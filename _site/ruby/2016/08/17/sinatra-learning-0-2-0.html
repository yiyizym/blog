<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>sinatra 0.2.0 源码学习</title>
  <meta name="description" content="声明">
  <link href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAMh/bAA4bHABP3OMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMAAAAAADMzMzMAAAADETMzETAAAAMRMzMRMAAAAzMzMzMwAAAAMzMzMwAAAAAzMzMzAAAAADMzMzMAAAAAMwAAMwAAAAMwAAADMAAAIwAAAAAyAAIgAAAAAAIgAAAAAAAAAAD//wAA//8AAP//AAD8PwAA8A8AAOAHAADgBwAA4AcAAPAPAADwDwAA8A8AAPPPAADn5wAAz/MAAJ/5AAD//wAA" rel="icon" type="image/x-icon" />
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://judes.me/ruby/2016/08/17/sinatra-learning-0-2-0.html">
  <link rel="alternate" type="application/rss+xml" title="jude&#39;s life" href="/feed.xml">
  
  

  
  <script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js',{scope: '/'}).then(function(registration) {
      // Registration was successful
      console.log('ServiceWorker registration successful with scope: ', registration.scope);
    }).catch(function(err) {
      // registration failed :(
      console.log('ServiceWorker registration failed: ', err);
    });
  }
</script>
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">jude&#39;s life</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">关于</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">sinatra 0.2.0 源码学习</h1>
    <p class="post-meta"><time datetime="2016-08-17T05:21:48+08:00" itemprop="datePublished">Aug 17, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="声明">声明</h2>

<p>本文系 <strong>sinatra 源码系列</strong>第 4 篇。系列的目的是通过 sinatra 学习 ruby 编程技巧。文章按程序运行的先后顺序挑重点分析，前一篇文章分析过的略去不说。水平很有限，所写尽量给出可靠官方/讨论链接，不坑路人。</p>

<h2 id="重要提醒">重要提醒</h2>

<p><strong>一定要先安装 1.8 版本的 ruby</strong> ，因为 1.9+ 的 ruby ，String 的实例是不响应 each 方法的，这会直接导致 rack 报错。可以使用 <a href="https://rvm.io/">rvm</a> 安装 1.8.7 版本的 ruby ，如果使用 rvm ，请先升级到最新版本，否则安装 1.8.7 的 ruby 时也会报错。</p>

<p>使用命令 <code class="highlighter-rouge">git log -1 --format=%ai 0.2.0</code> ，查看 0.2.0 版本 sinatra 的“出厂日期”，得到 <code class="highlighter-rouge">2008-04-11 16:29:36 -0700</code> ；而 1.8.7 版本的 ruby 是 2008 年 5 月发布的，两者兼容性应该比较好。</p>

<p>列一下本人运行 sinatra 0.2.0 用到的 ruby 和关键 gem 的版本：</p>

<ul>
  <li>ruby-1.8.7-p374</li>
  <li>rack 1.4.1</li>
  <li>mongrel 1.1.5</li>
</ul>

<h2 id="change-log">change log</h2>

<ul>
  <li>大重构，把功能模块都压缩在一个文件中</li>
  <li>增加大量测试用例</li>
</ul>

<h2 id="跑通所有测试用例">跑通所有测试用例</h2>

<p>首先修改一处代码错误，在 sinatra.rb 文件的 1022 行，将 <code class="highlighter-rouge">Rack::File::MIME_TYPES[ext.to_s] = type</code> 改为 <code class="highlighter-rouge">Rack::Mime::MIME_TYPES[ext.to_s] = type</code></p>

<p>然后安装一些缺少的 gem ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>gem install builder -v '2.1.2'
gem install sass -v '3.1.0'
gem install haml -v '1.8.0'
</code></pre>
</div>

<p>跑测试用例，发现只有 <code class="highlighter-rouge">sym_params_test.rb</code> 文件中的一处跑不通过。</p>

<p>此处的测试是验证可以用 String 和 Symbol 访问参数。实现的关键方法是：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># sinatra.rb 663 行
h = Hash.new { |h, k| h[k.to_s] if Symbol === k }
</code></pre>
</div>

<p>调用 <code class="highlighter-rouge">Hash.new</code> 时传进一个 block ，可以设置当访问某个不存在于 Hash 的 Key 时的一些默认行为，比如上面的代码就是说，当 key 不存在且是 Symbol 时，把 key 转换为字符串再找找（再抢救一下…）</p>

<p><code class="highlighter-rouge">Hash.new</code> 还可以用来初始化值为数组的键值对，在记录事件回调时很方便：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@events = Hash.new { |hash, key| hash[key] = [] }

# 出自这个版本的 sinatra.rb 的 738 行
# 再也不用先判断 key 是否存在，也不用手动初始化一个空数组了
</code></pre>
</div>

<p>回过头来修改代码以跑通测试用例，作者这里粗心写错了请求的方法，应该用 <code class="highlighter-rouge">post_it</code> ，而不是 <code class="highlighter-rouge">get_it</code> ，还要相应地修改路由：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>specify "should be accessable as Strings or Symbols" do
  post '/' do
    params[:foo] + params['foo']
  end
  
  post_it '/', :foo =&gt; "X"
  assert_equal('XX', body)
end
</code></pre>
</div>

<p>要在这个版本的 sinatra 的 get 方法中传递参数，需要把参数写在 uri 中，下面的写法也能通过测试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>specify "should be accessable as Strings or Symbols" do
  get '/' do
    params[:foo] + params['foo']
  end
  
  get_it '/?foo=X'
  assert_equal('XX', body)
end
</code></pre>
</div>

<h2 id="从-at_exit-说起">从 at_exit 说起</h2>

<p>还是从 at_exit 开始读代码。</p>

<p><code class="highlighter-rouge">$!</code> 记录异常信息，当调用 <code class="highlighter-rouge">raise</code> 的时候会设置这个变量，详见<a href="http://ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/variable.html#dquote">此处</a>。</p>

<p>调用 <code class="highlighter-rouge">load_options!</code> 解释完启动参数后， sinatra 在所有环境设置遇到异常和 404 时的回调方法，在开发环境遇到异常和 404 的回调方法比其他环境暴露更多的信息。</p>

<h3 id="openstruct">OpenStruct</h3>

<p>值得细看的是在非开发环境遇到异常时的回调方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>error do
  raise request.env['sinatra.error'] if Sinatra.options.raise_errors
  '&lt;h1&gt;Internal Server Error&lt;/h1&gt;'
end
</code></pre>
</div>

<p><code class="highlighter-rouge">Sinatra.options</code> 实际上是 <code class="highlighter-rouge">OpenStruct</code> 的实例。 <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/ostruct/rdoc/OpenStruct.html"><code class="highlighter-rouge">OpenStruct</code></a> 与 <code class="highlighter-rouge">Hash</code> 相似，但它通过元编程提供了不少快捷访问、设置值的方法。 <code class="highlighter-rouge">OpenStruct</code> 用法举例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 1
person = OpenStruct.new
person.name    = "John Smith"
p person.name    #=&gt; "John Smith"

# 2
person = OpenStruct.new(:name =&gt; "John Smith")
p person.name    #=&gt; "John Smith"
</code></pre>
</div>

<p>一个简单版本的 <code class="highlighter-rouge">OpenStruct</code> 实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class OpenStruct
  attr_accessor :h
  def initialize(hash = {})
    @h = hash

    h.each do |key, value|
      self.class.send(:define_method, key) do
        h[key]
      end
      self.class.send(:define_method, "#{key}=") do |value|
        h[key] = value
      end
    end
  end
  
  def method_missing(m, *args)
    if args.size == 1
      # m is  :name=
      # change m to :name
      h[m.to_s.chop.to_sym] = args[0]
    elsif args.size == 0
      h[m]
    end
  end

  def respond_to?(m)
    h.respond_to?(m) || super
  end

end

require 'test/unit'

class TestOS &lt; Test::Unit::TestCase
  def setup
    @person_1 = OpenStruct.new
    @person_2 = OpenStruct.new(:name =&gt; 'zhu')
  end

  def test_case_1
    assert_equal true, @person_1.respond_to?(:name)
    assert_equal nil, @person_1.name
    @person_1.name = 'zhu'
    assert_equal 'zhu', @person_1.name
  end

  def test_case_2
    assert_equal true, @person_2.respond_to?(:name)
    assert_equal 'zhu', @person_2.name
    @person_2.name = 'jude'
    assert_equal 'jude', @person_2.name
  end
end
</code></pre>
</div>

<p>以上只是我心血来潮写的， <code class="highlighter-rouge">OpenStruct</code> 的实现远远不是上面写的那么简单，有兴趣可以看看源码。</p>

<p><code class="highlighter-rouge">Sinatra.options.raise_errors</code> 的值只能在代码里设置，当其值不为 nil 或 false 时，默认在非开发环境下直接抛出异常。要想在命令行启动时设置值，只需要在 <code class="highlighter-rouge">load_options!</code> 方法中添加一行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>op.on('-r') { |env| default_options[:raise_errors] = true }
</code></pre>
</div>

<p>在订制开发环境下的异常和 404 页面时，使用到 <code class="highlighter-rouge">%Q(...)</code> 。 ruby 会特殊处理以百分号 ‘%’ 开头的字符串，帮你省去不少转义引号的麻烦：</p>

<blockquote>
  <p>The string expressions begin with % are the special form to avoid putting too many backslashes into quoted strings. <a href="http://ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html">出处</a></p>
</blockquote>

<p>更多相似的用法见<a href="https://ruby-china.org/topics/18512">Ruby 里的 %Q, %q, %W, %w, %x, %r, %s, %i</a>。</p>

<p>在显示异常信息时，用 <code class="highlighter-rouge">escap_html</code> 来转义 <code class="highlighter-rouge">&amp;</code>,<code class="highlighter-rouge">&lt;</code>,<code class="highlighter-rouge">&gt;</code>,<code class="highlighter-rouge">/</code>,<code class="highlighter-rouge">'</code>,<code class="highlighter-rouge">"</code> ，把这些 ascii 字符编码成实体编码，防止 XSS 攻击，不过源码有注释说有 bug ：</p>

<blockquote>
  <p>On 1.8, there is a kcode = ‘u’ bug that allows for XSS otherwhise</p>
</blockquote>

<p>源码中用正则表达式替换转义字符的<a href="https://github.com/rack/rack/blob/1.4.1/lib/rack/utils.rb#L181">实现</a>值得参考。</p>

<p>更多关于 XSS 的知识，可以看看本人之前写的<a href="http://judes.me/2015/10/02/xss-study/">这篇</a>。</p>

<h3 id="lookup">lookup</h3>

<p>接下来看 Application 的 call 方法。</p>

<p>首先由 <code class="highlighter-rouge">lookup</code> 方法实现根据请求找到正确的路由。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def lookup(request)
  method = request.request_method.downcase.to_sym
  events[method].eject(&amp;[:invoke, request]) ||
    (events[:get].eject(&amp;[:invoke, request]) if method == :head) ||
    errors[NotFound].invoke(request)
end
</code></pre>
</div>

<p>sinatra 在 <code class="highlighter-rouge">Enumerable</code> 上扩展了 <code class="highlighter-rouge">eject</code> 方法，因为 <code class="highlighter-rouge">Array</code> 加载了 <code class="highlighter-rouge">Enumberable</code> 模块，所以 <code class="highlighter-rouge">Array</code> 实例能用 <code class="highlighter-rouge">eject</code> 方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def eject(&amp;block)
  find { |e| result = block[e] and break result }
end
</code></pre>
</div>

<p>在 <code class="highlighter-rouge">eject</code> 方法内部，使用 <code class="highlighter-rouge">find</code> 方法找到第一个产生非 false 结果的 block ，并返回这个结果。<code class="highlighter-rouge">find</code> 方法本来会返回第一个符合条件的元素，通过 <code class="highlighter-rouge">break</code> 可以订制自己的返回值。</p>

<p>这里 <code class="highlighter-rouge">e</code> 是 Event 的实例。 <code class="highlighter-rouge">block</code> 是由 Array 实例转化而来的 Proc 。</p>

<p>系列<a href="http://judes.me/2016/06/12/sinatra-learning-0-0-1/">第一篇文章</a>提到过， 如果跟在 <code class="highlighter-rouge">&amp;</code> 后面对象的不是 Proc ，首先会调用这个对象的 <code class="highlighter-rouge">to_proc</code> 方法得到一个 Proc 实例，最后会调用这个 Proc 的 <code class="highlighter-rouge">call</code> 方法。</p>

<p>sinatra 扩展了 Array 的 <code class="highlighter-rouge">to_proc</code> 方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def to_proc
  Proc.new { |*args| args.shift.__send__(self[0], *(args + self[1..-1])) }
end
</code></pre>
</div>

<p>经过 <code class="highlighter-rouge">to_proc</code> 转换， <code class="highlighter-rouge">Proc#call</code> 把参数转换为一个数组，把这个数组第一个元素作为 <code class="highlighter-rouge">receiver</code> ，把调用 <code class="highlighter-rouge">to_proc</code> 方法的数组的第一个元素作为方法，把两个数组余下的元素作为方法的参数，拿前面的代码作例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 在 lookup 方法里下面的这行代码

&amp;[:invoke, request]

# 会得到这样一个 Proc

#=&gt; Proc.new { |*args| args.shift.__send__(:invoke, *(args + [request])) }

# 在 eject 方法定义中

find { |e| result = block[e] and break result }

# block[e] 就是把 e 当作参数调用  Proc#call ，做的事情是： 以 `request` 作为参数，调用 `e` 的 `invoke` 方法。
</code></pre>
</div>

<p><code class="highlighter-rouge">block[e]</code> 不能写成 <code class="highlighter-rouge">block(e)</code> ，否则 ruby 会把 <code class="highlighter-rouge">block</code> 当作是 main 的一个方法来调用。有三种方法可以调用 <a href="https://ruby-doc.org/core-2.2.0/Proc.html#method-i-5B-5D"><code class="highlighter-rouge">Proc#call</code></a> ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 1
 a_proc.call()
# 2
 a_proc.()
# 3
 a_proc[]
</code></pre>
</div>

<h3 id="invoke">invoke</h3>

<p><code class="highlighter-rouge">Event#invoke</code> 方法实现路由匹配和参数匹配。除了可以匹配路径，这个版本的 sinatra 还可以匹配 user_agent 和 host :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if agent = options[:agent] 
  return unless request.user_agent =~ agent
  params[:agent] = $~[1..-1]
end
if host = options[:host] 
  return unless host === request.host
end
</code></pre>
</div>

<p>用法和测试举例如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>require 'sinatra'

get '/path', :agent =&gt; /Windows/
  request.env['HTTP_USER_AGENT']
end
# get_it '/', :env =&gt; { :agent =&gt; 'Windows' }
# should.be.ok
# body.should.equal 'Windows'

# get_it '/', :agent =&gt; 'Mac'
# should.not.be.ok



get '/path', {}, HTTP_HOST =&gt; 'foo.test.com'
  'in foo'
end

get '/path', {}, HTTP_HOST =&gt; 'bar.test.com'
  'in bar'
end

# get_it '/foo', {}, 'HTTP_HOST' =&gt; 'foo.test.com'
# assert ok?
# assert_equal 'in foo', body

# get_it '/foo', {}, 'HTTP_HOST' =&gt; 'bar.test.com'
# assert ok?
# assert_equal 'in bar', body

# get_it '/foo'
# assert not_found?
</code></pre>
</div>

<p><code class="highlighter-rouge">request.user_agent</code> 最终调用 <code class="highlighter-rouge">env['HTTP_USER_AGENT']</code> ，在 /lib/sinatra/test/methods.rb 中， sinatra 重写了 <code class="highlighter-rouge">Rack::MockRequest#env_for</code> 方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Rack::MockRequest
  class &lt;&lt; self
    alias :env_for_without_env :env_for
    def env_for(uri = "", opts = {})
      env = { 'HTTP_USER_AGENT' =&gt; opts.delete(:agent) }
      env_for_without_env(uri, opts).merge(env)
    end
  end
end
</code></pre>
</div>

<p>这样在测试时就可以传递 <code class="highlighter-rouge">:agent =&gt; 'Windows'</code> 作为 user_agent 的参数，否则要这样写： <code class="highlighter-rouge">'HTTP_USER_AGENT' =&gt; 'Windows'</code> 。</p>

<h4 id="call-the-overridden-method-from-the-new">call the overridden method from the new</h4>

<p>在 ruby 中重写一个方法，新方法中还要调用未被重写前的旧方法，有几个技巧。</p>

<p>一，继承。需要修改每一处用到新方法的 reciever 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Foo
  def say
    'Hello'
  end
end

class Bar &lt; Foo
  def say
    super + ' World!'
  end
end

Foo.new.say #=&gt; 'Hello'
Bar.new.say #=&gt; 'Hello World!'
# 把 reciever 从 Foo 改为 Bar
</code></pre>
</div>

<p>二，修改祖先链。这与继承类似，但修改的方向不一样。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>moudle Bar
  def say
    super + ' World!'
  end
end

class Foo
  prepend Bar
  def say
    'Hello'
  end
end

Foo.new.say #=&gt; 'Hello World!'

# 使用了 prepend 把 Bar 放在 Foo 祖先链的下游，当寻找 say 方法时，首先找到 Bar 定义的 say 方法
</code></pre>
</div>

<p>三，使用 <a href="http://ruby-doc.org/core-1.9.3/UnboundMethod.html#method-i-bind">UnboundMethod</a>  和 <code class="highlighter-rouge">define_method</code> 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Foo
  def say
    'Hello'
  end
end

# 在某处重新打开 Foo

class Foo
  old_say = instance_method(:say)
  define_method(:say) do
    old_say.bind(self)[] + ' World!'
    # 调用 instance_method 得到一个 UnboundMethod ，你需要在调用它之前 bind 一个 Foo 的实例
    # 前面说过调用 Proc#call 的三种方法，调用 Method#call 也是一样。这里采用了 [] ，你也可以用 .()
  end
end
</code></pre>
</div>

<p>四， alias 。就是 sinatra 采用的方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Foo
  def say
    'Hello'
  end
end

# 在某处重新打开 Foo

class Foo
  alias :old_say :say
  def say
    old_say + ' World!'
  end
end

Foo.new.say #=&gt; 'Hello World!'
Foo.new.old_say #=&gt; 'Hello'
# 使用这种技巧，仍然可以访问旧的方法
</code></pre>
</div>

<p>更多的技巧，可参考<a href="http://stackoverflow.com/questions/4470108/when-monkey-patching-a-method-can-you-call-the-overridden-method-from-the-new-i">这里</a>。</p>

<p>继续看 <code class="highlighter-rouge">Event#invoke</code> 的实现，下面代码这行实现匹配路径：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>return unless pattern =~ request.path_info.squeeze('/')
</code></pre>
</div>

<p><code class="highlighter-rouge">String#squeeze</code> 方法用单个字符替换连续出现的字符，用法很灵活，参见<a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-squeeze">文档</a>。</p>

<p>sinatra 实现路径匹配的参数匹配的思路是：</p>

<ul>
  <li>将用户预先定义的路径转换为正则表达式</li>
  <li>用这些正则表达式去匹配实际请求的路径</li>
  <li>如果匹配成功，则把捕获的参数与定义的参数组成键值对保存起来</li>
</ul>

<p><code class="highlighter-rouge">Event#initialize</code> 实现了路径转换正则表达式：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>URI_CHAR = '[^/?:,&amp;#\.]'.freeze unless defined?(URI_CHAR)
PARAM = /:(#{URI_CHAR}+)/.freeze unless defined?(PARAM)
SPLAT = /(.*?)/
attr_reader :pattern

def initialize(path, options = {}, &amp;b)
  @path = URI.encode(path)
  @param_keys = []
  regex = @path.to_s.gsub(PARAM) do
    @param_keys &lt;&lt; $1
    "(#{URI_CHAR}+)"
  end
  
  regex.gsub!('*', SPLAT.to_s)
  
  @pattern = /^#{regex}$/
end
</code></pre>
</div>

<p>首先把用户定义的路径编码成 URI ，因为 <a href="http://www.ietf.org/rfc/rfc1738.txt">rfc1738</a> 文档规定在 URL 中出现的字符只能是 字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’() 以及一些保留字符：</p>

<blockquote>
  <p>only alphanumerics, the special characters “$-_.+!*’(),”, and reserved characters sed for their reserved purposes may be used unencoded within a URL.</p>
</blockquote>

<p>如果在路径或查询参数中出现其他字符，比如中文，需要先转义。</p>

<p>然后把用户在定义路径中的参数找出来，替换为去掉冒号（:）后的正则表达式字符串。</p>

<p><code class="highlighter-rouge">PARAM</code> 正则表达式———— <code class="highlighter-rouge">/:([^/?:,&amp;#\.]+)/</code>———— 匹配以冒号开头的，接下来的字符不是 <code class="highlighter-rouge">/ ? : , &amp; # .</code> 当中任意一个字符的字符串。</p>

<p><code class="highlighter-rouge">$1</code> 保存了最近一次正则表达式捕获的第一个匹配结果。</p>

<p>用户还可以定义不具名参数： ‘*’ ，这个功能还不完善，现阶段只能作占位符用，没法获取捕获的参数。</p>

<p>接下来的事情就是把捕获的参数与定义的参数组成键值对保存在 <code class="highlighter-rouge">params</code> 中，之前的系列文章有说过。</p>

<p>保存好参数后，调用 <code class="highlighter-rouge">Result.new(block, params, 200)</code> 生成 <code class="highlighter-rouge">Result</code> ，它是 <code class="highlighter-rouge">Struct</code> 的实例。跟 <code class="highlighter-rouge">OpenStruct</code> 不同， <code class="highlighter-rouge">Struct</code> 只能读、写在初始化时设定的 key ，不能新增 key ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Bar = Struct.new(a,b)
bar = Bar.new(1,2)
bar.a #=&gt; 1
bar.c #=&gt; undefined method `c' for #&lt;struct Bar a=1, b=2&gt;
</code></pre>
</div>

<p>sinatra 能正确响应 HEAD 请求方法。根据 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">rfc 文档</a>， HEAD 方法跟 GET 方法唯一的区别就是，响应 HEAD 方法时，响应报文不能带有 body 。响应报文的头应该跟 GET 方法的一致。 HEAD 方法主要用于验证资源的有效性、可用性以及最近是否修改过。</p>

<p>如上所述，如果是 HEAD 请求， sinatra 会自动去找对应的 GET 方法回调：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(events[:get].eject(&amp;[:invoke, request]) if method == :head)
</code></pre>
</div>

<p>在生成 HEAD 请求的响应时，会设置 body 为空字符：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># line 839
body = '' if request.request_method.upcase == 'HEAD'
</code></pre>
</div>

<h3 id="to_result">to_result</h3>

<p>在获取响应的 body 时，不论是正常流程，还是异常流程，都调用了 <code class="highlighter-rouge">to_result</code> 方法。 sinatra 在很多类中都扩展了这个实例方法。</p>

<p>正常流程的代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>returned = run_safely do
  catch(:halt) do
    filters[:before].each { |f| context.instance_eval(&amp;f) }
    [:complete, context.instance_eval(&amp;result.block)]
  end
end
body = returned.to_result(context)
# 一切正常时， returned 是 [:complete, context.instance_eval(&amp;result.block)]
</code></pre>
</div>

<p>与此相关的两个 <code class="highlighter-rouge">to_result</code> 方法是：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Array
  def to_result(cx, *args)
    self.shift.to_result(cx, *self)
  end
end

class Symbol
  def to_result(cx, *args)
    cx.send(self, *args)
  end
end
</code></pre>
</div>

<p><code class="highlighter-rouge">returned.to_result(context)</code> 最终是在 <code class="highlighter-rouge">context</code> 上调用 <code class="highlighter-rouge">complete</code> 方法，传入的参数是 <code class="highlighter-rouge">context.instance_eval(&amp;result.block)</code> 的返回值。</p>

<p>异常流程，如在 before filters 中抛出 <code class="highlighter-rouge">:halt</code> ，在 README.doc 文档中详细说明了多种情况：</p>

<blockquote>
  <p>Set the body to the result of a helper method</p>
</blockquote>

<blockquote>
  <p>throw :halt, :helper_method</p>
</blockquote>

<blockquote>
  <p>Set the body to the result of a helper method after sending it parameters from the local scope</p>
</blockquote>

<blockquote>
  <p>throw :halt, [:helper_method, foo, bar]</p>
</blockquote>

<blockquote>
  <p>Set the body to a simple string</p>
</blockquote>

<blockquote>
  <p>throw :halt, ‘this will be the body’</p>
</blockquote>

<blockquote>
  <p>Set status then the body</p>
</blockquote>

<blockquote>
  <p>throw :halt, [401, ‘go away!’]</p>
</blockquote>

<blockquote>
  <p>Set the status then call a helper method with params from local scope</p>
</blockquote>

<blockquote>
  <p>throw :halt, [401, [:helper_method, foo, bar]]</p>
</blockquote>

<blockquote>
  <p>Run a proc inside the Sinatra::EventContext instance and set the body to the result</p>
</blockquote>

<blockquote>
  <p>throw :halt, lambda { puts ‘In a proc!’; ‘I just wrote to $stdout!’ }</p>
</blockquote>

<p>在众多应对以上情况的 <code class="highlighter-rouge">to_proc</code> 中，值得一提的是以下这两个：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class String
  def to_result(cx, *args)
    args.shift.to_result(cx, *args)
    self
  end
end

class NilClass
  def to_result(cx, *args)
    ''
  end
end
</code></pre>
</div>

<p><code class="highlighter-rouge">throw :halt, 'this will be the body'</code> 之后，最终会用到 <code class="highlighter-rouge">String#to_result</code> 方法，传入的参数只有一个 <code class="highlighter-rouge">context</code> ，因此 <code class="highlighter-rouge">args</code> 是个空数组， <code class="highlighter-rouge">args.shift</code> 得到 <code class="highlighter-rouge">nil</code> ，所以得扩展 <code class="highlighter-rouge">NilClass#to_result</code> ，但它什么也没做，径直返回空字符串。</p>

<h3 id="contextbody">context.body</h3>

<p>在处理返回报文的正文时，有如下代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>context.body = body.kind_of?(String) ? [*body] : body
</code></pre>
</div>

<p><code class="highlighter-rouge">kind_of?</code> 方法跟 <code class="highlighter-rouge">is_a?</code> 一样，回溯祖先链，找到祖先返回 true ，否则返回 false 。</p>

<p><code class="highlighter-rouge">[*body]</code> 中的 <code class="highlighter-rouge">*</code> （splat operator）有很多用途，之前也说过它可以把函数的多个参数变为一个数组。此处是另外两种用法。</p>

<p>其一是强制类型转换，把当前类型转换为 Array 类型：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># Range 转换为 Array
a = *(1..3) #=&gt; [1,2,3]

# String 转换为 Array
b = *"one string" #=&gt; ["one string"]

# Array 仍然是 Array
c = *[1,2,3] #=&gt; [1,2,3]

# nil 转换为 Array
d = *nil #=&gt; []
</code></pre>
</div>

<p>其二是展平数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>e = [*[1,2],*[3,4]] #=&gt; [1,2,3,4]

# 这跟下面是一样的

f = [[1,2],[3,4]].flatten
</code></pre>
</div>

<p>回头看 <code class="highlighter-rouge">[*body]</code> ，如果只是把字符串强制转换为数组的话， <code class="highlighter-rouge">*body</code> 就够了。但是这里必须用中括号（<code class="highlighter-rouge">[]</code>）包着，否则会报语法错误。用中括号包住，解决了语法问题，得到的还是原来的那个数组。</p>

<p><code class="highlighter-rouge">*</code> 实际上并不是 operator ，而是 token ，而且很容易就会用错。大致有以下几种用法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 用于赋值

first, *rest = [1,2,3]
#=&gt; first = 1
#=&gt; rest = [2,3]

*rest, last = [1,2,3]
#=&gt; last = 3
#=&gt; rest = [1,2]

first, *m, last = [1,2,3,4]

# 收集参数，分解参数

def foo(first, *args); end #=&gt; *args 只能放在最后
foo(1,2,3,4) #=&gt; args = [2,3,4]

def bar(a, b); end
bar(*[1,2]) #=&gt; a = 1, b = 2

# 强制类型转换，很容易出语法错误，所以最好用中括号包住
</code></pre>
</div>

<p><code class="highlighter-rouge">context#body</code> 由在 Class 类中的 <code class="highlighter-rouge">dslify_writer</code> 方法实现：写入 body 的值，并返回这个值。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Class
  def dslify_writer(*syms)
    syms.each do |sym|
      class_eval &lt;&lt;-end_eval
        def #{sym}(v=nil)
          self.send "#{sym}=", v if v
          v
        end
      end_eval
    end
  end
end

class Foo
  dslify_writer :bar
  # 相当于这样写：
  # def bar(v=nil)
  #   self.send('bar=', v) if v
  #   v
  # end
end
</code></pre>
</div>

<p><code class="highlighter-rouge">context</code> 并没有实现 <code class="highlighter-rouge">body=</code> 方法，但它有实现 <code class="highlighter-rouge">method_missing</code> 方法，把找不到的 method 转发给 <code class="highlighter-rouge">@response</code> ，而 <code class="highlighter-rouge">@response</code> 是 <code class="highlighter-rouge">Rack::Response</code> 的实例，可以读写 <code class="highlighter-rouge">body</code> 。</p>

<p>本小节参考文章：</p>

<ul>
  <li><a href="http://blog.honeybadger.io/ruby-splat-array-manipulation-destructuring/">Using splats to build up and tear apart arrays in Ruby</a></li>
  <li><a href="http://jacopretorius.net/2012/01/splat-operator-in-ruby.html">Splat Operator in Ruby</a></li>
  <li><a href="https://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/">The Strange Ruby Splat</a></li>
  <li><a href="http://stackoverflow.com/questions/776462/where-is-it-legal-to-use-ruby-splat-operator">Where is it legal to use ruby splat operator?</a></li>
</ul>

<h3 id="contextfinish">context.finish</h3>

<p><code class="highlighter-rouge">context.finish</code> 也是转发到 <code class="highlighter-rouge">response.finish</code> ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def finish(&amp;block)
  @block = block

  if [204, 205, 304].include?(status.to_i)
    header.delete "Content-Type"
    header.delete "Content-Length"
    [status.to_i, header, []]
  else
    [status.to_i, header, self]
  end
end
</code></pre>
</div>

<p>包含以下<a href="https://zh.wikipedia.org/wiki/HTTP状态码">状态码</a>的响应会被删除响应头的 Content-Type / Content-Length 字段：</p>

<ul>
  <li>204 No Content ，服务器成功处理了请求，但不需要返回任何实体内容，浏览器不产生任何文档视图上的变化</li>
  <li>205 Reset Content ，服务器成功处理了请求，但不需要返回任何实体内容，浏览器要重置文档视图，比如重置表单</li>
  <li>304 Use Proxy ，被请求的资源必须通过指定的代理——在 location 字段中指定——才能被访问</li>
</ul>

<p>并且返回数组中的第三个元素是个空数组，表明响应正文为空。</p>

<p>其他状态码返回数组中的第三个元素是 <code class="highlighter-rouge">self</code> ，能这样做的前提是 response 实现了 <code class="highlighter-rouge">each</code> 方法。</p>

<h3 id="设置-body">设置 body</h3>

<p>application_test.rb 里有一个测试用例如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class TesterWithEach
  def each
    yield 'foo'
    yield 'bar'
    yield 'baz'
  end
end

specify "an objects result from each if it has it" do

  get '/' do
    TesterWithEach.new
  end
  
  get_it '/'
  should.be.ok
  body.should.equal 'foobarbaz'

end
</code></pre>
</div>

<p>如果没有在 get block 中设置 body 值， sinatra 就会用 block 的返回值作为 body ，如果这个返回值不响应 <code class="highlighter-rouge">each</code> 方法， body 就会被设置为空字符。可以模仿这里的 <code class="highlighter-rouge">TesterWithEach#each</code> 实现一个简单的 <code class="highlighter-rouge">each</code> ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Foo
  attr_reader :bar
  
  def initialize(*bar)
    @bar = bar
  end
  
  def each
    return nil unless block_given?
    i = 0
    while i &lt; bar.length
      yield bar[i]
      i += 1
    end
  end
end

# foo = Foo.new(1,2,3,4)
# foo.each { |i| p i  }
</code></pre>
</div>

<p>目前为止， sinatra 的基本功能都已经实现，剩下的扩展功能——如重定向、渲染xml/erb/sass/haml、传输文件等等——都是通过加载模块来实现。</p>

<h2 id="streaming">Streaming</h2>

<p>这一模块取自 ActionPack ，目的是用更少的内存消耗传输更大的文件，大体的做法是用流传输取代一次性输出整个文件。</p>

<p>实现 Streaming 的关键代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class FileStreamer
  
  #...

  def to_result(cx, *args)
    self
  end
  
  def each
    File.open(path, 'rb') do |file|
      while buf = file.read(options[:buffer_size])
        yield buf
      end
    end
  end
  #...

end

#...

def send_file(path, options = {})

  #...

  if options[:stream]
    throw :halt, [options[:status] || 200, FileStreamer.new(path, options)]
  else
    File.open(path, 'rb') { |file| throw :halt, [options[:status] || 200, file.read] }
  end

end
</code></pre>
</div>

<p>如果 <code class="highlighter-rouge">options[:stream]</code> 为 true 则通过自身的 <code class="highlighter-rouge">each</code> 方法每读入 4096 个字节就对外输出，否则一次性读入内存再输出。</p>

<h3 id="protected">protected</h3>

<p>Streaming 模块中有两个 protected 方法。 ruby 的 protected 跟 java 的很像，一般情况下被设置为 protected 的实例方法只能从类（或子类）实例方法中访问。（借助 <code class="highlighter-rouge">send</code> 方法可以突破这层限制）</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Person

  def initialize(age)
    @age = age
  end

  def older_than?(other_person)
    if self.class == other_person.class
      age &gt; other_person.age
    end
  end
  
  protected

  attr_reader :age

end

class Monkey

  def initialize(age)
    @age = age
  end

  def older_than?(person)
    age &gt; person.age
  end
  
  protected

  attr_reader :age
end

p1 = Person.new(10)
p2 = Person.new(11)
p1.older_than?(p2) #=&gt; false

# p1.age #=&gt; protected method `age' called for #&lt;Person:0x007f80cc0263c8 @age=10&gt; (NoMethodError)

m1 = Monkey.new(13)

# m1.older_than?(p1) #=&gt; protected method `age' called for #&lt;Person:0x007fd3e4963880 @age=10&gt; (NoMethodError)
</code></pre>
</div>

<p>ruby 的 protected 方法很少用到，如果要用的话，通常用于同类之间的比较（参见上面的 Person 类）。</p>

<p>本小节参考文章：</p>

<ul>
  <li><a href="http://nithinbekal.com/posts/ruby-protected-methods/">When to Use Protected Methods in Ruby</a></li>
  <li><a href="https://tenderlovemaking.com/2012/09/07/protected-methods-and-ruby-2-0.html">Protected Methods and Ruby 2.0</a></li>
  <li><a href="http://devblog.orgsync.com/2013/05/20/private-and-protected-they-might-not-mean-what-you-think-they-mean/">Private and Protected: They might not mean what you think they mean</a></li>
</ul>

<h2 id="renderinghelpers">RenderingHelpers</h2>

<p>sinatra 渲染的过程大致可以分为两个步骤：</p>

<ul>
  <li>根据传进来的参数 (String/Symbol/Proc) ，找到对应的模板</li>
  <li>调用具体的渲染引擎渲染模板</li>
</ul>

<p>第一个步骤是共用的，抽出来形成 RenderingHelpers 。</p>

<p>RenderingHelpers 的实现体现了两个软件设计原则： 1. 依赖反转； 2. 开闭原则（对扩展开放，对修改闭合）。</p>

<p>举例说明一下本人所理解的依赖反转：把高层次的模块比作电器，把低层次的模块比作插座。要使两者配合起来为人所用，高层次的模块必须实现低层次模块指定的接口，这个接口就是特定的插头（或两脚或三脚）。</p>

<p>RenderingHelpers 对外提供 <code class="highlighter-rouge">render</code> 方法，但要使用 <code class="highlighter-rouge">render</code> 方法，必须实现 <code class="highlighter-rouge">render_renderer</code> 方法，这个 <code class="highlighter-rouge">render_renderer</code> 就是特定的插头。</p>

<p>这个版本的 sinatra 增加了多个渲染引擎的支持，这些引擎的实现细节各有不同（如 sass 不支持 layout），但增加这些引擎支持都不用修改 RenderingHelpers 里面的代码。你甚至可以加入自己的引擎，无需改动 RenderingHelpers ，只要它提供的 <code class="highlighter-rouge">render</code> 方法，并实现自己的 <code class="highlighter-rouge">render_renderer</code> 方法。这体现了开闭原则。</p>

<h3 id="use_in_file_templates">use_in_file_templates!</h3>

<p>渲染时需要的模板，除了可以放在别的文件中，还可以放在当前文件中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>get '/stylesheet.css' do
  header 'Content-Type' =&gt; 'text/css; charset=utf-8'
  sass :stylesheet
end

# 这里需要的模板可以放在 "views/stylesheet.sass" 文件中，假设包含以下内容

  #  body
  #    #admin
  #      :background-color #CCC

# 也可以放在当前文件中，需要事先调用 use_in_file_templates! ，如下：

use_in_file_templates！

__END__
## stylesheet
body
  #admin
    :background-color #CCC
</code></pre>
</div>

<p><code class="highlighter-rouge">use_in_file_templates！</code>实现的细节是首先找到调用 <code class="highlighter-rouge">use_in_file_templates！</code> 方法的文件。 <code class="highlighter-rouge">caller</code> 方法会以数组形式返回当前方法的调用栈，形式如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def a(skip)
  caller(skip)
end
def b(skip)
  a(skip)
end
def c(skip)
  b(skip)
end
c(0)   #=&gt; ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10"]
c(1)   #=&gt; ["prog:5:in `b'", "prog:8:in `c'", "prog:11"]
c(2)   #=&gt; ["prog:8:in `c'", "prog:12"]
c(3)   #=&gt; ["prog:13"]
</code></pre>
</div>

<p>然后把这个文件转换为字符串，定位到字符串的一个特殊标记。这里作者写错了这个特殊标记，应该是 <code class="highlighter-rouge">__END__</code> ，而不是 <code class="highlighter-rouge">__FILE__</code> 。虽然写成 <code class="highlighter-rouge">__FILE__</code> 也能跑过测试用例，但这个标记与 <code class="highlighter-rouge">__END__</code> 是完全不同的。</p>

<p>ruby 有一个特殊的常量 <a href="https://ruby-doc.org/core-2.3.1/Object.html"><code class="highlighter-rouge">DATA</code></a> ，它是一个 <code class="highlighter-rouge">File</code> 对象，包含了文件中的数据。你可以把数据和代码放在同一个文件当中， ruby 通过 <code class="highlighter-rouge">__END__</code> 这个标记分开代码和数据：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># t.rb
puts DATA.gets
__END__
hello world!

# ruby t.rb 
# =&gt; hello world!
</code></pre>
</div>

<p>定位到数据部分后，把这部分字符串转换为 <a href="http://stackoverflow.com/questions/12592234/what-are-the-advantages-to-using-stringio-in-ruby-as-opposed-to-string">StringIO</a> 对象，以便把字符串当作文件逐行解释。</p>

<p>只要匹配到以 <code class="highlighter-rouge">##</code> 开头的行，就把捕获的字符串当作新的模板名字，没匹配行的就当作是模板的内容。</p>

<p>全文完。</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">jude&#39;s life</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              jude zhu
            
            </li>
            
            <li><a href="mailto:yiyizym@163.com">yiyizym@163.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/yiyizym"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">yiyizym</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>记录生活的点点滴滴
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
