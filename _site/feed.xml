<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.4.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-03-11T16:01:31+08:00</updated><id>http://localhost:4000//</id><title type="html">jude’s life</title><subtitle>记录生活的点点滴滴
</subtitle><author><name>jude zhu</name></author><entry><title type="html">人类砍头的花边历史</title><link href="http://localhost:4000/reading/2017/03/10/history_of_human_beheaded.html" rel="alternate" type="text/html" title="人类砍头的花边历史" /><published>2017-03-10T07:48:07+08:00</published><updated>2017-03-10T07:48:07+08:00</updated><id>http://localhost:4000/reading/2017/03/10/history_of_human_beheaded</id><content type="html" xml:base="http://localhost:4000/reading/2017/03/10/history_of_human_beheaded.html">&lt;p&gt;说到砍头，就想起刑场上一个个跪着的身着白囚衣，被五花大绑，脖子上还插着一块木板的的犯人。到正午行刑时候，刽子手大刀一挥，就见一碗热血泼洒在地上。&lt;/p&gt;

&lt;p&gt;砍头往往被影视作品如此刻板描画着，以致刚看到这本《人类砍头小史》时，不敢相信这个动作还可以成书。更意外的是，读者们的评价还很不错。&lt;/p&gt;

&lt;p&gt;也按捺不住好奇心看了下，我承认这种心态，就似 18 世纪时欧洲那些在远处围观斩首的群众，如果可以的话，自己或许会争取再靠近一点的位置看看这段历史。&lt;/p&gt;

&lt;p&gt;下面是一些从书中摘录下来的片段，用现代人的眼光来看，那是一段既熟悉，又陌生的历史。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;变质的干缩人头：从有利可图到滥竽充数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;19 世纪末，南美的土著人有“猎头”习俗：杀死敌人，割下首级，制成干缩人头。这些土著人认为，一旦通过仪式取出干缩人头内藏着强大力量之后，干缩人头就没有价值了。但对欧洲人来说有价值的不是人头里的那股力量，而是干缩人头本身：一个干缩人头可以卖很多钱。他们从土著手上大量采购，人头很快就供不应求，“猎头”迅速从习俗变成赤裸血腥的杀戮：首先是土著人的敌对部落的女人、孩子，然后是倒霉的欧洲游客，最后是无辜的猴子。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;战场上的无头亡者&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1984年从马里亚纳群岛被送回本国的日本战死者当中，有 60% 的尸体丢失了头颅。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这些丢失的头颅有不少是被美国大兵砍下来的，此外恐怕就是被炮弹炸飞。&lt;/p&gt;

&lt;p&gt;那片战场到处散落半掩着破碎肢体，时刻弥漫着腐败恶臭，人要活着变得变成魔鬼：切下对方头颅宣示自己最后的胜利；把对方头颅制成骷髅，有的被当作玩具、送给女朋友的礼物，还有的最后跟活着的人成了朋友。&lt;/p&gt;

&lt;p&gt;不远处的海面上空，蜂蛹而至的神风战斗机在炮火中爆裂，血如雨下，大大小小人体碎块如冰雹弹落在战舰甲板上，铺满一层：手臂、心脏、肠子、脑浆……&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ISIS 的最爱&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;既保留着砍头这个历史悠久的野蛮行径，又与时俱进地搞全球视频播放的就只有 ISIS 了。但在围观砍头这件事上，如今的人跟 18 世纪甚至更早（中世纪）的人似乎并没有本质的不同。&lt;/p&gt;

&lt;p&gt;对人们来说，透过屏幕围观斩首，既不会被指责袖手旁观，又满足了好奇心；对运营视频的网站来说，这是绝好的带来流量广告的机会。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;人血馒头不止 MADE IN CHINA&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在鲁迅笔下，围观行刑的国人“頸項都伸得很長，仿佛許多鴨，被無形的手捏住了的，向上提著”。这冷漠有力的笔触同样可以用来描画在那不久之前的西方世界，兴许还得再添加一点魔幻色彩：华老栓要是能够穿越到几十年前（1869年）的丹麦，要把钱交给刽子手，得先穿过一大群“准备痛饮从那还在颤抖的身体中流出的鲜血”的癫痫病患者呢。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;人一出名，这头就保不住了&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作曲家贝多芬、莫扎特和舒伯特都丢掉了自己的骷髅，落入了崇拜者之手。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;贝多芬、莫扎特和舒伯特他们的脑袋好歹还能在土里静静待上 10 来年，可怜的海顿刚躺下没几天就被掘坟枭首。&lt;/p&gt;

&lt;p&gt;在 19 世纪，人们对天才的颅骨产生巨大的兴趣，诡异的是，他们只打算把这些颅骨当成某样看不懂的宝物一样收藏展览，而没有去研究天才的颅骨与普通人有何不同。及至开始研究人头，却让“颅相学”风靡一时。人类科学发展史有些片段可谓是很傻很天真呢。&lt;/p&gt;</content><author><name>jude zhu</name></author><summary type="html">说到砍头，就想起刑场上一个个跪着的身着白囚衣，被五花大绑，脖子上还插着一块木板的的犯人。到正午行刑时候，刽子手大刀一挥，就见一碗热血泼洒在地上。</summary></entry><entry><title type="html">雪花分形，一次从前到后的尝试</title><link href="http://localhost:4000/tech/2017/03/07/snow_flake_app.html" rel="alternate" type="text/html" title="雪花分形，一次从前到后的尝试" /><published>2017-03-07T08:06:50+08:00</published><updated>2017-03-07T08:06:50+08:00</updated><id>http://localhost:4000/tech/2017/03/07/snow_flake_app</id><content type="html" xml:base="http://localhost:4000/tech/2017/03/07/snow_flake_app.html">&lt;p&gt;&lt;strong&gt;缘起&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很久之前，我写下一篇介绍“雪花分形”写作理论的文章。我觉得可以做一个让人方便地用上这个理论写作的工具，甚至一度幻想着可以靠它提供的服务来赚点钱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我打算先做一个原型。原型的话，网页最容易做。在技术选型时原本可以抓起身边的 Bootstrap 和 jQuery 撸起袖子就是干的，但我不想依靠思维惯性写代码，这样很没意思。&lt;/p&gt;

&lt;p&gt;刚好听说 vue 出 2.0 ，要不试着用一用？将来也好说自己用过 vue 2.0 嘛 =w= 于是，开始一边看着文档，一边敲代码，开启了踩坑之旅。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;顺带说一句，在工作中，这样的选型思路非常危险哦，除非是玩票项目且完全不在乎成败，又想任性一把&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;踩坑&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;模块化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;雪花分形有十一个步骤，大体分为两条线：剧情和人物。随着步骤的进展，剧情和人物都在之前步骤的基础上逐渐清晰丰满。&lt;/p&gt;

&lt;p&gt;因此可以用两大类组件来展示这些步骤。&lt;/p&gt;

&lt;p&gt;刚开始用字符串拼接的形式写组件 &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt; ，拼接了十几行，相当痛苦。&lt;/p&gt;

&lt;p&gt;我觉得 vue 文档里的一个坑就是在介绍组件时没同时展示一种很方便的模板语法。文档中一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vue.component('my-component', {
  template: '&amp;lt;div&amp;gt;A custom component!&amp;lt;/div&amp;gt;'
  // 这里的 template 很简单，如果 template 是一大堆的 html ，写起来很累，读起来也很累
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我用字符串拼接的形式写了两个组件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt; 之后，太难受，终于忍不住要找点别的写法。虽然 es6 的语法能解决问题，但最理想的是 vue 原生支持的语法。找了一会儿还真找到了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--把模板用 `type` 是 `text/x-template` 的 script 标签包着 --&amp;gt;
&amp;lt;script type=&quot;text/x-template&quot; id=&quot;component-id&quot;&amp;gt;
  &amp;lt;div&amp;gt;A custom component!&amp;lt;/div&amp;gt;
&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
  Vue.component('my-component', {
    template: '#component-id'
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;驼峰与烤串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在书写组合词时，不同语言有各自约定俗成的习惯，因此有不同的写法，如“组件ID”这个词，在 html/css 中，会写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;component-id&lt;/code&gt; (kebab-case/烤串形)，在 javascript 中，会写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;componentId&lt;/code&gt; (camelCase/驼峰形)，在 ruby 中，会写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;component_id&lt;/code&gt; (snake_case/蛇形)。原本这些只是约定，就算不遵守也不会出问题，但在使用 vue 时，不遵守就会出问题。比如把“组件ID”这个词一律写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;componentId&lt;/code&gt; ，程序不会正常运行，但也不报错。这是个大坑。&lt;/p&gt;

&lt;p&gt;避开这个坑的要点是，时刻注意代码身处的语境，在 html/css 语境中用 kebab-case ，在 javascript 语境中就用 camelCase 。举&lt;a href=&quot;https://vuejs.org/v2/guide/components.html#camelCase-vs-kebab-case&quot;&gt;文档&lt;/a&gt;中的例子说明语境问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
Vue.component('child', {
  // myMessage 在 JavaScript 中，所以用 camelCase
  props: ['myMessage'],
  template: '&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;'
}) 
&amp;lt;/script&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;input v-model=&quot;parentMsg&quot;&amp;gt;
  &amp;lt;br&amp;gt;
  &amp;lt;!-- my-message 在 HTML 中，用 kebab-case  --&amp;gt;
  &amp;lt;!-- parentMsg 在 JavaScript 中，用 camelCase  --&amp;gt;
  &amp;lt;child :my-message=&quot;parentMsg&quot;&amp;gt;&amp;lt;/child&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;事件绑定、触发也是类似的写法，但是有一个例外：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;
  &amp;lt;!-- select-item 在 HTML 中，用 kebab-case  --&amp;gt;
  &amp;lt;!-- alertItem 在 HTML 中，用 camelCase  --&amp;gt;
  &amp;lt;list :list=&quot;list&quot; @select-item=&quot;alertItem&quot;&amp;gt;&amp;lt;/list&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script type=&quot;text/x-template&quot; id=&quot;list&quot;&amp;gt;
  &amp;lt;ul&amp;gt;
      &amp;lt;!-- 例外！！ select-item 在 JavaScript 中，但在 $emit 时，要跟在上面声明时的保持一样  --&amp;gt;
    &amp;lt;li
      v-for=&quot;(item, index) in list&quot;
      @click=&quot;$emit('select-item', item)&quot;
    &amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
  Vue.component('list', {
    props: ['list'],
    template: '#list'
  })
  new Vue({
    el: '#app',
    data: {
      list: [1,2,3,4]
    },
    methods: {
      // alertItem 在 HTML 中，用 camelCase
      alertItem: function(item){
        window.alert(item);
      }
    }
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 vue 时，要经常切换语境，所以很容易搞错。我在写这个应用时，偷了个懒，既不用驼峰，也不用烤串，更不用蛇形，组合词一律小写，比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;togglemenu&lt;/code&gt; 。工作中千万别这样写。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加个后台吧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前台页面很快就写好。用到不少 vue 的功能，挺有满足感的。果然编程知识还是动手学得快。&lt;/p&gt;

&lt;p&gt;满足感很快就退却，忽然想到一个问题，这东西没后台，用户一关闭页面，写下的内容不就什么都没有了吗？缺少保存功能，明显违背了做这个应用的初衷啊。这个功能必须有。&lt;/p&gt;

&lt;p&gt;我有阿里云主机资源，也会 Rails ，但要做这个保存功能，就得做一整套的用户系统：注册、验证、登录、保持会话、注销、忘记密码、重置密码等等。一套功能做下来工作量不少；如果只是个原型的话，可不可以直接调用现成的服务呢？&lt;/p&gt;

&lt;p&gt;记得有个叫“后台即服务”(BaaS)的概念，基于这个概念的产品，有 google 的 Firebase ，国内也有个 leancloud 。&lt;/p&gt;

&lt;p&gt;能不能用呢？出于好奇，我注册了个 leancloud 账号，看到它还真有用户系统，而且开发版应用每天有几千次免费的接口调用次数，够用了。&lt;/p&gt;

&lt;p&gt;凭借 leancloud 我很快写好了用户注册、登录、保存、退出的功能。不得不说，在原型开发时借助“后台即服务”真会大大提高效率。&lt;/p&gt;

&lt;p&gt;贴个成品网址： &lt;a href=&quot;https://judes.me/snow_flake/&quot;&gt;snow flake&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在快写好这个应用时，不小心把 leancloud 应用的 key/secrect 上传到 github 了。在此之前自己还很有信心不会出这种差错，而把 key/secrect 跟主程序放到一起呢。事实证明，程序员的信心真是不靠谱啊～&lt;/p&gt;</content><author><name>jude zhu</name></author><summary type="html">缘起</summary></entry><entry><title type="html">《人类简史》感想</title><link href="http://localhost:4000/reading/2017/02/25/history_of_human.html" rel="alternate" type="text/html" title="《人类简史》感想" /><published>2017-02-25T10:23:56+08:00</published><updated>2017-02-25T10:23:56+08:00</updated><id>http://localhost:4000/reading/2017/02/25/history_of_human</id><content type="html" xml:base="http://localhost:4000/reading/2017/02/25/history_of_human.html">&lt;p&gt;在《人类简史》里，我读到一股伴随着人类发展的越来越强大的力量：虚构故事。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;人类（智人）为什么能在漫长的物种演化中胜出？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不少书中都回答过类似的问题，答案五花八门，有：直立行走解放了双手,能使用工具;使用火来烤熟食物,减少消化时间和疾病;汗腺发达,在白天也能觅食;会使用语言等等。《人类简史》这本书给出了另外一种可能性:人类会讲虚构故事。&lt;/p&gt;

&lt;p&gt;人除了像某些动物一样会使用语言发出“狮子来了”的警告信号，还能说些虚构故事：包括种族成员之间的八卦故事,以及不存在的神话故事。虚构故事能组织、维系大规模的群体共同协作、抵抗其他物种。&lt;/p&gt;

&lt;p&gt;譬如体力（甚至智力）比智人要好的尼安德特人，最终在与智人的竞争中落败，书中相信原因就在于尼安德特人没能用虚构故事组织起群体对抗智人的入侵。&lt;/p&gt;

&lt;p&gt;人类用虚构故事组织起帝国、宗教、贸易；就算在科技高度发展的今天，仍然用虚构故事来建立让社会稳定运行的秩序。&lt;/p&gt;

&lt;p&gt;作为个体，人无时无刻不活在被广泛接受的共同虚构故事当中：&lt;/p&gt;

&lt;p&gt;“人人生而平等”实际上是一个虚构故事，至少在人文主义兴起之前，这个想法并没有存在于人的脑袋里头。&lt;/p&gt;

&lt;p&gt;又有，当下流行的一句话：来一场说走就走的旅行。旅行是从什么时候开始让人向往的呢？是不是因为有了浪漫主义和消费主义才让人产生这种想法呢？&lt;/p&gt;

&lt;p&gt;因为人与虚构故事的这一层关系，人是不是变得比从前更快乐、人活着的是不是有意义等等都成了问题。&lt;/p&gt;

&lt;p&gt;未来，人类会不会因为科技发展，可以脱离种种虚构故事呢？如果可以，那时人还是当下意义上的人吗？&lt;/p&gt;</content><author><name>jude zhu</name></author><summary type="html">在《人类简史》里，我读到一股伴随着人类发展的越来越强大的力量：虚构故事。</summary></entry><entry><title type="html">微信小程序组件开发示例</title><link href="http://localhost:4000/tech/2017/02/11/wechat_app.html" rel="alternate" type="text/html" title="微信小程序组件开发示例" /><published>2017-02-11T11:09:57+08:00</published><updated>2017-02-11T11:09:57+08:00</updated><id>http://localhost:4000/tech/2017/02/11/wechat_app</id><content type="html" xml:base="http://localhost:4000/tech/2017/02/11/wechat_app.html">&lt;p&gt;&lt;strong&gt;2017-02-26 更新了组件的代码，支持在同一页面中引入多个组件实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文介绍微信小程序 （自制）上传图片组件 的关键实现，喜欢通过代码学习的朋友，可以直接看 &lt;a href=&quot;https://github.com/yiyizym/wechat_mini_program_upload_img_module&quot; target=&quot;_blank&quot;&gt;github 源码&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;缘由&quot;&gt;缘由&lt;/h2&gt;

&lt;p&gt;最近在微信小程序上要实现上传图片的功能，因为多个页面都会用到这个功能，我试着就像网页开发一样，写一个能复用的组件。&lt;/p&gt;

&lt;p&gt;上传图片的功能，微信小程序已经提供了相应的组件和API，结合 weui 样式，如果不考虑复用的话，很容易实现（官方 demo 就可以拿来用 ^_^ ）。&lt;/p&gt;

&lt;p&gt;如果要复用，可以利用模板，但是会面临微信小程序的很多限制。&lt;/p&gt;

&lt;h2 id=&quot;限制&quot;&gt;限制&lt;/h2&gt;

&lt;p&gt;举个例子，下面是一个模板文件 customer.wxml （ 注意模板文件里绑定了一个回调函数 sayHello ）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template name=&quot;customer&quot; data-customerid=&quot;{{ id }}&quot; bindtap=&quot;sayHello&quot;&amp;gt;
  &amp;lt;text&amp;gt;{{ name }}&amp;lt;/text&amp;gt;
  &amp;lt;text&amp;gt;{{ gender }}&amp;lt;/text&amp;gt;
  &amp;lt;text&amp;gt;{{ age }}&amp;lt;/text&amp;gt;
  &amp;lt;block wx:for=&quot;orders&quot; wx:for-item=&quot;order&quot;&amp;gt;
    &amp;lt;view&amp;gt;{{order.id}}&amp;lt;/view&amp;gt;
    &amp;lt;view&amp;gt;{{order.detail}}&amp;lt;/view&amp;gt;
  &amp;lt;/block&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;页面 A.wxml 引用了这个模板文件 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;import src=&quot;path/to/customer.wxml&quot;&amp;gt;
&amp;lt;template is=&quot;customer&quot; data=&quot;{{...customer}}&quot;&amp;gt;&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要显示模板里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;orders&lt;/code&gt; 部分，页面 A 的 js 文件里 data 必须有一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;customer&lt;/code&gt; 的 key （可以通过 setData 设置 name/gender/age ，但不能通过 setData 设置 orders ，这样会报错。猜测是因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;setData&lt;/code&gt; 在模板解析之后执行，解析模板时 name/gender/age/orders 都为 undefined ，name/gender/age 为 undefined 时不显示就行，但 wx:for 会遍历 orders ，遍历时调用 hasOwnProperty 方法，这时就报错了。），如果要调用模板里的回调函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;sayHello&lt;/code&gt; ，同样必须在页面 A 的 js 文件里先定义它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// A.js
Page({
  data: {
    customer: {} // 可以先写成空 hash ，稍后更新，但 key 必须先存在
  },
  sayHello: function(e){
    // say hello
    // e.target.dataset.customerid
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;解决办法&quot;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;因为这两个限制，必须找出一个办法让模板文件能动态改变引用它的文件（以下称为宿主）的作用域下的一些变量和方法，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// A.js
require('path/to/customer.js');

Page({
  data: {
    customer: {}
  }
  onLoad: function(){
    // this 是宿主的执行上下文环境
    // this.data 可以访问 data
    // this.setData 可以更新 data
    // this.func = function() {} 可以往宿主增加新方法
    new Customer(this);
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// customer.js
// 这里用到 es6 的类定义语法

class Customer {
  constructor(pageContext){
    this.page = pageContext
    this.page.sayHello = this.sayHello.bind(this)
  }

  sayHello(e){
    // say hello
    // e.target.dataset.customerid
  }
}

module.exports = Customer

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本文关于微信小程序的组件开发关键点介绍完毕，&lt;a href=&quot;https://github.com/yiyizym/wechat_mini_program_upload_img_module&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt; 还展示了如何 设置组件的默认配置以及更改组件的回调方法。&lt;/p&gt;</content><author><name>jude zhu</name></author><category term="微信小程序" /><category term="插件" /><summary type="html">2017-02-26 更新了组件的代码，支持在同一页面中引入多个组件实例</summary></entry><entry><title type="html">提交历史神秘消失事件薄</title><link href="http://localhost:4000/tech/2017/02/06/overwrite-code.html" rel="alternate" type="text/html" title="提交历史神秘消失事件薄" /><published>2017-02-06T18:57:14+08:00</published><updated>2017-02-06T18:57:14+08:00</updated><id>http://localhost:4000/tech/2017/02/06/overwrite-code</id><content type="html" xml:base="http://localhost:4000/tech/2017/02/06/overwrite-code.html">&lt;p&gt;老司机最怕的是什么？&lt;/p&gt;

&lt;p&gt;老司机最怕的就是在新手面前装逼失败,比如说我刚刚向新人传授一系列确保不覆盖别人的代码的方法,转过头就有新人(将他称为 A)反映我覆盖了他的代码。&lt;/p&gt;

&lt;p&gt;覆盖别人代码这种事,我已经很久没做过了。所以当听到这个消息时，我半信半疑。仔细的看过他给我展示的代码后,发觉确实是被覆盖了。我清楚记得自己在那个文件添加过几行代码,如今也都不见了。在查看的文件的提交历史时,发现文件的提交历史只有寥寥几次，里面并没有 A 的提交历史。&lt;/p&gt;

&lt;p&gt;文件的提交历史消失真是一件很有意思的事情,但是当务之急是证明代码不是我覆盖的。&lt;/p&gt;

&lt;p&gt;没有了文件的提交历史，只好查看开发分支上面所有的提交历史。找到 A 那些被覆盖的代码最初引进来的提交,以及最新提交,把两个提交之间的所有提交都按顺序仔细看一遍。&lt;/p&gt;

&lt;p&gt;A 说是我覆盖了代码，是因为他在最新的一个提交里（那是个合并提交）看到我删除了他的代码。我没印象这样做过，但面对清清楚楚的代码，又无从辩白，只好在众人鄙视的眼光下默默地寻找真相。&lt;/p&gt;

&lt;p&gt;这些提交都出自两个人,一个是我,另外一个暂且称他为 B 。我的代码也被覆盖了,所以推测覆盖代码的人肯定就是 B 。&lt;/p&gt;

&lt;p&gt;平时很少用查看代码提交历史的工具（ stash ），花上不少时间后我终于找到证据， B 在一次合并操作当中 把我和 A 的代码都覆盖了。&lt;/p&gt;

&lt;p&gt;事情就此告一段落，过了一个多月，直到最近看到这篇文章&lt;a href=&quot;http://coolshell.cn/articles/17680.html&quot; target=&quot;_blank&quot;&gt;《从GITLAB误删除数据库想到的》&lt;/a&gt;，Gitlab 员工误删数据库非但不跑路，还在网上记录犯错的详细过程，这种追根究底的精神感动了我，忽然回想起文件提交历史神秘消失的事情。&lt;/p&gt;

&lt;p&gt;我首先弄明白了为什么在最新的那个提交里显示的是我删除了代码,我却没有印象。因为那次合并没有产生冲突,是一次快速合并。覆盖代码就是在双方修改同一个文件并产生冲突时,在合并冲突过程中错误的删除了别人的代码。解决完冲突后的提交,在填写提交 message 时,会自动生成提示语表明这是一次产生过冲突的提交。因此,以后如果发生了代码覆盖,就应该首先关注那些有冲突提示的合并提交。&lt;/p&gt;

&lt;p&gt;接下来就是文件提交历史的消失。首先我注意到文件的提交历史并没有消失,毕竟它们出现在分支的提交历史中。最初,我猜测这是我们用的工具的一个 bug ，为了证实这一点,我在 terminal 中运行了 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log -- filename&lt;/code&gt; 命令,发现竟然跟工具显示的一模一样,于是我又猜想,难道这是 git 的 bug ？直觉告诉我不可能。&lt;/p&gt;

&lt;p&gt;同时,我还发现这些消失的历史提交的一个特点,可以这样描述：一个文件提交了 n 次，假如第 2 次跟第 n-1 次提交后文件内容相同，文件提交历史就只显示 1,2,n 三个历史，第 3 次直到第 n-2 次的提交都消失不见了。&lt;/p&gt;

&lt;p&gt;如果这并不是一个 bug 的话，难道这是一个特性？我不由得想起了那个笑话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It’s not a bug, it’s a feature .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;想到这一点,我不由得看起了 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 的帮助文档,文档有 1600 多行,我试着先查找一些关键字,比如 full ，结果还真被我很快地找到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;--full-history&lt;/code&gt; 这个选项。&lt;/p&gt;

&lt;p&gt;原来 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 在查看某个文件提交历史时，默认下会隐藏一些提交历史。&lt;/p&gt;

&lt;p&gt;这一切得先从一个关键概念开始： &lt;strong&gt;TREESAME&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设有一个文件 foo ，如果某次提交改变了文件的内容，那么针对文件 foo 来说，这次提交与父提交的关系就是 !TREESAME ， 否则就是 TREESAME .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 查看某个文件的提交历史，默认只会显示那些与之前任何一个父提交都是 !TREESAME 的提交，而且当一个提交是合并提交，且这个提交与其中一个父提交 TREESAME ，不显示别的父提交。&lt;/p&gt;

&lt;p&gt;接下来借用文档中的例子，简单说明上面的行为。&lt;/p&gt;

&lt;p&gt;下图是一个图形化的提交历史：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   .-A---M---N 
  /     /   / 
 I     B   C  
  \   /   /  
   `-------

  注： &quot;A--M---N&quot; 是在 master 分支上的提交
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;I 是初始提交，这个提交新建了一个名为 foo 的文件，内容是 asdf ，因为是初始提交，所以 I 是 !TREESAME&lt;/li&gt;
  &lt;li&gt;A 提交中，把 foo 的内容改为 foo ，显然 A 是 !TREESAME&lt;/li&gt;
  &lt;li&gt;B 处在 I 提交之后，在其基础上 checkout 出来的一个新分支（称为 b_branch），在 B 提交中，也把 foo 的内容改为 foo ，显然 B 是 !TREESAME&lt;/li&gt;
  &lt;li&gt;M 是在 master 分支上， A 与 B 合并得到的提交。显然 M 中 foo 的内容跟两个父提交都是一样的，所以 M 是 TREESAME&lt;/li&gt;
  &lt;li&gt;C 处在 I 提交之后，在其基础上 checkout 出来的一个新分支（称为 c_branch），在 C 提交中，没有发动 foo 的内容，而是新增了一个文件： c_file 。显然 C 是 TREESAME&lt;/li&gt;
  &lt;li&gt;N 是在 master 分支上， M 与 C 合并得到的提交。在 N 提交中，把 foo 的内容改变为 foobar (要做到这个点不难，在合并时带上 –no-commit 选项，之后手动修改 foo 的内容)，显然 N 是 !TREESAME&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;做完上面的步骤之后，在 master 分支上运行命令： &lt;code class=&quot;highlighter-rouge&quot;&gt;git log --oneline -- foo&lt;/code&gt; ，就会看到类似下面的提交历史：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;9959742 N
5a52a9b A
e6d934b I

# 提交 M B C 都消失了。B 消失了是因为 M 与 A TREESAME ，M 的其他父提交（B）不显示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要看到较为完整的提交历史，在 master 分支上运行命令： &lt;code class=&quot;highlighter-rouge&quot;&gt;git log --oneline --full-history -- foo&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;9959742 N
0cf1684 B
5a52a9b A
e6d934b I

#此时 M 提交仍然不显示
#因为单独使用 `--full-history` （不带 `--parents` 或 `--children`）时不显示与两个父提交都 TREESAME 的提交
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要看到最为完整的提交历史，在 master 分支上运行命令： &lt;code class=&quot;highlighter-rouge&quot;&gt;git log --oneline --full-history --sparse -- foo&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;9959742 N
e513d97 C
b4cc017 M
0cf1684 B
5a52a9b A
e6d934b I

#这时所有的提交都显示出来了
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，这个例子的&lt;a href=&quot;https://github.com/zymiboxpay/git_log_full_history&quot;&gt;源码&lt;/a&gt;已经上传到 github ，建议仔细看文档之余亲自动手试试。&lt;/p&gt;</content><author><name>jude zhu</name></author><summary type="html">老司机最怕的是什么？</summary></entry><entry><title type="html">我所经历的敏捷开发</title><link href="http://localhost:4000/life/2017/01/23/my-so-call-agile.html" rel="alternate" type="text/html" title="我所经历的敏捷开发" /><published>2017-01-23T19:36:06+08:00</published><updated>2017-01-23T19:36:06+08:00</updated><id>http://localhost:4000/life/2017/01/23/my-so-call-agile</id><content type="html" xml:base="http://localhost:4000/life/2017/01/23/my-so-call-agile.html">&lt;p&gt;&lt;strong&gt;以下关于敏捷开发的内容，只是我个人经历和感想，没打算说点“正确”的话，觉得我说的错得离谱，大可以认为我经历的是假的敏捷开发 ^_^&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我来到现在的公司才第一次接触敏捷开发,之前对敏捷开发一无所知。&lt;/p&gt;

&lt;p&gt;说起敏捷开发,网上已经有一大堆复杂抽象的概念,在实际工作当中能接触到的有典型特征的几件事情就是:每天站立会议、头脑风暴形式的需求讨论会议、测试用例设计会议、code review、迭代回顾等等。&lt;/p&gt;

&lt;p&gt;每天站立会议的形式是让每一个人当着大家的面说一下自己昨天完成了什么用户故事,今天计划完成什么用户故事,以及遇到了什么问题，需要谁的帮助等等。会议方便大家了解、监督彼此的进度，之所以采取站立的形式,是要控制开会的时间不要过长。&lt;/p&gt;

&lt;p&gt;用户故事来源于客户的需求以及整个产品和研发团队对客户需求的分析，分析的过程就是需求讨论会议,参与会议的人有客户(最理想的情况)、产品经理、整个研发团队。大家对客户提出的需求进行讨论、头脑风暴,最终整理得出一个个的用户故事。&lt;/p&gt;

&lt;p&gt;接下来就是测试用例设计会议。参加会议的人有产品经理以及整个研发团队。会议上面大家对每一个用户故事提出各种可能的用例,每一个用例的形式大致就像这样:谁在什么前提下依步骤做了什么操作,操作成功的时候他会得到什么回应,操作失败的时候她又会得到什么回应。在验收迭代产出的时候,验收人员根据测试用例来判定测试是否通过。&lt;/p&gt;

&lt;p&gt;研发人员根据测试用例,首先写好测试用例,然后实现功能代码,确保所有的测试用例都顺利通过。之后请其他研发人员做 code review 。review 通过之后才能提交代码。&lt;/p&gt;

&lt;p&gt;迭代回顾安排在每一次迭代完成之后。让整个团队,包括产品经理和研发人员总结在这一次迭代当中有什么事做得好的,有什么事做得不好,以及有什么事可以做得更好。在回顾当中,针对做得不好的地方提出可行的改善方案,在下一次迭代当中实行此方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上所说,就是较为理想的敏捷开发。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最初我们在站立会议上使用白板和便签来描述每一个人计划要做的,正在做的,已经完成的用户故事。后来,我们发现把用户故事写在便签上面,查看用户故事,以及在迭代回顾总结自己所做的事情的时候并不方便,所以后来我们直接就用了 jira 来录入和管理每一个人领取的用户故事。&lt;/p&gt;

&lt;p&gt;用户需求讨论会议上,虽说是头脑风暴,但实际上往往只要那么几个人愿意开动脑筋去思考用户提出的具体的某一个需求背后到底隐藏着怎么样的真正的需求,或者说我们交付出去的产品怎么样才能更好的满足用户的需求。&lt;/p&gt;

&lt;p&gt;测试用例设计会议,我们只坚持开了几次,之后的测试用例就让负责完成每一个用户故事的研发人员自己去写。我一直觉得测试用例是非常重要的：软件的某一个行为究竟是特性还是碧油鸡（bug）,就由测试用例决定。之所以只能坚持几次,我想是因为负责纪录测试用例的人打字速度不够快吧:如果有十个人在会上轮流提出一个测试用例,但只有一个人负责记录,那么当那个人写第一条测试用例的时候,其余九个人就只能等着,对他们来说这段时间浪费了。&lt;/p&gt;

&lt;p&gt;敏捷开发要求研发人员实行测试驱动开发,测试驱动开发有几个步骤:第一，在编写任何功能代码之前先编写测试代码；第二，只编写刚好体现一个失败的测试用例；第三，只编写刚好让失败的测试用例通过的功能代码。&lt;/p&gt;

&lt;p&gt;在实践测试驱动开发的过程中,我始终不能接受上面的三个步骤。在写好能运行起来的代码之前,我很难给这段代码编写相应的测试用例,因为：第一,在什么都没有的时候,我不知道测试的边界在哪里;第二,在功能代码有雏形之前,代码本身会频繁变动,这时候我并不在乎代码本身是否正确,但一旦写了测试代码,我都必须要在每一次改动之后相应地修改测试代码,这样会不断地打断开发人员的思路,影响开发效率。&lt;/p&gt;

&lt;p&gt;但是我很认同测试对软件质量的是至关重要的,所以最终采取的是:先编写功能代码,编写功能代码的时候,先让代码能跑起来,再让代码“看起来正确”地跑起来,然后编写测试代码,测试代码要覆盖相应的测试用例,编写好测试代码之后,再着手修正、重构功能代码。&lt;/p&gt;

&lt;p&gt;确保所有测试用例都跑通过之后,让其他研发人员帮忙检查代码,也就是 code review 。在实行代码检查的时候遇到很多困难:比如说,在研发人员忙的时候,让他替你检查代码,他通常是不愿意的,他要么是直接拒绝你,要么是敷衍了事。还有一种情况就是,检查的人与被检查的人对某一段代码的实现有不同的意见,而且都不能说服对方。这些都会导致研发人员不愿意进行代码检查,我个人的做法是在编写具体的功能代码之前,首先向其他人描述自己的大概实现思路,确保在大方向上不会出现偏差,找人检查代码的时候,如果他忙就找另外一个人(就算这个人对这个功能一无所知也没有问题),用最简单的语言让他明白你实现了一个怎样的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上所说,是我们崩坏之前的敏捷开发，说说崩坏后的景况：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如今,只有每天站立会议和代码检查还能维持下来,需求讨论会议便成需求了解会议,测试用例设计会议早就不存在,测试代码也早已成为研发人员的包袱:新开发的功能影响了已有的功能,导致已有的测试失败,但是并没有时间修改正确,当大部分测试代码都失败的时候,研发人员已经不再指望测试代码来保证功能的正确性;迭代回顾也已经很久没有开,但也没有人感觉缺少了什么东西。&lt;/p&gt;

&lt;p&gt;回顾近两年所经历的敏捷开发,我总结出敏捷开发是一整套对所有参与其中的人员有着高要求的规范:他要求所有人主动承担整个产品的责任,人与人之间要密切沟通交流,最重要的是要求尽早的交付给客户有价值的能满足用户需要的产品。&lt;/p&gt;

&lt;p&gt;我们的敏捷开发之所以会崩坏,就是因为我们一直都没有找到对客户有价值的功能点,没有找到有价值的功能点就不确定该先做哪些功能,所以全都做，因此就不能尽早的交付给客户。经历了近两年的失败，无论是产品经理还是研发人员已经对公司在这个方向上的探索不抱希望：产品经理辞职,研发人员从主动了解需求、提出建议到被动接受、执行需求。同时,因为一直没有找到主要的功能点，业务方向经常改变,导致功能代码到了需要重构的时候,却不得不在此基础上实现新的功能代码,功能代码都没有时间来得及好好想想如何实现,测试代码的通过与否就更不在话下了。&lt;/p&gt;</content><author><name>jude zhu</name></author><summary type="html">以下关于敏捷开发的内容，只是我个人经历和感想，没打算说点“正确”的话，觉得我说的错得离谱，大可以认为我经历的是假的敏捷开发 ^_^</summary></entry><entry><title type="html">方法只做一件事</title><link href="http://localhost:4000/tech/2017/01/15/func-do-one-thing.html" rel="alternate" type="text/html" title="方法只做一件事" /><published>2017-01-15T18:31:26+08:00</published><updated>2017-01-15T18:31:26+08:00</updated><id>http://localhost:4000/tech/2017/01/15/func-do-one-thing</id><content type="html" xml:base="http://localhost:4000/tech/2017/01/15/func-do-one-thing.html">&lt;p&gt;当职业程序员有两年多，算上休息时写的代码，代码量也不算少了，但每次有机会回望自己写的代码，总觉得与别人写得好的那些代码有差距，别人写的读起来短、易懂。&lt;/p&gt;

&lt;p&gt;我知道方法越短越好，但一旦自己写起短代码来，就导致一个简单的功能，实现代码会嵌套四/五层，曾经因此被人说过“代码分得太细”，我自己读着的感觉也不好：虽然方法都短小，但不易懂。&lt;/p&gt;

&lt;p&gt;后来我逐渐归纳出一个组织代码的想法：处于同一抽象层级的代码应该放在一起，不在同一抽象层级的代码就应该分开写。&lt;/p&gt;

&lt;p&gt;我想，这一个想法跟本文题目的意义是一样的。&lt;/p&gt;

&lt;p&gt;“方法只做一件事”这个论调很常见，在程序员界很政治正确，但落到实处，首先就会遇到这个问题：怎样才算是一件事？&lt;/p&gt;

&lt;p&gt;举个例子，要实现一个“把大象放进冰箱”的方法，方法内部大概可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def put_elephant_in_fridge:
  
  open_fridge
  put_elephant_in
  close_fridge

end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;put_elephant_in_fridge&lt;/code&gt; 方法，做了一件事还是三件事？显然会数数的人都会说是三件事，但我会说这是“一件事”。首先，这三件事都处在同一个抽象层级，然后，这三件事都处在 &lt;code class=&quot;highlighter-rouge&quot;&gt;put_elephant_in_fridge&lt;/code&gt; 方法往下一级的抽象层级上。&lt;/p&gt;

&lt;p&gt;问题又来了，怎样判别方法是否处在同一个抽象层级呢？接着上面的例子，看另一种实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def put_elephant_in_fridge:
  
  figure_out_the_volume_of_fridge

  if fridge_not_found or fridge_not_big_enough
    buy_a_fridge
    open_fridge
  else
    open_fridge

  chop_elephant
  full_fill_fridge

  close_fridge

end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的方法，前几行是确保找到足够大的冰箱， &lt;code class=&quot;highlighter-rouge&quot;&gt;chop_elephant&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;full_fill_fridge&lt;/code&gt; 描述怎样处理大象，怎样把大象塞进冰箱。显然，这些方法相对 &lt;code class=&quot;highlighter-rouge&quot;&gt;close_fridge&lt;/code&gt; 来说都是实现细节，它们都不在同一个抽象层级：第一层级是 &lt;code class=&quot;highlighter-rouge&quot;&gt;close_fridge&lt;/code&gt; ，第二层是 &lt;code class=&quot;highlighter-rouge&quot;&gt;chop_elephant&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;full_fill_fridge&lt;/code&gt; ，最下层的是前面几行代码。写代码的时候应该像第一段代码那样隔离不同层级的抽象，隐藏实现细节。&lt;/p&gt;

&lt;p&gt;现实情况下，要求程序员一边实现功能，一边把代码按不同抽象层级安放好或许有点强人所难，可以先后做这两件事。关键是要做，只有这样才能写出好代码。&lt;/p&gt;

&lt;p&gt;“方法只做一件事”，出自「clean code」。如果在我刚当程序员的时候看这本书，或许不会像如今有这么大收获，那时写过的代码少，遇到的问题也少，有过困惑和思考的就更少了；现在的我，看书的每一节都能联系到自己一直以来遇到过的、思考过的问题，这些问题有的已经有了模糊答案，有的想不明白，不论怎样书中的解释总能带给我新的启发。&lt;/p&gt;

&lt;p&gt;“方法只做一件事”就是如此。&lt;/p&gt;</content><author><name>jude zhu</name></author><category term="clean code" /><summary type="html">当职业程序员有两年多，算上休息时写的代码，代码量也不算少了，但每次有机会回望自己写的代码，总觉得与别人写得好的那些代码有差距，别人写的读起来短、易懂。</summary></entry><entry><title type="html">从读一本废话连篇的书说起</title><link href="http://localhost:4000/reading/2016/12/28/from-reading-a-nonsense-book.html" rel="alternate" type="text/html" title="从读一本废话连篇的书说起" /><published>2016-12-28T05:53:20+08:00</published><updated>2016-12-28T05:53:20+08:00</updated><id>http://localhost:4000/reading/2016/12/28/from-reading-a-nonsense-book</id><content type="html" xml:base="http://localhost:4000/reading/2016/12/28/from-reading-a-nonsense-book.html">&lt;p&gt;最近在读一本叫《刻意练习：从新手到大师》的书。这本书的重点早已被万维钢和罗胖他们一条条地划出来。&lt;/p&gt;

&lt;p&gt;之所以要自己读一读，是因为觉得看这种被人消化过的二手知识不好：一是会被他人的偏见带跑，二是理解不深刻，三是没有学到书本作者得出结论的具体方法。&lt;/p&gt;

&lt;p&gt;还有一个原因就是 kindle 上面这书减价，趁机买一本支持作者。&lt;/p&gt;

&lt;p&gt;书的前言写得还好，但往下读就大失所望了。&lt;/p&gt;

&lt;p&gt;我一边读，一边越来越觉得，「别人替你读书」之所以有市场，既要拜读者思维懒惰又不想错过的心态所赐，另一方面不得不说是因为作者在书中废话太多。&lt;/p&gt;

&lt;p&gt;书中的废话，形式大多是举例，这本没有错，但举例并没有从佐证论点出发，而是在追求生动形象。&lt;/p&gt;

&lt;p&gt;比如第一章开头两段的实验描写，简直就是写小说的笔法。一句话可以说清楚的事竟然硬生生扩充成了两大段话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个卡内基梅隆大学的高材生在实践刻意练习之前，不论用什么方式，都最多只能记住 9 位数字。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种形式的大量举例，除了会让书变更厚一些，并不会让论述更为有力。&lt;/p&gt;

&lt;p&gt;又比如，在论证“有目的的练习是专注的”时，那近 500 字的故事看下来，你知道它的重点是什么吗？除了开头两句用到专注两个字眼，其他内容跟专注一点关系都没有。&lt;/p&gt;

&lt;p&gt;在手机 kindle 上读这本书，有时连续翻上好几页，都没翻过一个故事，就像看国产电视剧，拼命按快进画面里还是那两个人在说些可有可无的话，剧情一点都没有进展。忍无可忍。&lt;/p&gt;

&lt;p&gt;有意思的是，或许知道读者在拼命翻书时可能错过重点，出版社贴心地用黄字标出了重点。&lt;/p&gt;

&lt;p&gt;虽然我对这本书评价很低，但它也不是什么用都没有。&lt;/p&gt;

&lt;p&gt;这类实用型的书，看过之后就应当尽快影响现实生活。恰好这段时间我都在背日语单词，因为日语元音只有五个，每个单词音节不多，不同单词之间发音和音节数量相近，很难记住，就算今天能记住，明天就会忘。这本书给我的一个启发就是，要用尽各种方法让单词发音和意义跟自己已经掌握的知识结合起来，产生意义，书中称之为“产生心理表征”。有意义的事情容易被回忆起来。这个理论的实际运用例子就是学生时代背单词最常用的办法：谐音。用上了这种办法之后，每天背同样多的单词，时间可以减少5、6分钟。&lt;/p&gt;

&lt;p&gt;除了背单词，看完一篇文章、学到一个暂时用不到的知识，受这本书的影响，我都用 xmind 整理一下。读懂作者所说，只是在被动接受，注意力集中在细节上面；而把它们整理一下，就是从整体层面上，用自己的理解重新组织知识、取重点、舍弃细节。这其实就是另一种的“建立心理表征”。&lt;/p&gt;

&lt;p&gt;最后，如果没有写这篇文章，大概我只会疯狂吐槽，至于具体差在哪里却又说不出个所以然来。写完后，又发觉它没有当初认为的那么差。随着接触增多，对事物的认知真的会反反复复地改变呢。&lt;/p&gt;</content><author><name>jude zhu</name></author><category term="刻意练习" /><category term="废话连篇" /><summary type="html">最近在读一本叫《刻意练习：从新手到大师》的书。这本书的重点早已被万维钢和罗胖他们一条条地划出来。</summary></entry><entry><title type="html">逝去的 2016</title><link href="http://localhost:4000/life/2016/12/18/my-2016.html" rel="alternate" type="text/html" title="逝去的 2016" /><published>2016-12-18T05:12:06+08:00</published><updated>2016-12-18T05:12:06+08:00</updated><id>http://localhost:4000/life/2016/12/18/my-2016</id><content type="html" xml:base="http://localhost:4000/life/2016/12/18/my-2016.html">&lt;p&gt;下面用一句话来描述今年作为程序员的我：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我享受编程的乐趣，也想用自身所学，做个有一点受众的产品。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以前对算法和数据结构只有零零碎碎的印象，年初有幸看到《算法第 4 版》这本书，对算法和数据结构有了整体的认知。2、3月份那段时间每天一边细看，一边手写书上的代码加深理解，还顺便学习 java 。以我粗浅的眼光来看， java 的接口和泛型对团队合作来说是好东西。&lt;/p&gt;

&lt;p&gt;4 月份又遇到《Ruby 元编程》。 ruby 程序员怎样捧这本书都不为过。我之前连 ruby 对象的变量/方法存放的位置都不清楚，看完（还动手实现每章节的小测验）之后——既满足又有成就感——就忍不住用上各种黑魔法了。一本书写满知识而让读者看完感到满足并不难，难的是在前者之上还能让人全程都有成就感。&lt;/p&gt;

&lt;p&gt;我做的别的事情，都可以在 &lt;a href=&quot;https://github.com/yiyizym&quot;&gt;github&lt;/a&gt; / &lt;a href=&quot;http://judes.me&quot;&gt;blog&lt;/a&gt; 上面看到，有三四个小东西。技术含量都不高，在做了一点点宣传之后，也没几个人用。即使如此，它们对我有很大意义：用所学践行自身所想：至少它们都满足了我个人的需求。&lt;/p&gt;

&lt;p&gt;我想以后会做出既满足了自己的需求，还迎合另一部分受众的产品。它们是通往这个目标的第一步。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如果说今年发生了什么重大事情，却没有在别的地方留下痕迹的话，就是 4 月初的一次主动交涉。当时受某句话的鼓动，跑去跟人家直接说要把月薪加到多少多少。交涉的结果就是月薪上涨 40% 。那句鼓动我的话是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一旦你跨了个性的界，那么你在同类人中就会成为佼佼者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本人个性一直很怕主动跟人接触，更别说主动要求那么大幅度的加薪。那个举动，没有源自金钱方面的压力，完全出自挑战自己固有界限的冲动。&lt;/p&gt;

&lt;p&gt;加薪一大好处就是，9 月份凑够了钱办签证去东京玩一趟。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后，写下一句话，希望对读者有些许启发：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;要得到自己所想的，就先设立最终目标，然后把最终目标分解成大中小目标，努力去完成一个个小目标，定期检查付出的努力是不是达到既定目标，如果没有，就改变努力的方式，甚至改变自己一直改不了的性格、做事方式、缺点，反复检查改变后的成效，如果某个目标最终完成不了，就根据实际调整目标。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（本人正在实践中，除了在设定最终目标/五年/三年/一年/半年/季度等目标时比较挣扎之外，月度目标和周目标是很好计划和达成的）&lt;/p&gt;</content><author><name>jude zhu</name></author><category term="年终" /><summary type="html">下面用一句话来描述今年作为程序员的我：</summary></entry><entry><title type="html">模糊的正确</title><link href="http://localhost:4000/life/2016/12/05/simplify-bayes-theorem.html" rel="alternate" type="text/html" title="模糊的正确" /><published>2016-12-05T05:30:28+08:00</published><updated>2016-12-05T05:30:28+08:00</updated><id>http://localhost:4000/life/2016/12/05/simplify-bayes-theorem</id><content type="html" xml:base="http://localhost:4000/life/2016/12/05/simplify-bayes-theorem.html">&lt;p&gt;在《对“伪心理学”说不》一书的第 10 章中，有这样一个例子：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果在每 1000 人中有 1 个人携带艾滋病的病毒(HIV)， 
 再假设有一种检查可以百分百地诊断出真的携带该病毒的人; 
 最后，假设这个检查有 5% 的可能性，把没有携带者说成是有。
 也就是说，这项检查在没有携带 HIV 的人中，也会错误地检测出有 5% 的人是携带病毒者。 
 假设我们随便找一个人来进行这项检查，得到了呈阳性反应，亦即此人为 HIV 携带者。 
 假定我们不知道这个人的患病史，那么他真的是 HIV 携带者的概率是多少呢?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果凭直觉大概会猜答案是 95% 。&lt;/p&gt;

&lt;p&gt;如果知道这是一道典型的条件概率题目，大概会认真对待：翻开书本，复习一下条件概率，然后套公式（贝叶斯定理）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先找准事件：
设 H 为携带 HIV 事件
设 N 为没有携带 HIV 事件
设 + 为检测为阳性事件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后可以得到：
P(H) = 0.1%
P(N) = 1 - P(H) = 99.9%
携带者接受检测，并检测出阳性的概率:
P(+|H) = 100%
没有携带者接受检测，并检测出阳性的概率:
P(+|N) = 5%&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;问题是 P(H&lt;/td&gt;
          &lt;td&gt;+) 等于多少&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;得到：
P(H|+) = P(+,H) / P(+) = P(+|H) * P(H) / P(+) 
 = P(+|H) * P(H) / (P(+,H) + P(+,N)) 
 = P(+|H) * P(H) / (P(+|H) * P(H) + P(+|N) * P(N)) 
 = 1 * 0.1% / (1 * 0.1% + 5% * 99.9%)
 ≈ 0.01963&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么新的问题又来了，如果没学过（或者忘记了）条件概率，有没有办法得出“正确的”答案呢？&lt;/p&gt;

&lt;p&gt;办法还是有的，有一种很简单的办法，能得到大致正确的答案。&lt;/p&gt;

&lt;p&gt;关键思路是：把概率化作统计。&lt;/p&gt;

&lt;p&gt;还记得题目问的是什么吗？&lt;strong&gt;一个检测呈阳性的人真实患病的概率有多大。这个问题可以略为简化一下，看成是真实患病的人占被检出阳性的人的比例有多大&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先随机找到 10,000 个人，根据条件，我们可以假设其中有 10 人患有艾滋病；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让这 10，000 人接受检查，那么这患病的 10 人一定会被检出阳性；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;被检出阳性的人一共有多少呢？除去那真实患病的 10 人，还有不患病的 9990 人，他们当中被检出阳性的人数是 9990 * 5% ≈ 500 （要是算是 499.5 的话，得到的答案跟前面的方法是一样的）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么这个比例就是： 10 / (10 + 500) ≈ 0.01961&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个简单的方法并不总能都得到正确答案，但足以用来评估大概数字，做出正确决策（起码不会猜 95% ^_^ ）。实际上这个方法得到的概率只会比正确答案要高，不会低。&lt;/p&gt;

&lt;p&gt;最后再来一个例子展示怎样使用这个简单的方法帮助我们做出正确判断：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;近来发生的多起恐怖活动中，某教人士所占比例非常大，导致人们大都信仰某教的人抱有成见：信仰某教的人很有可能是恐怖份子。问题来了，信仰某教的人是恐怖份子的概率有多大呢？
 已知的条件有：1, 假设恐怖份子都信仰某教 ；2, 全球有 1/100 人口信仰某教；3, 恐怖份子人数占全球人口 1/10,000 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;按照“把概率化作统计”的思路：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;假设全球有 100，000 人口，那么当中的恐怖份子有 10 人，信仰某教的人数是 1,000 ，所以得到信仰某教的人是恐怖份子的概率只有 10 / 1,000 = 1%&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考虑到信仰某教的实际人口比例比 1/100 要高，而恐怖份子则要比 1/10，000 低，所以这种成见是没有数据支持的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;
本文所述的简单方法，出自《x的奇幻之旅》&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/条件概率&quot;&gt;条件概率&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/贝叶斯定理&quot;&gt;贝叶斯定理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>jude zhu</name></author><category term="条件概率" /><category term="贝叶斯定理" /><category term="统计" /><summary type="html">在《对“伪心理学”说不》一书的第 10 章中，有这样一个例子：</summary></entry></feed>
