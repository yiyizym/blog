<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jude&#39;s life</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://judes.me/"/>
  <updated>2016-12-29T00:50:29.000Z</updated>
  <id>http://judes.me/</id>
  
  <author>
    <name>jude zhu</name>
    <email>yiyizym@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从读一本废话连篇的书说起</title>
    <link href="http://judes.me/2016/12/27/from-reading-a-nonsense-book/"/>
    <id>http://judes.me/2016/12/27/from-reading-a-nonsense-book/</id>
    <published>2016-12-27T13:53:20.000Z</published>
    <updated>2016-12-29T00:50:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读一本叫《刻意练习：从新手到大师》的书。这本书的重点早就被万维钢和罗胖他们一条条地划出来。</p>
<p>看这种被人消化过的二手知识，总觉得不妥，一是会被他人的偏见带跑，二是理解不深刻，三是没有学到书本作者得出结论的具体方法。</p>
<p>于是最近趁着 kindle 上面这书减价，就买了本读读。</p>
<p>前言还好，但再往下读就后悔了。</p>
<p>越来越觉得，「别人替你读书」之所以有市场，一方面是读者思维懒惰又不想错过，另一方面不得不说是因为书中废话太多。</p>
<p>比如第一章开头两段的实验描写，简直就是写小说的笔法。一句话可以说清楚的事竟然硬生生扩充成了两大段话：</p>
<blockquote>
<p>一个卡内基梅隆大学的高材生在实践刻意练习之前，不论用什么方式，都最多只能记住 9 位数字。</p>
</blockquote>
<p>大量的举例，并不会让论述更为有力，反而冲散结构，使得读者迷惑：现在是在说什么？</p>
<p>大量的重复，没有层层递进</p>
<p>拼命翻书的时候，还担心错过了什么</p>
<p>话虽如此，还是有收获的</p>
<p>跟日常结合（背日语单词）。为什么会记不住？没有结构化材料，或赋予它意义</p>
<p>回到 学习和读书</p>
<p>对那种目的性不强，但又觉得读后要得到（记住）什么的，要去用 xmind 整理，要回忆，要去用，要去教别人</p>
]]></content>
    
    <summary type="html">
    
      这是一篇意识流的，扯到哪算哪的文章
    
    </summary>
    
      <category term="reading" scheme="http://judes.me/categories/reading/"/>
    
    
      <category term="刻意练习" scheme="http://judes.me/tags/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/"/>
    
      <category term="废话连篇" scheme="http://judes.me/tags/%E5%BA%9F%E8%AF%9D%E8%BF%9E%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>仿照微信的通讯录</title>
    <link href="http://judes.me/2016/11/26/wx-contacts/"/>
    <id>http://judes.me/2016/11/26/wx-contacts/</id>
    <published>2016-11-26T09:54:03.000Z</published>
    <updated>2016-12-27T13:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个通讯录现在长这个样子：<br><img src="http://ww4.sinaimg.cn/large/60cdc5a5gw1fa5mumuv6sg20aw0j0kjm.gif" alt="幼年期"></p>
<p>以后可能就是这个样子了（我不保证）：<br><img src="/2016/11/26/wx-contacts/will_be.jpg" alt="完全体" title="完全体"></p>
<p>如果我最后放弃改进它，你可以在<a href="https://github.com/yiyizym/contacts" target="_blank" rel="external">这里</a>找到源码，然后自己作修改。</p>
<p>这件事情的由来是，公司的设计师在之前的项目里想实现一个跟微信通讯录一样的页面。我没多少把握能在 web 端实现跟微信原生一样的功能效果：可以想象东西做出来能覆盖微信原生 80% 的功能，但剩下的 20% 会被设计师挑刺当成是 bug ，（比如姓氏的正确分类，比如多个同姓的人的先后排序，比如多音字的处理，比如姓氏首字母切换的效果），要实现这 20% 的功能效果很费力气。所以当时就明说要做到一模一样有困难，要么多给我点时间做，要么做一个十分简单的带个搜索功能的列表。最终选了后者。</p>
<p>这周处于迭代中间，有点空闲时间，回想这个通讯录功能，感觉可以做做。于是先到网上搜搜有没有现成可靠的插件，发现竟然没有。</p>
<p>为什么这个功能会没有人做呢？忽然就产生自己来做一个的想法。要是做出来能用，也是挺好的。</p>
<p>这个功能（或者说是前端插件），首先是要方便 Rails 用户使用，假设有一个不怎么懂前端的后端工程师，他只需要做一件事：提供一个联系人数组，每个元素有 id/name/url 等等属性就行。其余的事情交给这个插件。</p>
<p>然后我打算只用原生 javascript 实现所有的功能。这样可以练习一下在没有 jQuery/underscore 的情况下写代码。</p>
<p>然后是把这个功能做正确：</p>
<ul>
<li>联系人按姓名正确分类</li>
<li>点索引要跳转到正确的分类</li>
<li>当前类别要在顶栏显示</li>
<li>要有检索过滤功能</li>
</ul>
<p>以上目标在动手前先写下来，然后一个个地实现，这样在断断续续的开发中也不会乱了优先级。</p>
<p>真正动手时遇到几个问题：</p>
<ul>
<li><p>把中文姓氏正确分类<br>最初想法是找一个常用汉字与拼音一一对应的哈希表，遇到中文只需要查查表就行，虽然要引入大约十几KB的数据，但查表时间复杂度低。可惜找了一圈没找到合适的。</p>
<p>后来在 ruby-china 论坛找到一个聪明的方法，用几行代码就可以找到中文字的拼音首字母。我在以下几个环境测试了下都没有问题：</p>
<ul>
<li><p>iOS 10 的 safari</p>
</li>
<li><p>iOS 10 的微信，版本 6.3.30 </p>
</li>
<li><p>android 5.0 的 chrome ， 版本 51 </p>
</li>
<li><p>android 5.0 的微信，版本 6.3.30 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>点击索引跳转到相应类别<br>这个用 html 原生的 anchor 实现，灵感来自 MDN 。</p>
</li>
<li><p>实时更新当前类别<br>要随着页面滚动更新顶栏的当前类别，不可避免要监听页面的 scroll 事件。 scroll 事件会在页面滚动过程中被频繁触发，可以用 underscore 的 throttle 来限制因事件触发而调用其他方法的频率，但我不想引入 underscore 。<br>在 MDN 上看到优化后的监听 scroll 事件的方式，思路是利用 requestAnimationFrame 方法设置开关，这个方法会在浏览器渲染下一帧前调用。也就是说可以利用它使得由 scroll 事件触发执行的事件在每一帧都只被执行一次。</p>
</li>
<li><p>图标<br>实现搜索功能才发现没有搜索常用的“放大镜”图标，无论是使用字体图标还是 svg/png 图标，都意味着又得引入别的资源。看样子这个图标不就是个圆圈加根棍子么？自己动手用CSS画。</p>
</li>
</ul>
<p>我大致想了下未来这个插件会变成怎样，一是要把UI做得跟微信差不多，现在的太朴素了点。</p>
<p>然后对同属一个类别下的联系人排序。排序是个有意思的工作，要选那些可以实现快速插入新元素的算法。</p>
<p>不过在此之前，得先写一篇介绍这个插件的文章，宣传一下这个好东西。我现在很想在付出更大努力前，想办法知道值不值得。</p>
]]></content>
    
    <summary type="html">
    
      无聊做了个 web 版的功能跟微信里面那个差不多的通讯录
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://judes.me/tags/frontend/"/>
    
      <category term="wechat" scheme="http://judes.me/tags/wechat/"/>
    
      <category term="微信" scheme="http://judes.me/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Rails 的 CSRF 对策</title>
    <link href="http://judes.me/2016/11/12/csrf-protect-from-forgery/"/>
    <id>http://judes.me/2016/11/12/csrf-protect-from-forgery/</id>
    <published>2016-11-12T14:33:28.000Z</published>
    <updated>2016-11-26T09:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的工作是把原有 PC 端的一整套面向客户的询价下单流程移植到微信公众号上。</p>
<p>原有的流程十分复杂，移植时想着后台代码能不改就不改，前端代码能重用的就重用。</p>
<p>其中有一步是前端提交一个表单，后台根据处理结果，分别重定向到成功和失败页面。</p>
<p>在 AJAX 流行之前，这是标准的做法（简单且重定向有效防止重复提交表单）。</p>
<p>如今要用 AJAX 模拟表单提交很容易，但接下来要重定向页面就有点困难了。简单的做法就是创建一个表单元素，然后塞一些 input 元素进去，再调用表单元素的 submit 方法：</p>
<pre><code><span class="keyword">var</span> <span class="keyword">form</span> = document.createElement('<span class="keyword">form</span>');
<span class="keyword">form</span>.method = '<span class="keyword">post</span>'
<span class="keyword">form</span>.action = '/where/to/<span class="keyword">post</span>'
<span class="keyword">var</span> input_1 = document.createElement('<span class="keyword">input</span>');
input_1.name = 'name_1';
input_1.<span class="keyword">type</span> = 'hidden';
input_1.val = 'val_1';

<span class="keyword">form</span>.appendChild(input_1);
document.body.appendChild(<span class="keyword">form</span>);

<span class="keyword">form</span>.submit();
</code></pre><p>(想来想去，与其写这么多 javascript ，还不如直接在 html 里放一个隐藏的表单元素。自己纯粹就是闲的)</p>
<p>单看上面这段代码应该没问题，但实际上有很大的安全隐患，在 Rails 中会提交失败。</p>
<p>这个安全隐患就是提交到这个路径 ‘/where/to/post’ 的表单很容易被伪造，后台没办法区分伪造的表单和正常的表单。这就是 cross site request forgery, <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29" target="_blank" rel="external">CSRF</a> 。</p>
<p>事情得从头说起。</p>
<p>后台为识别用户的操作，可以在每个操作前都要求用户输入用户名和密码，这样做太麻烦了，为方便用户，后台和浏览器共同发展出一套只需输入一次用户名密码就能在一段时间内记住用户身份的 session 机制。这套机制依赖于保存在浏览器里的 cookie 。</p>
<p>因此如果 cookie 漏泄了，被用来伪造用户身份的话，后台没有办法区分哪些是假冒操作，哪些正常操作。</p>
<p>CSRF 正是利用了这个弱点。</p>
<p>Rails 为防止 CSRF ，默认会检查除 GET 、 HEAD 之外的其他请求当中的请求头或请求正文，看里面有没有一个 token 字段，如果没有或者跟 session 中保存的值不一致，就判定为非法请求。</p>
<p>Rails 的这一套机制覆盖了多种发出请求的方式：</p>
<p><strong> 在前端 </strong></p>
<ul>
<li><p>jQuery</p>
<p>如果使用 jQuery 的 ajax 方法，那么需要引入 jquery-ujs.js 。这个文件调用 <code>jQuery.ajaxPrefilter</code> 方法，为所有非跨域的请求（跨域的请求，后台通过 CORS ，检查 Origin 字段避免非法请求来源），在其请求头中加入一个 X-CSRF-Token 字段。 </p>
<p>X-CSRF-Token 的值来自页面中的一个 meta 标签，这个标签在 layout 中通过设置：<code>&lt;%= csrf_meta_tags %&gt;</code> 生成。</p>
</li>
<li><p>表单提交</p>
<p>如果引入了 jQuery 和 jquery-ujs.js ，所有的 form 元素会在页面初始化时被塞进一个隐藏的 token 字段，它的值同样来自 meta 标签。</p>
</li>
</ul>
<ul>
<li><p>form_tag</p>
<p>如果没有引入 jquery-ujs.js 或不能用 javascript ，也可以使用 <code>form_tag</code>, <code>form_for</code> helper 方法，它们也会根据上述情况加入 token 字段。</p>
</li>
</ul>
<p><strong> 在后台 </strong></p>
<p>ActionPack 提供一个 <strong> protect_from_forgery </strong> 方法，用脚手架生成的 Rails 应用，会在 ApplicationController 调用这个方法：</p>
<pre><code><span class="comment">#Prevent CSRF attacks by raising an exception.</span>
protect_from_forgery <span class="keyword">with</span>: :exception
</code></pre><p>它做两件事情：</p>
<ul>
<li><p>在处理请求前，检验请求是不是 GET 或 HEAD 请求，是不是关闭了 protect_from_forgery ，请求头中的 X-CSRF-Token 字段是否正确， 请求正文中的 authenticity_token 字段是否正确，只要满足以上四个条件的一个，校验就算通过，可以处理请求；一个都不满足的话，就抛出异常。</p>
</li>
<li><p>在处理完请求，返回数据前，如果是 GET 请求并且不是 xhr 请求，抛出异常，不返回数据。这样做是为了防止有人使用 script 标签加载内容，并盗窃其中敏感的信息（因为 script 加载完成后会执行）。</p>
</li>
</ul>
<p><strong> 总结 </strong></p>
<p>Rails 应对 CSRF 的措施覆盖了大多数使用场景，帮助程序员在不知不觉间写出安全的代码，但这种贴心的保护往往使得程序员忘记各种危险，一旦脱离 Rails 代码就写得很脆弱。</p>
]]></content>
    
    <summary type="html">
    
      protect_from_forgery 方法
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
      <category term="CSRF" scheme="http://judes.me/tags/CSRF/"/>
    
      <category term="frontend" scheme="http://judes.me/tags/frontend/"/>
    
      <category term="rails" scheme="http://judes.me/tags/rails/"/>
    
  </entry>
  
  <entry>
    <title>雪花分形</title>
    <link href="http://judes.me/2016/11/07/snowflake-method/"/>
    <id>http://judes.me/2016/11/07/snowflake-method/</id>
    <published>2016-11-07T14:04:44.000Z</published>
    <updated>2016-11-26T09:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>时常在看完一本精彩小说后，冒出什么时候自己也写一本的念头。</p>
<p>被各种文章鼓舞，每天动手写一百几十字，几十天之后，发觉自己写的简直就是一页页垃圾。</p>
<p>没错，上面说的就是我。</p>
<p>我深受打击，再也不相信那些所谓的“写作训练”，还有那些教你“成为作家”的空话。</p>
<p>但我一直坚信：伟大的作品，倚仗超群的天赋，可望而不可及；但优秀的作品完全可以用规律、技巧写就，再精心打磨而成。</p>
<p>就这样过了很久，一天在看湾区日报的<a href="https://medium.com/@gabrielgambetta/how-i-wrote-my-first-novel-during-my-daily-commute-e1d02c9447b9" target="_blank" rel="external">这篇文章</a>时，找到共鸣了。</p>
<p>文章的作者是一个程序员，叫 Gabriel Gambetta ，他利用每天上下班的通勤时间写成一本小说。光成写好一本几百页的小说没什么值得关注的，有意思的是他在文章中分享了写小说的具体策略：</p>
<ol>
<li><p>找一个模仿对象。他喜欢丹布朗，就把丹布朗的几本小说细读一遍，用 excel 表格列出它们的每一章的故事情节或者人物关系。</p>
</li>
<li><p>阅读大量关于写作的书籍，学习写作原理、技巧。</p>
</li>
<li><p>按照 <a href="http://www.advancedfictionwriting.com/articles/snowflake-method/" target="_blank" rel="external">Snowflake method</a> ，把自己的小说逐渐由一句话扩展为一段话，再到几句纸、一本小说。</p>
</li>
</ol>
<p>整个过程持续三年。</p>
<p>我想觉得每一步都走得十分好：</p>
<p>每个人都有自己欣赏的作家，模仿他的技法不失为好开始。</p>
<p>模仿能得到相似的套路，却没有看到背后的原理、规律，很难在日后运用自如，因此学习写作原理、技巧必不可少。（这方面的中文书籍，有《经典人物原型45种》、《小说写作教程》、《有效写作13篇》等等）</p>
<p>最后，写小说是一个大型、复杂的工程项目，得找一套能保证项目质量稳定、进展顺利的方法。这个方法就是接下来要说的 Snowflake method （下称雪花分形方法）。</p>
<p>雪花分形方法是一套完整的小说创作方法，名字来源于计算机画雪花的几个步骤：从粗略大致到具体细致。适合那些习惯做事前先从整体规划，再逐渐细化执行的人。（如果你偏好斯蒂芬·金信马由缰式的创作手法，这种方法就不适合你了。）</p>
<p>雪花分形方法大致有以下几个步骤：</p>
<ol>
<li><p>用一句话总结小说的内容</p>
</li>
<li><p>把这句话扩写成一段话（包含 5 个句子），要有故事开头（1句）、主角经受的主要磨难（3句）以及结尾（1句）</p>
</li>
<li><p>塑造主要人物。每个主要人物都要用一页篇幅讲述他的以下特征：</p>
<ol>
<li>姓名</li>
<li>一句话总结的角色故事情节</li>
<li>角色的动机（偏向于抽象的）</li>
<li>角色的目标（偏向于具体的）</li>
<li>阻碍角色达到目标的事物</li>
<li>角色最终的感悟</li>
<li>一段话总结的角色故事情节</li>
</ol>
</li>
<li><p>扩写之前的（即第 2 步完成的）那段故事梗概，将一段扩充成一页</p>
</li>
<li><p>为每个主要角色写上一页纸的描述，为其他重要角色也写上半页描述。主要是从每个角色的角度去描述整个故事</p>
</li>
<li><p>把在第 4 步中完成的一页纸的故事概述，扩写成四页</p>
</li>
<li><p>把每个角色的所有资料都完善好。最重要的是要写清楚：在故事的末尾，角色有了什么样的转变、收获</p>
</li>
<li><p>把在第 6 步中完成的四页纸中出现的故事场景，用 excel 一条一条记下来。一行一个场景，一行有多列，一列是故事情节，一列是出场人物，一列是大约写多少页</p>
</li>
<li><p>把第 8 步中完成的每一条场景扩写成一段，要在每一段中出现冲突，如果很难做到，就可以把它从 excel 中去掉</p>
</li>
<li><p>开始写初稿</p>
</li>
<li><p>不断地打磨作品</p>
</li>
</ol>
<p>看到这里，是不是变得自信满满跃跃欲试了？</p>
<p>不过，愿望、方法、行动三者加起来并不一定等于成功，不要忽略了 Gabriel 可是花上整整三年才完成小说创作的。你有这份坚持吗？</p>
<p><strong> 祝你好运！ </strong></p>
]]></content>
    
    <summary type="html">
    
      一种被实证可行的小说创作方法
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
      <category term="snowflake" scheme="http://judes.me/tags/snowflake/"/>
    
      <category term="写作" scheme="http://judes.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>iOS浏览器内核导致 fixed 定位元素可能错位问题</title>
    <link href="http://judes.me/2016/10/11/fixed-pos-problem-in-ios-wechat-browser/"/>
    <id>http://judes.me/2016/10/11/fixed-pos-problem-in-ios-wechat-browser/</id>
    <published>2016-10-11T13:32:43.000Z</published>
    <updated>2016-10-11T14:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在企业号某个列表页面使用 <code>position: fixed;</code> 置顶搜索输入框时，发现一个诡异的问题：在 iOS 的微信浏览器中点击输入框，弹出输入法时，很有可能会（复现条件：列表长度超过一屏，在点击输入框前往下拖动列表）导致输入框错位下移，在 Android 微信浏览器中却没有问题。</p>
<img src="/2016/10/11/fixed-pos-problem-in-ios-wechat-browser/problem_1.jpg" alt="在 iOS 输入法未弹出时显示正常" title="在 iOS 输入法未弹出时显示正常">
<img src="/2016/10/11/fixed-pos-problem-in-ios-wechat-browser/problem_2.jpg" alt="在 iOS 输入法弹出后出现错位" title="在 iOS 输入法弹出后出现错位">
<p>出问题的页面结构大致如下，完整的代码见<a href="https://gist.github.com/zymiboxpay/1e0a620284d1cf320f5f9603779a728d" target="_blank" rel="external">这里</a>：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"fixed_part"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">placeholder</span>=<span class="value">"输入文字"</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"overflow_part"</span>&gt;</span>
    <span class="comment">&lt;!--items--&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>相应的样式如下：</p>
<pre><code><span class="class">.container</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
}</span>
<span class="class">.fixed_part</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
}</span>
<span class="class">.fixed_part</span> &gt; <span class="tag">input</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5%</span></span></span>;
  <span class="rule"><span class="attribute">border</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span></span>;
}</span>
<span class="class">.overflow_part</span> <span class="class">.item</span> <span class="rules">{
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">100px</span></span></span>;
  <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
  <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span></span>;
}</span>
</code></pre><p>最初遇到这个问题时，当作没看见（一，这是兼容性问题，手尾长；二，复现条件比较苛刻；三，产品经理没发现；四，手头上事情很多；五，不想做的理由总是很多），这事就过去了。</p>
<p>后来又再次遇到，一时兴起想解决它。很快找到原因（ iOS 原生浏览器内核对 fixed 定位元素渲染有 bug ），还看到有文章给出了<a href="http://efe.baidu.com/blog/mobile-fixed-layout/" target="_blank" rel="external">解决方案</a>。借鉴文中的思路——放弃使用 fixed 定位，同时缩窄滚动区域——给出了自己的解决方案，完整的代码见<a href="https://gist.github.com/zymiboxpay/de6885576848a072b776c51acc556737" target="_blank" rel="external">这里</a>。</p>
<p>页面结构没有改变。</p>
<p>样式有大改变：</p>
<pre><code><span class="class">.container</span> <span class="rules">{
  <span class="comment">/* 让容器计算出自身高度 */</span>
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="comment">/* 让子元素处理自身高度 */</span>
  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
<span class="class">.fixed_part</span> <span class="rules">{
  <span class="comment">/* 用 absolute 代替 fixed */</span>
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
}</span>
<span class="class">.fixed_part</span> &gt; <span class="tag">input</span> <span class="rules">{
  <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5%</span></span></span>;
  <span class="rule"><span class="attribute">border</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span></span>;
}</span>
<span class="class">.overflow_part</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
  <span class="comment">/* 让滚动条出现在高度超过一屏的元素上面 */</span>
  <span class="rule"><span class="attribute">overflow-y</span>:<span class="value"> auto</span></span>;
}</span>
<span class="class">.overflow_part</span> <span class="class">.item</span> <span class="rules">{
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">100px</span></span></span>;
  <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
  <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span></span>;
}</span>
</code></pre><p>这个方案的好处是不需要写死——你要这样做也是可以的——任何一个元素的高度。</p>
<p>完成后的效果图：</p>
<img src="/2016/10/11/fixed-pos-problem-in-ios-wechat-browser/solution_1.jpg" alt="在 iOS 输入法未弹出时显示正常" title="在 iOS 输入法未弹出时显示正常">
<img src="/2016/10/11/fixed-pos-problem-in-ios-wechat-browser/solution_2.jpg" alt="在 iOS 输入法弹出后显示正常" title="在 iOS 输入法弹出后显示正常">]]></content>
    
    <summary type="html">
    
      又是一个在开发微信企业号时遇到的问题，这次锅不在腾讯
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
      <category term="wechat" scheme="http://judes.me/tags/wechat/"/>
    
      <category term="浏览器" scheme="http://judes.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tokyo go round</title>
    <link href="http://judes.me/2016/10/08/tokyo-go-round/"/>
    <id>http://judes.me/2016/10/08/tokyo-go-round/</id>
    <published>2016-10-08T15:00:54.000Z</published>
    <updated>2016-10-25T14:49:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>祖国名山大川、风景古迹一直以来吸引着众多慕名而来的游客，我讨厌人山人海，节假日就没有出外旅游过，偶尔得到大片连续工作日休息的机会，也总是“宅心仁厚”地窝在家里。</p>
<p>读万卷书行万里路，这是古人熟知的两种增长见闻的好方法，他们没想到在现代就算安心在家也可以环游世界吧：有旅游节目展示无限风光，有纪录片介绍世俗人情，通过镜头看到的景往往比实地游览的更优雅清静，人也更自然纯朴。如果一个人禁不住亲自到某地瞧瞧，发觉景致跟预想的差太多，很可能会大失所望吧。</p>
<p>以上都是我不去到处玩的理由，除此之外，没有合适的旅伴，一个人在外面游荡，跟独自坐在屏幕前有什么不一样？无论看到什么景，遇到什么人都只能自言自语。</p>
<p>如果我有机会去玩，日本是首选。</p>
<p>作为一枚宅男，没少受日本文化的熏陶。论看过的日本动漫、电视剧、电影、文学作品，这几样单独挑出来我可能比不上别人，但加起来不比任何一个认识的人少，也不比本国同类作品少。</p>
<p>一个人长期被一种——无论是先进还是落后的——文化耳濡目染，会自然而然地对它产生好感。但自己并不身处其中，这份好感就似雾里看花，有欠真实。日本人是不是如传闻中的那样安静、守规矩，日本的街道是不是非常整洁，日本人说话是不是都跟动漫人物那样好听，现实里日本女中学生是不是都很有感觉，等等，因为有这些模糊不清的印象，才产生了想一探究竟的好奇心。</p>
<p>在众多的印象中，却有一点是笃定不移的：日本是吃货们的天堂。美食讲求形色香味，日本食物在“香”这点上受制，反而逼迫人们在其他方面处处用心。你常常能感受到摆在眼前的除了美味，还有克制的匠心。</p>
<p>好几年前，我曾向一个——算是有共同语言的——朋友表达过日本旅游的愿望，当时他还答应将来结伴同游。</p>
<p>没想到今年6月他又重提这个约定，之后这事又被犯拖延症的我拖了两个月，期间只拿到护照，认真考虑怎样到日本已经是7月底。</p>
<p>朋友最初打算跟团游——不用操心任何事，安全系数还很高，我却对跟团游十分反感。两人就此差点谈崩了，幸好发现旅行社还提供报名自助游——旅行社解决签证、机票、酒店——的方案。</p>
<p>报团自由行之后，出国旅行护照/签证/机票/酒店/行程等等琐碎但又必不可少的事，只剩下行程需要花点心思。</p>
<p>同事说他在去日本玩前一个月就开始计划行程（他称之为攻略），若打印出来会密密麻麻铺满几张A4纸，而我是在出行前一个星期才记下一点日本旅游注意事项。</p>
<p>那时还没有具体计划，只有大致想法：六天时间里，除了拨出一天到镰仓——朋友还抽一天去看富士山，风景对我的吸引力远远不及人文历史，所以——我决定其他日子好好待在东京。</p>
<p>从来没做过行程计划，但毕竟看过网上大把的旅游路线推荐和前人的攻略总结，以为不难做，谁知就连第一天从羽田机场到新宿酒店的计划和注意事项都花了一整晚。</p>
<p>东京的交通让外国人眼花缭乱，JR新宿站更是令人闻风丧胆。</p>
<p>就在此时，亲戚老少七人决定周末来香港玩两天，让我当导游。老早答应过人家陪游香港，不能拒绝。</p>
<p>在他们眼中我经常到香港，很安心地把一切行程计划都托付给我，他们有所不知的是某人每次都是到屯门市中心购物，没到过尖沙咀和中环。</p>
<p>屋漏偏逢连夜雨，已经忘记上一次生病是什么时候的我，感冒了。</p>
<p>那个星期的每个深夜、清晨和午休，一边打着喷嚏坐在电脑前搜集资料，一边在脑海里来回切换香港和东京的景点、行程和注意事项。对我这种单线程生物来说，真是难忘（受）的经历，再也不想有第二次了。</p>
<p>上天保佑，一切顺利。9月26号出行日下午2点，我们登上全日空（ANA）的飞机。<br><img src="/2016/10/08/tokyo-go-round/ana_plane.jpg" alt="上翘的机翼" title="上翘的机翼"></p>
<p>一上飞机就像身临日本，空姐们轻柔的日语不绝于耳。没想到还在中国境内，汉语已经不能用了。朋友会一点日语；我只会说 すみません ，幸好英语还算过得去。</p>
<p>空姐英语都不错，还能说简单的中文单词，在我连续两次填错入境申请表，厚着面皮管人家再要一张的时候，这真是帮了大忙。把出生日期填成入境日期，我是过于兴奋还是没有睡醒呢。</p>
<p>有人说三万尺高空上的飞机餐不好吃，可能那饭后甜点——一小盒哈根达斯——拉高了印象分，我倒觉得还凑合。<br><img src="/2016/10/08/tokyo-go-round/launch.jpg" alt="午餐" title="午餐"></p>
<p>飞机先飞往上海，此后穿越东海，抵达东京湾再稍稍转个身在羽田机场降落。走下机舱时已经 8 点。<br><img src="/2016/10/08/tokyo-go-round/over_the_cloud.jpg" alt="高空飞行" title="高空飞行"></p>
<p>入境第一件事就是解决往后几天的交通问题。到了日本才知道之前看到的攻略有多不靠谱。</p>
<p>按计划，首先要到京急电铁问讯处买 Welcome! Tokyo Subway Ticket 套票，包含一张从羽田到品川的单程车票、一张 72 小时车票和一张 48 小时车票。</p>
<p>走到京急电铁问讯处，我俩都愣了一阵，谁也不敢第一个开口问工作人员。我是不敢讲英语，他是不敢讲日语。相互推脱一番后，朋友上前对工作人员——一位年轻女性——讲了几句日语，她似乎听不懂他说的话。在俩人都很为难的时候，我拿出准备好的行程计划，翻到交通那一章，指着 Welcome! Tokyo Subway Ticket 用英语说“我们要买这个”。她终于知道我们想要什么，但又说不可以全卖给我们，有一种票不在这里卖。正当我也迷惑的时候，她来了一句，“你可以说中文的，我会说中文”。</p>
<p>好吧，瞬间我们就很愉快地说起中文。原来问讯处可以出售把单程票和一张小时券捆绑在一起的套票，但不单卖小时券，要买小时券得到附近的另一家店买。她认真地拿出地铁路线图，在上面用红笔划上路线、圈起站点，把它交给我之后，还告诉我往哪里走到哪个月台，下一班车在什么时候到达。</p>
<p>日本人服务周到真是名不虚传呢，我俩开头乱了方寸，又慌张又尴尬，但最后信心满满地离开了。</p>
<p>刚转身，就看到让外国游客办理 Free-Wifi 的机器，操作十分简单，只需扫描一下护照。有了这个，在东京很多地方——包括地铁站——都能蹭 wifi ，速度还可以，虽然大部分时候我直接用 docomo 的服务。<br><img src="/2016/10/08/tokyo-go-round/free_wifi.jpg" alt="free_wifi" title="free_wifi"></p>
<p>接下来就是买一张小时券，走到店门口，朋友心血来潮走上前问店员能不能在这里买小田急的江之岛——镰仓周游券，话说到一半忽然停了下来，转头跟我讲还是买小时券吧（后来才知道他忘记“镰仓”的日语怎么讲）。</p>
<p>店里也有 PASMO 卡卖，不过我们想买西瓜卡，可走出来没看到哪里有西瓜卡卖。于是走到服务台问哪里可以买到，工作人员说卖卡的店已经下班了，但可以在前面的自动售卖机器里买到其它交通卡。她拿出一叠文件，翻到交通卡那一页，我一看，里面除了 PASMO ，不是有 Suica 卡吗，难道西瓜卡分两种？</p>
<p>我忍不住问这些卡跟西瓜卡有什么不一样，她说，“外观不一样”——这句话意外地击中我的笑点——“功能都是一样的”。</p>
<p>我在网上看过在机器上买卡的流程，虽然看不懂上面的提示，但操作起来得心应手。</p>
<p>按指示到月台等车的间隙，心终于安定下来，看了看周围，发觉地面给人一股异样的清净感。往后几天我才弄明白这种感觉是怎么回事：地面不是没有垃圾，偶尔还是能看到纸屑、纸杯的，但上面感觉不到一点灰尘；每天千万人次的踩踏，竟然把地面打磨得蹭光瓦亮。深圳地铁也很干净，但能感觉到地面铺了一层灰尘。</p>
<p>抬头看车次指示牌，即将到达的是另一辆车，品川方向（日文写作：品川方面）的排在它后面，还要再等十几分钟。东京地铁跟国内不一样：同一个方向，同一条铁轨，上面运行着几种车次。多数情况下，不同车次的区别只是经停车站多与少的区别，有些车次则是终点站不一样。我估计坐即将到达的列车也能到品川，但又不敢冒险。</p>
<p>趁机把手机 SIM 卡换成 docomo 的，上网大事交由 docomo 是明智的选择。朋友上网靠租用的随身 wifi ，但是效果非常不好，网速慢不说，耗电量是非常的大，玩着玩着很容易就会遇到断电、断网的境况。</p>
<p>坐东京地铁，第一感觉就是小。车厢宽度比深圳地铁的要窄，里面还挂、贴了各种各样的广告：大学文化祭通告，地方旅游景点广告，杂志广告，东京都议会例会广告……还有宫崎葵——我最喜欢的演员——的电视剧播出广告。</p>
<p>第二感觉是，传闻和电视里的地铁车厢安静场景都是骗人的。日本人跟天朝人在车厢里的表现差不多，独自一人乘车还能乖乖地低头玩手机（少数人看书），只要有个伴——无论男女老幼——一定会吱吱喳喳地讲话说笑。旁边三个年轻女性就一路聒噪，其中一个激动起来还踩了我一脚。一路上没少向日本人说 すみません ，没想到这么快日本人也会对我说。</p>
<p>花了大约一小时，终于到达JR新宿站。虽然抬头就能看到很多出口、线路指示牌，运气好点还能看到站内平面地图，但一出闸就身处汹涌人潮，站着不动片刻都要带走，加上没看到南口的指示牌，不由得慌了。</p>
<p>幸好还有谷歌地图，依着地图向南逆着人流走了一段路终于看到南口指示牌。在南口的手扶电梯上看到一个喝醉酒的中年男人，懵懂懂懂的，站都站不稳。真佩服他就这种状态也敢独自回家。</p>
<p>酒店距离新宿站有十几分钟路程，不远也不近。在办理入住手续时，服务生的那一口日式（印式？）英语真是把我听崩溃了，单词发音全是直来直往——哔哩吧啦飞快地说一通注意事项，完全不在意我有没有听懂，幸好柜台有英文手册，事先偷偷瞄了一眼：上面有说怎样在电梯里使用房卡，怎样用早餐券，什么时刻前要退房。</p>
<p>放下行李才 9 点多，时候还早，我们决定到歌舞伎町瞧瞧。</p>
<p>沿路返回新宿站，再一次感受偌大的地铁站，竟然找不到东北口指示牌的窘况，没办法，我们选择一路向北，走了不知道多久，走出新宿再折向东。</p>
<p>说实话，歌舞伎町给我的印象十分不好，街道中央每隔四五米站一个皮条客，有游客走近就像磁铁一样吸附过来，用日语、英语、中文套近乎，就算回绝他也能跟着走上两三米，直到下一个上来接力，真是不胜其烦。比较意外的是看到一个五六十岁的老爷子穿着西装也站在路中央拉客，一把年纪还得出来干这活，民生多艰呐，抑或是大爷早年生活作风不好，欠下一身赌债，偿还到现在？我忍不住脑洞大开。</p>
<p>走着走着感受有点饿，看到一家店名有“烧鸟”两个字的烧烤店，里面挺热闹的，决定就在这里解决晚饭。</p>
<p>点了一小碟六根烤串、一份拌饭、一小壶清酒。<br><img src="/2016/10/08/tokyo-go-round/dinner.jpg" alt="晚餐" title="晚餐"></p>
<p>不知道是不是故意的，烤串外面有些地方已经焦了，但内里还是很嫩，吃起来有焦有嫩还多汁，调味比较清淡。</p>
<p>伴饭上面有一只生鸟蛋（很小一只，不像鸡蛋），还有些细碎的紫菜，其他配料看不出来，搅匀之后，入口顺滑，吃不出半点鸟蛋的腥味，味道咸淡适中，层次丰富。</p>
<p>至于那清酒，与五粮液尖刀似的刺激相比，它像隔着抱枕的一记重拳。令人担心来日本第一晚就喝醉。店里很热闹，旁边就有一桌身穿水手服的妹子——像是附近的从业人士——在兴高采烈地聊天，吧台上也有独自一人喝酒抽烟的女性和下班后来小酌一杯的朋友同事。</p>
<p>回去的路上，飘起了小雨，没伞的人好像挺淡定，有伞的就撑起那种透明白边的伞，这种伞超级受欢迎，在哪里都能看到。九月到东京，得提防变幻莫测、说下雨就下雨的天气呢。</p>
<p>按计划第二天要早起坐小田急到江之岛-镰仓玩。</p>
<p>睡觉前才想起得换洗衣服。房间里只有干洗的指引手册，收费太贵不合算。网上说酒店有投币洗衣机，但没说在哪，于是我们一大早就下楼找洗衣房。</p>
<p>问一个上年纪的酒店员工——要是在天朝，早就退休享福的老爷子，他一再告诉我洗衣房在“ANNIX”的二楼，但我对“ANNIX”为何物真是一点概念都没有。他见我很困惑，于是带我走到一个出口，上面有指示牌，这时我才明白，原来“ANNIX”是酒店的另一幢建筑，他还想带我走到洗衣房，我立马说想先吃顿早餐，他又领我去另一层楼的中华料理餐厅，陪在一旁等候入席。日本人服务真是太热情周到了，言语无法表达我的感激，所以还向他鞠躬致谢。虽然我预想着第一顿早餐吃和食来着。</p>
<p>吃完早餐，到“ANNIX”洗衣服，还花了二十分钟烘干，不得不说那烘干机实在太坑，效果还不如用手拧！之前一点都没考虑过衣服的问题，是一大失误，下次出游一定要带够每天一件的量，免去洗衣服的麻烦。</p>
<p>虽说早就知道，小田急旅游服务台在新宿站西口外面，但我俩是连蒙带逛了好一阵才找到它。朋友经历过京急电铁那次尴尬，学乖了，一上来就问服务员可不可以讲汉语，结果人家干脆利落地说不。他日语还没到能买周游券的程度，英语比日语更差，最后还得由我出马。哈，又尴尬了。</p>
<p>有人提到，担心到江之岛的列车没座位的话，可以在月台加钱买“浪漫特急”。不过担心是多余的，据我观察列车开出前，车厢没坐满。</p>
<p>第一天坐地铁时，就发现列车开关门都是人手操作的，列车员站在车门旁，一边观察上落车情况，一边伸手进去按关门键，时常有人最后一刻才上下车，很考验反应能力呢。小田急这趟也是如此，更厉害的是，报站、开关门、巡查都是由同一个列车员小哥来完成的。小哥巡查时，进入每一节车厢做的第一件事就是稍微鞠一躬，就算没人看过去，他也这样做。真是很佩服他，自忖做不来，我一定会趁没人注意偷个懒省去这个步骤的。</p>
<p>列车从新宿驶往片濑江之岛，沿路都有建筑，区别只是从高楼慢慢变成独幢小房子，偶尔见到河川，还有立体停车场。这时车厢照进一方阳光，鲜明但却似日光灯不带一点热度。除了车轮摩擦铁轨的响声，周围都很安静，深呼吸，然后用肌肤感受这种清冷的氛围。因为知道这个时刻转瞬即逝，我赶紧拍了一张，希望日后能唤起这个记忆吧。<br><img src="/2016/10/08/tokyo-go-round/on_the_train.jpg" alt="车厢" title="车厢"></p>
<p>还没走出片濑江之岛车站，就能感受到今天是阳光灿烂的日子。面对如此晴朗的天气，几个年轻的日本游客也激动得忍不住哇哇大叫。</p>
<p>走过桥，立刻被右手边的景致吸引着了，此刻没有停靠一艘船的船坞像一双要拥抱了万顷星光的手，阳光下泛白的屋顶显得比平日更为干净。左手边是几公里长的弧形海难，白色的浪不时拍打金黄的海岸，退去，消散，留下一片暗黄的濡湿。</p>
<p>耳际不时传来几声短促的鸟叫声，抬着一看，天空中竟然飘着两只展着翅膀的鹰，看着它们在蔚蓝的天空悠然地漫游，真是不敢相信，因为在天朝已经很久没见到活着的鹰了。</p>
<p>沿着笔直的河堤又走了一段路，才发现这片海、这片天是鸟类的天堂，除了鹰，还有麻雀、乌鸦、海鸥，不过活得最为自在的还得数鹰，它们伸累了胳膊就蹲在路灯上歇歇脚，不时扭扭头，眨眨眼。</p>
<p>江之岛上有座神社，名字取得很随意，就叫江岛神社。入乡随俗，走进鸟居前先鞠躬，在手水舍洗手漱口，到拜殿投钱许愿。说得轻巧，做起来步骤挺多，我都是在一旁观察好几个日本人怎样做，确信自己都记住了才走上前。</p>
<p>许的愿望是旅途顺利。</p>
<p>阳光炙热，走走停停不到三十分钟，就汗流浃背，对我来说，除了海景，岛上还有很多有趣的东西，比如脚下这块文艺的下水道井盖。<br><img src="/2016/10/08/tokyo-go-round/manhole_cover.jpg" alt="松树井盖" title="松树井盖"></p>
<p>还有这块“春日钓灯笼”石碑，完全猜不着是什么鬼。<br><img src="/2016/10/08/tokyo-go-round/stone_tablet.jpg" alt="石碑" title="石碑"></p>
<p>下面这个贴在电表上的小广告，无论是行为本身还是上面文字都很有广东特色（广东人蔑称外国人为鬼佬）。<br><img src="/2016/10/08/tokyo-go-round/ad.jpg" alt="小广告" title="小广告"></p>
<p>因为担心下午没时间走完行程，所以没在神社呆多久，沿路返回时还拍了一段鹰击升空的视频，在这海岸当一只鸟比做人还自在快活吧。</p>
<p>中午饭没有特意去找好吃的，在走往江之岛车站的半路，见到一家叫 纪依国屋 的食店，很多人在里面吃饭，想着在日本到客人多的店吃饭总没错，于是就走了进去。</p>
<p>点了一份 1000 日元（含税）的刺身，店里还有免费饮料，光是吃的就物超所值。我和朋友还被领进了里面铺上塌塌米的坐席，意外地体验了一番日式的就餐环境。<br><img src="/2016/10/08/tokyo-go-round/sashimi.jpg" alt="刺身" title="刺身"></p>
<p>有意思的是坐在我对面的妇人点了跟朋友一样的天妇罗套餐，连两人各自去取的饮料都是绿色的芬达，好尴尬啊。</p>
<p>可能真是不习惯盘腿吃饭吧，两人穿上鞋子后腿脚酸麻得伸都伸不直。</p>
<p>道路两旁是日剧、电影中常见的街区小道，天气实在太好，忍不住又拍了一张。<br><img src="/2016/10/08/tokyo-go-round/street_view.jpg" alt="街景" title="街景"></p>
<p>江之电在小镇上快速穿行，时常像人一样侧身躲过前面的建筑物，险象环生，一家后院停放的小货车就靠在铁路旁，跟我相距十几厘米；几个孩子就在没有没有隔离护栏的轨道旁玩耍嬉戏。他们父母就不担心吗？不过可能他们都习以为常了吧。</p>
<p>列车途经海岸，此处的海岸线几近直线，镰仓直面太平洋，一望无际的水面在靠近海岸时陡然翻起两米多高的浪头，显然今天十分适合冲浪。<br><img src="/2016/10/08/tokyo-go-round/wave.jpg" alt="海浪" title="海浪"></p>
<p>在镰仓高校前站下车，这是个十分迷你——不到三米宽，十米长——的站台，只有一个出口，出口处没有闸门，也没有工作人员检票，只有一架刷磁条卡的机器，刷不刷卡全凭自觉。</p>
<p>镰仓高校前的这个平交道是灌篮高手粉丝们的圣地，想不到过去这么多年了，烈日暴晒下游人依然这么多。我在这附近站了很久，镜头里面始终都有拍照游客。</p>
<img src="/2016/10/08/tokyo-go-round/cross.jpg" alt="平交道" title="平交道">
<p>下一站是长谷寺，站前有一间百元店。日本的百元店真不是骗人的，加上税，商品都是108日元，买了一瓶雪碧。</p>
<p>长谷寺是个十分可爱的寺院。整个庭院是日式设计，紧小精致，偶尔能在草地上看到笑容可掬的地藏菩萨（在日本，地藏菩萨是旅行者、孩子的守护神）。<br><img src="/2016/10/08/tokyo-go-round/bodhisattva.jpg" alt="地藏菩萨" title="地藏菩萨"></p>
<p>提到日式庭院，你可能会想到苔藓、樱花、松树、枫叶，这些长谷寺都有，有意思的是院旁边还种着一丛茂密的竹林。站在竹林小径里，微风拂过，万叶婆娑。<br><img src="/2016/10/08/tokyo-go-round/bamboo.jpg" alt="竹林" title="竹林"></p>
<p>相比长谷寺的惬意，高德院就乏味很多。高德院占地大，售票处就占了一个院子。游客也多，这些游人应该不是来捉小精灵的吧？之所以这样说，是因为院子门口立了一个牌子： No Pokemon Go here !</p>
<p>朋友饶有兴致地跟大佛合照了很多张，我对大佛没多少兴趣，唯一想知道大佛是不是实心的，当走到大佛侧身时看到它身后长了一双小翅膀，那是一扇从里面打开的窗户。整座大佛只是一层薄薄的铜皮，想来金属铸就的佛像都是这样的吧。<br><img src="/2016/10/08/tokyo-go-round/buddha.jpg" alt="大佛" title="大佛"></p>
<p>在走往八幡宫的路上，看到一家店铺别出心裁地在铁闸门上画了幅附近景点地图，看多了“门前不准停车，违者后果自负”，这样有意义的涂鸦第一次见。抬头看一眼店铺的招牌，原来是消防局。<br><img src="/2016/10/08/tokyo-go-round/painting.jpg" alt="铁闸门上的画" title="铁闸门上的画"></p>
<p>八幡宫好像是为了十月初举办的祭典在整修，神社的气势比前面两间寺院都要宏大。我喜欢神社前面那一塘荷池，近处的一片荷叶上托着一堆白闪闪的百元硬币，想不到日本人也好这口。水中游弋着体长超过半米的草鱼，一听到由远及近的脚步声，这些家伙就冒出头来，张着大嘴。一个日本老太太对它们说了句话，我听懂一半，大意是：对不起，今天没带东西给你们吃。<br><img src="/2016/10/08/tokyo-go-round/dutch_pool.jpg" alt="荷池" title="荷池"></p>
<p>我俩在侧门离开八幡宫时，刚好见到两个神社职员迎送一辆小货车驶出去，我俩又走了七八米，回头看，他俩还在路中站着目送。日本人就是喜欢在这种别人看不到的地方下功夫。</p>
<p>走了大半天，我们只是在肯德基喝了点东西稍稍歇了会儿，朋友打算在景点附近找家店解决晚饭问题，可惜天一黑景点的游人就都走光了，没几家商店在营业。</p>
<p>无奈之下，我们只好乘江之电打道回府。在等电车的间隙，来了好几拨中学生。真是搞不懂日本中学生的放学时间，在夜晚各个时间段都能见到乘地铁的中学生。说到中学生，我能总结一个关于女中学生的规律，判断一个女学生是在上小学、初中还是高中，只要看她的裙摆长度就行，下摆越短，年级越高。奇怪的是，日本成年女性的衣着并没有依照这个规律，而是比中学时代还要内敛。在东京看到一个露出大腿的成年女性，十有八九都是外国人，这点我亲自验证过五六回，迎面走来一个穿短裙、亚洲面孔的女性，走近时就会听到她在讲中文或者韩语。</p>
<p>回新宿的地铁开出几站后，忽然困意来袭。在国外的列车上睡着可不是开玩笑的，我用这点仅剩的理智，抬起眼皮，数次把快要失去知觉东倒西歪的自己拉直，直到一个男中学生坐到我对面，忽然间清醒了。这学生刚才跟几个同学一起，就坐在跟我同侧隔几个人的座位上，此刻他跟之前一样捧着一本小书。我扭头看了看他的几个同学，猜测他换位置可能是因为他们都在玩游戏，而他想看书吧。</p>
<p>他有这种想法是好的，不过很快他跟我一样犯起困来。看着他从最初捧着书到把头埋在书中，再到东倒西歪的样子，我不禁想起了自己当年读初中的时候也是如此，一读书就犯困。</p>
<p>回到新宿，随便找了家拉面店吃晚饭。第一次吃拉面，走到店里面不知所措，经店员提示才知道要先在店门口的机器上选好，又走回去，好尴尬。</p>
<p>第三天早上，我如愿吃上了日式早餐，从份量上看它比中午的定食还要大。据《江户时代的老菜谱》说，江户时期的日本人把早餐当作正餐，这天往后吃的都是早餐吃剩下的食物。<br><img src="/2016/10/08/tokyo-go-round/breakfast.jpg" alt="丰盛的早餐" title="丰盛的早餐"></p>
<p>这顿早餐还有纳豆（上图没有出现），除了像莲藕般扯不开咬不断的丝线令人吃着尴尬，纳豆味道也很不好，最突出的一点就是苦，苦得让我怀疑是不是过了保质期或者是坏掉了。然而从吃完后并没有闹肚子来看，纳豆就是这个味儿。</p>
<p>这一天我跟朋友分开行动，他去看富士山，我计划到新宿御苑和江户东京博物馆看看，还有时间就到国立西洋美术馆。</p>
<p>花了半个小时从酒店走到新宿御苑，大清早的御苑还没有几个人。漫步在母子之森，有种一个人承包整个森林的感觉，树上不时有橡子掉落下来，看着有小指头那般粗的橡子掉在地上还能蹦几回，真有点担心被砸中。</p>
<p>快走到日式庭院时，见到一个独自坐电动轮椅的老奶奶，她一看路牌写着日式庭院，扭头就走，很是潇洒。在东京，行动不便的人也能放心出行，在地铁里见过两次盲人靠着手杖自己走路，在国内却一次都没见到过。</p>
<p>在树林里走着走着，一个老外情不自禁地说了句，我从来没看见过长这么高大的XX树。显然他是想跟我搭话，然而我听不懂他说的是什么树。只好说对不起，问他说的是什么树。他指着一棵银杏树，说不知道用中文或者日语怎么说，但是它掉落的果实很臭。我明白他说的是银杏，但怎样告诉他我懂他说的话呢，只好说在我读书的大学里也有几棵，一到秋天叶子会全掉光（事后觉得这样说很蠢，落叶乔木不都这样吗？我应该说，中国人会把发臭的果实变成好吃的白果，英语要是再好一点可以向他强行科普一番，银杏产自中国，最开始只生长在浙江天目山和西南部几个山区）。之后还说了几句为啥北美的银杏长不高，我是哪国人、来东京干嘛。最后分别时说了一句“Have a good day”，我还没反应过来，只好原话奉还。</p>
<p>新宿御苑有三大庭院，除了日式，还有法式和英式。法式庭院讲究工整对称，可惜来得不是时候，庭院两侧高大的法国梧桐叶子还未变黄，而花坛里的月季却已凋谢大半。</p>
<img src="/2016/10/08/tokyo-go-round/indus.jpg" alt="梧桐" title="梧桐">
<p>英式庭院最为简单，就是一大片平整的草地，上面种几颗大树。这种大而无当的空旷感，身处其中会有躺倒或狂奔的冲动。<br><img src="/2016/10/08/tokyo-go-round/lawn.jpg" alt="草坪" title="草坪"></p>
<p>走累了，在一块有树影的草地上坐着的时候，来了一群幼稚园小朋友。他们在老师（兴许还有家长）的组织下先在草地上休整，然后三个一组在公园各处游荡。</p>
<p>陆陆续续又来了两大群小朋友，他们排成一队走路时还前后手拉着手。负责拍照的老师在忽前忽后地拍照。<br><img src="/2016/10/08/tokyo-go-round/path.jpg" alt="树林小径" title="树林小径"></p>
<p>离开新宿御苑，走到新宿三丁目坐电车江户-东京博物馆。还在楼梯没到月台，列车即将到站刮起的阵风吹得人差点站不稳，东京有些地铁站连屏蔽门都没有，人多等车时十分危险；好一点的装了半封闭式屏蔽门，但列车一来风就会吹乱头发，都比不上深圳的全封闭屏蔽门。</p>
<img src="/2016/10/08/tokyo-go-round/poster.jpg" alt="痴汉海报" title="痴汉海报">
<p>江户-东京博物馆，顾名思义，这是一间关于江户和东京的历史博物馆。博物馆的常设展览场所在五楼和六楼，五楼是江户历史展览，六楼是东京历史展览。建议先从五楼开始逛。</p>
<p>在一楼每年还有5、6个特别展览，我去的时候展出的是一个致力于向欧洲介绍日本风物文化的德国医生、植物学家 Siebold 的生平，印象最深的是直到死前他都在努力争取第二次出行日本。</p>
<p>那几天都背着电脑到处跑，考虑到要在博物馆逗留几个小时，老背着两三斤的包可不行。于是在一楼找到储物柜，令人汗颜的是，上面并没有中英文操作指引，有的柜子关上，有的柜子上面插着钥匙但又关不上，完全不知道要怎样才好。</p>
<p>这时走过一个店员（博物馆内的商店），我不失时机地向他请教。他告诉我柜子是要用100日元租用的，往上面的孔放进100元，放好东西，关门取走钥匙。回来的时候用钥匙开门，100元会自动从下面的孔滚出来。</p>
<p>我以为自己听得很明白了，于是动手实践一把：掏出100元，放进上面的孔，关门，扭钥匙开门，结果一时没看到100元从哪里滚出来，还是他伸手帮我拿的。</p>
<p>可能是因为觉得我蠢蠢的，直到真正放好东西前，他都在一旁和善地看着防止出差错。</p>
<p>博物馆的软硬件设施都不错（比11年的中国国家博物馆要好），可以在前台租借语音解说设备，也可以在每个展览区阅读电子版文字解说（有中日韩英四种语言），还有懂中/韩/英的志愿者提供现场解说服务——视乎当天志愿者的出席情况。</p>
<p>德川家康于1603年以江户为据点设立幕府，距今400来年，不像2000多年前的古迹遗物，今人只能根据残存的雪泥鸿爪想象、推测历史，江户的历史后人可以了解得很详细。即使我抱着这个想法参观，仍然被博物馆的展览震惊了。馆内有一个关于1657年的明历大火的动画，以时间为轴，在江户地图上演示了星星之火发展成燎原之势到将近熄灭还死灰复燃的全过程，不可思议的是，动画里竟然还标示出实时风向。</p>
<p>展览大都包含着非常多的历史信息，馆方力图通过各种手段使展品不平淡乏味地示人。比如说江户的发展带动了周边地区的经济，如果想知道江户人爱吃的某一种鱼是哪个岛提供的，可以通过点击屏幕生成动画告诉你答案；动手翻牌子来猜猜明治维新前后江户东京人的各项变化；每隔一段时间歌舞伎座就会上演一段带配乐的机关表演、玻璃地板下鹿鸣馆里的宾客就会踏着西洋乐的节拍起舞。</p>
<p>与各式各样的展览手法相比，我更喜欢各个展区的文字描述。不知道十几个展区的文字是不是出自一人之手，能感觉到行文的风格都是一样的冷静中立。在说完历史事件的正面影响之后，一定会补充其负面影响，反之亦然。</p>
<p>中午来到博物馆，不大的两层空间，竟然走到闭馆还没看完。东京这座拥有400年历史的城市，如果只可以用四个字来形容的话，我会说：浴火重生。先后经历过大火、大地震、大空袭，每次东京被几近化作焦土，但每次都迸发出更强的生命力，变得比之前更好。令人佩服。</p>
<p>临走前，看到一个志愿提供英语向导的老人家，在介绍几十年来小学生的早餐变迁。他说自己小时候的早餐只有几片面包加水，而现在他小孙女吃的就像面前的展品一样，有面包、牛奶、鸡蛋、杂果、蔬菜（沙拉）。早餐的丰富程度令几个外国游客以及我惊叹不已。</p>
<p>晚上回到新宿，等朋友从富士山回来。之后不能免俗地去吃蟹道乐，感觉蟹的味道一般，说实话还不如深圳桃园某家音乐餐厅的4人份泰国菜套餐呢。也就尝尝鲜，之前未吃过生的蟹肉，原来口感是如此松软无力，就像是冷掉的葡式蛋挞。</p>
<img src="/2016/10/08/tokyo-go-round/wine_and_crab.jpg" alt="蟹和梅子酒" title="蟹和梅子酒">
<p>那顿饭令我念念不忘的却是一杯加了冰的梅子酒，与之前喝过的劣质梅子酒不同，它清冽酸甜，不带半点苦涩。一回想起这点，就在刚才忍不住下单买了瓶日本产的梅子酒，希望口感依旧吧。</p>
<p>第四天，手机的计步器显示，在东京暴走了20.3公里。</p>
<p>我们打算吃遍酒店几家早餐店，那天轮到西餐。与中餐、和食相比，西餐要逊色得多，我嫌面包要涂黄油或果酱麻烦，钟爱皮薄干脆的小烤肠。除此之外留下记忆的就只有不咸不淡的玉米糊。</p>
<p>吃完早餐第一站是皇居外苑。</p>
<p>我们坐地铁到二重桥前站，在东京大多数时候都是靠左侧行走，但也有例外，（没记错的话）二重桥站进出站就是靠右侧行走的。我还发现东京的地铁站，进出站的楼梯至少一侧挖一个排水渠，如果天花漏水，还会用胶带收集起来导流到渠里。进站口地势就比周围高，就算万一被水淹了还有排水渠，这一点比深圳地铁做得好，深圳地铁下大雨时唯一能做的就是堆沙包了。</p>
<p>我对皇居和二重桥没多大兴趣，但走近时一幢建筑物闯进视线，真是意想不到，忽如其来！这不是来东京之前一直想瞧瞧的东京警视厅吗？</p>
<p>作为一个相棒脑残粉，一直想到警视厅朝圣，要知道一个外国人到警视厅外面转悠很容易引起误会的，搞不好就进局子耽误一天了，但难得有这个机会，我还是要在皇居喊一声：“右京叔，我来看你啦！”</p>
<img src="/2016/10/08/tokyo-go-round/police_department.jpg" alt="远处的警视厅" title="远处的警视厅">
<p>前往楠正成铜像时，看到前面走着一大群小学生，朋友耳尖，听出他们是来自天朝帝都。然后我嘴欠走上前跟一个小子搭话，先确认他们是不是帝都的小学生，得到肯定回复之后，我（自以为）称赞了一句“你们学校真厉害啊，选择这个时候来东京旅游”，人家回了一句“我们不是来旅游的，我们是来交流的”。</p>
<p>悻悻地道了歉，想像力太差，层次差距太大。辛苦工作好几年，才凑够钱赴日远游一趟，怎能想到人家小学就能达成，还是以交流的名义呢？</p>
<p>离开皇居，坐地铁到银座，时候还很早，很多店铺都还在准备中。漫无目的的走了会儿之后，朋友提议到附近大一点的电器店给他上司买手表，还得给他某个亲戚买保温杯。</p>
<p>从银座走到有乐町，看到一个僧人，站在一个十字路口的边上手捧钵碗举到胸前化缘，如果算乞讨，这是在东京看到的唯一一例。</p>
<p>最终我们走到 BIC CAMERA 有乐町店 ，在那里逛很久，肚子里已经憋不住一泡尿的时候，我用刚学的一句日语问销售员“请问厕所在哪里呢”。她回了好几句话，一句都没听懂，看她的手势大概是往回手上楼梯。幸好厕所在楼梯很显眼的位置。</p>
<p>BIC CAMERA 提供免费寄送商品到顾客入住酒店的服务，正适合那些买了大件又得赶往下个目的地的游客。</p>
<p>走出电器店，又到了饭点，附近不像是景点，倒有点像白领办公的区域，地下有一条美食街，我们进去逛了一圈，最终选了一家卖咖喱饭的小店。据说最受日本人欢迎的一道菜就是咖喱饭，这家店看着像是印度人开的，听着他们说一口纯正的日语感觉有点怪，同样怪异的还有日式吧台摆放着阿拉丁神灯造型的咖喱杯。这种混搭的产物——味道甜甜的一点都不辣的咖喱饭——却是非常好吃。</p>
<img src="/2016/10/08/tokyo-go-round/curry_rice.jpg" alt="咖喱饭" title="咖喱饭">
<p>下午陪朋友去了台场。在那儿坐摩天轮，朋友坦言想不到第一次坐会跟我一起，遗憾的是我有资格原话奉还。从摩天轮走回高达塑像的地下商店街很绕，走得晕头转向、心烦意乱时还好可以抬头看看画在天花板上的蓝天白云，柔和的灯光照在上面有点奇幻的感觉。<br><img src="/2016/10/08/tokyo-go-round/ferris_wheel.jpg" alt="摩天轮" title="摩天轮"></p>
<img src="/2016/10/08/tokyo-go-round/ceiling.jpg" alt="人造蓝天" title="人造蓝天">
<img src="/2016/10/08/tokyo-go-round/small_balls.jpg" alt="走得饿了，来一碗章鱼小丸子" title="走得饿了，来一碗章鱼小丸子">
<p>按计划我们只在东京塔下走一遭，再到六本木之丘看东京夜景。如果你想跟东京塔合照一张，总不能身处塔上吧？</p>
<p>担心六本木之丘的森大楼会是整个旅程最难找的目的地，出发前还用谷歌街景走了一趟。后来沿着高架桥往西南走一段路就看到了，难度大的反而是找52楼观景台的售票处。森大楼一二三层都走了个遍，最终也忘了在几楼找到柜台。</p>
<img src="/2016/10/08/tokyo-go-round/spider.jpg" alt="森大楼前的蜘蛛" title="森大楼前的蜘蛛">
<p>森大楼的电梯十分有意思，速度快自不待言，天花的灯光色调还会随着楼层改变而渐变。</p>
<p>晚上天色要比白天好得多，能看到远处的小小的晴空塔，很难想像东京之大，灯火通明一直延伸到地平线。全身橙红的东京塔就在眼皮底下，活像一个模型。</p>
<p>观景台还提供——当然不是免费的——拍照服务，那销售手法简直是教科书式的：先是说可以免费帮游客跟东京塔合拍一张小照片，至于照片有多小，不说；当走到服务台拿照片时，展开在面前的是一片很小的、一张很大的照片和明信片，它们都整齐地安插在一张制作精良的折页上，服务员这时候会对你说：这片小的你可以免费取走，你只需要出XXXX日元就可以带走这张大，我们还额外赠送明信片。</p>
<p>看，我们都装好了，只需要XXXX日元，你就可以全带走了哦！要怎样办呢，特别是有朋友在身边看着的情况下，恐怕只能乖乖掏钱了。朋友就是这样。</p>
<p>回到新宿站，走累了也饿了，就在站内一家店吃晚饭。我点的是海胆和明太子意大利面，芡汁丰富，面很好吃，只是海胆海胆味道有点怪还有点苦。原以为可以尝尝菜单推荐的自家酝清酒，不幸卖光了，只好来一杯酒味全无的威士忌苏打水。</p>
<p>回到酒店看了下当天步行距离，还差一点点就满20公里，心想怎能轻易放过这个成就呢？抱着就算断腿也要多走几百米的决心，我们晚上十点多还到东京都厅附近转转。</p>
<p>不走寻常路才能看到寻常之外的风景，在一处天桥下，昏黄的路灯照着人行道两旁流浪汉们的简易窝棚，他们有的已经睡着，还没睡的，在静静地读着文库本。在天朝，读书和流浪这两种互斥行为，只存在于文青的想像里，爱读书的人怎会沦落到露宿街头呢？反过来无片瓦遮头的人做什么也轮不到读书。流浪和读书都只是他们的爱好和个人选择吧，或者是我太肤浅，理解不了这种人生追求。</p>
<p>前天走多了路，第二天下床时脚底还隐隐作痛。到25楼可以看到周边景致的餐厅找吃的，那儿的人比另外三家都多，餐厅提供中西和三式自助餐，面对众多选择，我还是拿了西式小烤肠。</p>
<p>朋友安排了大神宫和神田明神神社两趟拜神之旅，听他介绍，大神宫是求姻缘的，能看到很多为此而来的日本妹纸，在祈愿时，要用5元的硬币，因为5元的日语发音跟缘份相近。</p>
<p>事实真如他所说，来参拜的除了我俩，基本都是妹子。大神宫跟它的名字恰恰相反，是我见过的最小的神社，目测能让游客走动的范围一百平方都不够。院落有一个喷雾加湿器，我就坐在加温器旁边看着朋友诚心诚意地在各个他能找到的神明所在一一许愿。朋友家里已经替他购置一间大房子，工作也稳定，就缺个女主人；而我选择独自在外漂着，想着不要房子、妻子、孩子，两种人生就像一个静静坐着，另一个奋力四处奔走。</p>
<p>就算你不求姻缘，大神宫也值得一去。即使人在东京，它附近的居民区能满足你对日本小镇的想像：远离尘嚣、游客绝迹、自给自足、生活悠然。</p>
<img src="/2016/10/08/tokyo-go-round/bulletin_board.jpg" alt="社区布告栏，看看上面都有些什么" title="社区布告栏，看看上面都有些什么">
<p>从大神宫到上野会在秋叶原站换乘地铁，朋友一见到“秋叶原站”这个牌子就兴奋地让我帮他拍照，为了把他和站牌定格在一张照片内，我蹲下身子取景。拍好之后扭头一看，对面月台挤满了人，而这边月台只有几个，感觉好羞耻啊。</p>
<p>上野站是东京的北大门，繁忙的交通枢纽，上野公园就在车站旁边，隔一条马路。公园全名是上野恩赐公园，东京有几个公园全名都带有恩赐二字，大概是因为公园原本归皇室私有，后来皇室交由政府管属，向民众开放。在称呼时也往往被省略恩赐两个字。</p>
<p>刚走进上野公园就看到国立西洋美术馆，再往前走还有到处画着熊猫画像的上野动物园。除此之外还有博物馆、文化会馆、神社，包含太多别的东西，要说它是一个公园反而显得不真实。</p>
<p>走在其中挺惬意的，公园里的鸽子一点都不怕人，它们三五成群在树根突起的泥地上啄沙子，人就在泥地上的石板行走，相安无事。</p>
<p>我们走着走着走出公园也不自知，临街有个敞开大门却又空无一人的门庭，朋友说想进去看看，反正没有禁止入内的标示，进去看看没有损失。</p>
<p>于是我们误打误撞走进了东京艺术大学的展览，在一楼楼梯处领一纸展品描述，上了二楼。展出十分简单，百来平方的屋子里只有五六件雕塑作品，能看懂的有木板装钉组成的波音787飞机，一侧的机翼上竟然安放着都市大楼；还有由整块塑料泡沫雕刻形成的地狱之门；所有作品都是直立放在地板上的，唯独一架腾空而起留下大股烟雾的木雕火箭横着插在墙壁上，起初不明白为什么要这样摆放，直到离开时在门口回头一看，才发现如果火箭也立在地板上，整个展览就会显得死板单调，就火箭本身来说，横着摆这种有违常规的做法比竖着摆更有冲击力。</p>
<p>离开展览会场，我们又走回到上野公园，在喷水广场看到几个或躺或坐无所事事穿着蓝缕的流浪汉，还有一位母亲像遛狗一样用绳子系在到处跑的孩子身上，不知这位母亲会怎样向孩子解释这些流浪汉是怎么回事呢。<br><img src="/2016/10/08/tokyo-go-round/mother_and_child.jpg" alt="遛孩子的母亲" title="遛孩子的母亲"></p>
<p>在一处空地上还有三个人在准备露天表演，我们在旁等了一阵还没开场就走了，草木深处有一家小吃店，名字叫新鹭亭，忽然有点饿。</p>
<p>小店在我们之前还没有顾客，只有一个服务员，店家的菜单制作很用心，除了用有活力的英语翻译好外，还配上手绘的食物图画。我被关东煮的图画吸引住，各种食材被巧妙地组合成一个僧人，没留意店家在菜单上的建议：份量较大，适合很饿的顾客。结果吃得很饱。<br><img src="/2016/10/08/tokyo-go-round/menu.jpg" alt="菜单" title="菜单"><br><img src="/2016/10/08/tokyo-go-round/Kanto_cooking.jpg" alt="关东煮" title="关东煮"></p>
<p>在我们坐下后，来了——一男一女——一对年轻人。在等菜闲极无聊时，想好好听听他俩说话，结果人家很少说话，声音也很小，除了男的中途大声地说了几句，几乎都听不清楚。他们刚吃完，我们也跟在后面走了，我得以好好观察那个男的，他穿着举止竟然很女性向：脚上一双粉色船口鞋，左手九十度角挽着一只包包。东京人这么开放，想必穿萝莉装也大有人在，看不到只能怪自己运气不好了。</p>
<p>公园内有祭祀德川家的东照宫——可以理解为最高统治者的家祠，神社内的石灯笼数不胜数，上面都刻有姓名，大概是历代家臣、大名捐献的。主殿被一圈矮墙包围着，矮墙正面设有一扇华丽非凡的大门，名字虽然叫唐门，但大门屋顶是典型的日式弓形线条，半点唐代风格都没有。门两侧的龙倒是唯妙唯肖，尽得真传。</p>
<p>在走去看西乡隆盛像时，离雕像很远就见到一个小小的铜像站在广场上，以为西乡隆盛像这么寒伧，难掩心中的失望。走近一看，原来是个站着不动的街头艺人，中年发福的西乡隆盛在他身后不远处高高的底座上，牵着一条狗，不比艺人好看多少。</p>
<p>朋友想吃鳗鱼饭，但走遍了阿美横街都没见到，于是打开谷歌地图，导航到附近一家评分还可以的店家。走到门口一看，竟然是伊豆荣。额，都来了，总不能像其他游客一样合个影就一走了之吧？</p>
<p>下午两点多的鳗鱼饭，凉了。鱼身看着已烤焦，口感却一点都不硬，鱼肉入口即化，就是有点咸。</p>
<p>接下来我俩分开行动。朋友去浅草寺，我去东京车站对面的 KITTE 寄明信片。</p>
<p>在外面看会以为东京车站不大，里面却大得惊人，墙上挂着的巨大电子显示屏上面密密麻麻的车次信息，会令人产生身处国际机场的错觉。我不知道 KITTE 在车站的哪个方位，车站分东西两大广场，茫茫然选了西广场，走出车站看到熟悉的红砖西式建筑，车站前面正在为2020年东京奥运会施工整修，只好跟着人流走，幸运地看到了对面带 KITTE 几个字的大楼。</p>
<p>虽然知道根本用不着，但忍不住买了几套日本邮票。工作人员的英语不是很好，寄明信片回中国时真是费了不少劲呢。</p>
<p>分开前朋友说浅草寺能逛好几个小时，结果过了才两个小时就打电话问我弄妥没有。我只好匆忙赶往下一站末广町。在东京坐地铁，最怕就是从JR线换到都营线，有时两者车站入口隔得有点远，而方向指示牌会中途突然消失，把你扔到不知何处。在神田换乘银座线到末广町时就是这样。还好那天幸运女神站在我身边，无论怎样走都能到达目的地。</p>
<p>朋友跟我说他在浅草跟一个穿浴衣的女孩子合照了，我看了照片，姑娘还挺漂亮呢。在东京偶尔能看到穿和服的女性，但无一例外都比我大一两辈，没能看到年轻一点的也是遗憾。</p>
<img src="/2016/10/08/tokyo-go-round/school.jpg" alt="来自明光村中学附属大学的朋友们，让我看到你们的双手" title="来自明光村中学附属大学的朋友们，让我看到你们的双手">
<p>朋友到神田明神是来朝圣的，他说总得要在日本留下点东西，于是写了一个绘马。这家神社的绘马特别多，架子就有三处，而且因为有 Love live 加持，绘马的颜值很有可能是全日本最高的，我饶有兴致地把绘马架子都看一遍，发现有不少天朝人也许下跟 Love live 相关的愿望呢，这部动漫的感召力真是超强的。</p>
<img src="/2016/10/08/tokyo-go-round/ema.jpg" alt="颜值爆炸的绘马" title="颜值爆炸的绘马">
<p>离开神社，秋叶原就在不远处。秋叶原真是年轻人呆的地方呢，街上人群的平均年龄要比新宿的小十岁。朋友买了一个PS4游戏、几张游戏王卡牌之后，说想去女仆店吃蛋包饭，这是他几大心愿之一，只是一个人去不好意思。言下之意就是带上我了？</p>
<p>不过我对吃的要求比较高，听说女仆做的饭味道很一般，简直就是浪费钱，所以就断然拒绝——其实我听说妹纸颜值高的店都得排很久队，普通一点的虽然不用排队，但又过于普通了。</p>
<p>在他去吃饭期间，我在几幢大楼里到处逛。游戏不玩，出版物看不懂，贴纸又太贵，抱枕、垫子太工口，手办嘛，原本想找找千反田的，但是日本一年究竟出了多少部新作，4年前——且市场反应平平——的冰菓怎会还留得一席之地呢？</p>
<p>话虽如此，琳琅满目的手办还是令我大饱眼福，流连忘返。几个裹着头巾穆斯林女性也徜徉其中，很想知道，被衣着暴露的公仔包围，她们心里是怎样想的。</p>
<p>朋友吃完蛋包饭，很兴奋地诉说女仆的服务有多好，他和女仆一起做了哪些羞耻的举动。我把他拉进手办店，怂恿他买了个黑魔导士。</p>
<p>走起路来不觉饿，一回到酒店肚子就咕咕，放下东西决定出外吃饭。新宿站到酒店的路上有一间位于街角、其貌不扬的拉面店，每次经过都想着下一次就去吃。终于有机会了。</p>
<p>然而我又犯傻忘记了先到门口机器下单的规矩，在吧台前呆呆地站了一阵子，享受着店员、顾客们投过来的不解目光。拉面店很小，一切事情只由两个人来做。煮开水、下面、捞面、浇汤、下配料、上菜、收拾、洗碗，这些统统都是两人在顾客眼皮底下完成的。客人点好菜后，先上一杯冰水——东京的自来水可以直接喝，很方便——能喝出来这是加了冰的自来水。</p>
<p>自从坐下后，一直怀疑斜对面的几个妹纸在议论我，一直是刚才行为太怪异，她们在猜我是哪国人。几个先我吃完的客人在走前都说一声“我吃饱了”。我不能坏了这个传统，但要大声说出那句日语又非常胆怯，直到放下筷子，不知在心里默念多少遍 ごちそうさま 了。幸好大声说出来时舌头并没有打结。</p>
<p>最后一天的早餐，我们又回到原点：吃中餐。暂且不提味道，中餐的食材用料是最贵的，每只烧卖里面都藏着结实的大虾呢。要说味道的话，清淡宜人，符合广东人的口味。</p>
<p>明治神宫是供奉明治天皇及皇后灵位的地方。去之前我就有个想法，东京还有没有新的地块兴建祭祀当代天皇的神宫呢？看高楼的密度似乎是没有，看皇室的地产却绰绰有余。</p>
<p>在明治神宫门前的原宿站下车，原宿站很小，当时没看出来——只是感觉很有特色——原来它是座有近百年历史的木造建筑，东京最悠久的木造车站。</p>
<p>据说在黄道吉日，日本人会在明治神宫举办神前婚礼，我想那天晚些时候神社会有婚礼，因为有神职人员在旁列队排练。</p>
<p>在神乐殿前许了个愿，希望——世界和平，开玩笑啦，其实是——归途一切顺利。玩乐的时光总是过得飞快，最后一天在日本了呢。</p>
<p>离开前在文化馆买了一枚印章，上刻单字“樱”。我深知很少有机会用到，但就是忍不住，来日本怎能放过带走这一既有武士精神又受国民喜爱的文化符号呢。</p>
<p>赶回酒店退房，傻傻的在柜台前排队，要不是有服务员过来问需要什么帮助，都不知道人家有旁边放一排自动办理 Check out 手续的机器呢。</p>
<p>在日暮里吃完午饭后乘京成特急到成田机场，搞不懂旅行社一去一回竟然安排两个不同的机场，成田机场离东京很远，坐特急也要70分钟。</p>
<p>车站站内有不少商店，在那里逛一圈花了五六千日元买了点织物、团子和万圣节饼干。刚好看到有饭团卖，就买了两个来吃，原先以为饭团的饭要不很结实，要不很僵硬，咬了一口之后，发觉饭粒虽已凉透，但外形保持完好，紧蹦着的表面锁住的大部分的水，比刚煮好的饭更有弹性；而米粒之间的距离出乎意料的松散，让人想不到入口之前它们抱成一团。</p>
<p>米饭太好吃，已经记不起里面馅料的味道了。</p>
<p>朋友记得成田特急的倒数第二站对应的航站楼是国际航站，所以我们在倒数第二站下车，结果翻遍电子显示屏也找不到我们要坐的那班飞机。一问服务台才知道，我们走错航站楼了，应该在最后一站下车的。</p>
<p>幸好有免费的接驳巴士到第一航站楼，时间也宽裕。在东京都是走路或坐地下铁，走前能坐一坐巴士，算是因祸得福吧。</p>
<p>成田机场可以自助打印登机牌，把行李箱贴好标签好，办理托运也很快。就是因为过程太顺利，忘记了旅行社之前千叮万嘱的要在办理托运手续时让工作人员在归国报告书上签字盖章。</p>
<p>朋友走过了免税店才想起买的免税物品在离境前好像要申报。至于在哪里申报、流程都不清楚。机场工作人员英语不好，完全无法交流，懂中文的免税店大妈让我们去找服务台，找到服务台时发现那里没人。最终找到一处里面站着人的小小咨询台，拿着护照比划了一阵之后，也不知道服务员懂不懂我们要干嘛，她只是把钉在塑料袋上的购物小票取下来，就对我们说都弄好了。看着桌面上一叠小票，我选择相信她，不管了。</p>
<p>一切琐碎手续都办好（自认为）后，坐在候机室打开电脑上网，旁边坐着好几个美国人民，他们应该是在东京转机回国的，好几个时差都没倒过来，昏昏欲睡；醒着的还未连上WIFI，就吐槽机场WIFI一定不好。我在一旁刷微博溜得飞起，真想告诉他们成田机场的WIFI不一样。</p>
<p>还有一个半小时才轮到我们飞，忽然感觉饿得手脚乏力。记得来时路上有家M记，朋友不饿，独自去买了个套餐回来。正当我俩慢条斯理吃着薯条时，一个小男孩扯着他爸爸的衣服闹了起来，看样子他也想吃。他爸爸没办法，走过来问薯条哪里买的，但又说不出话来，于是我主动用英语问他“你是韩国人吗？”，他回答是。于是就用英语给他指路。朋友后来偷偷说，他哪里是韩国人啊，听口音像是来自粤西的天朝人。两个天朝人竟然用英语交流，真是尴尬了，都怪他英语太差！</p>
<p>当把包放在飞机的架子上时，我才想起归国报告书那档子事。向空姐求助，她看上去也挺着急，拿起那报告书就走。我心里盘算着这事没戏，求助只是碰碰运气而已，不久空姐回来，说站楼已经关门，没法见到地面工作人员，而她没有印章，办理不了。我跟她说没关系，不要紧。对自己说，收拾收拾心情，回到中国再想办法吧。朋友从坐下来就在看电影，下了飞机跟我说，可惜刚出来的那部哥斯拉在飞机上没看完。他的心态比我好。</p>
<p>回到中国，在机场问了全日空的工作人员，她说忘记了归国报告书也不要紧的，向旅行社说明原因，用护照复印件也能销签。事后证明确实如此，幸好心情没被这事破坏，想起了最后许下的心愿，日本的神明还真是爱开玩笑呢。</p>
<img src="/2016/10/08/tokyo-go-round/sos.jpg" alt="带了这俩货回来" title="带了这俩货回来">]]></content>
    
    <summary type="html">
    
      东京见闻&amp;感想。6天的东京之旅，注定是走马观花，借用 merry-go-round ，给这游记取名为 Tokyo-go-round 多图！慎点！
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
      <category term="东京" scheme="http://judes.me/tags/%E4%B8%9C%E4%BA%AC/"/>
    
      <category term="旅游" scheme="http://judes.me/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>香港两日游</title>
    <link href="http://judes.me/2016/10/04/two-days-visiting-hongkong/"/>
    <id>http://judes.me/2016/10/04/two-days-visiting-hongkong/</id>
    <published>2016-10-04T09:22:52.000Z</published>
    <updated>2016-10-08T14:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在中秋时答应亲戚在他们去香港时会当兼职导游，想不到这么快——在去东京前两天——就得兑现承诺。</p>
<p>不凑巧的事情偶尔会赶一起：当码农搬砖又到了一个关键的时期；自己中秋回来就生病；同行的友人工作忙，没时间做东京旅游行程安排；亲戚说周末游香港，一切听我的安排……</p>
<p>一边担心病情加重，一边每晚默默计划行程到12点多才躺下还睡不着，早上6点半起来继续，就这样熬了过来。</p>
<p>香港之行与其说是玩了两日，操心的事实在太多，不如说是累了两日。</p>
<p>首先，提议去玩的人自己没有特别想去的地方和明确的计划（爬爬太平山/夜游维港/逛逛几条有香港特色的街，就几句）；人数还不少，老的少的一共7人，要照顾所有人，不好安排行程；更令人担心的是周末就去香港玩两天，周二还没订好香港那边的酒店，9月是到香港旅游的旺季耶，这么晚还不订酒店真的大丈夫？只好一而再，再而三地强调酒店的重要性，还找了好几家酒店以供选择。</p>
<p>在做行程计划直到出行那段时间里，最大的感想就是，有时候这导游就跟程序员一样，游客的需求就似客户的需求往往不明确，但交付期限已经定下，只能勉力而为。就这样还很可能不合人家心意，真是吃力不讨好的活。比程序员好一点的是，因为是一锤子买卖，导游可以做得更强势。</p>
<p>刚到香港，手机网络就出岔子，联通的上网不限流量漫游服务根本就不能用，陆陆续续打了6通电话，按指示做了无数操作，从地铁到酒店再到太平山脚，一路折腾，最终选择打电话取消服务。</p>
<p>跟联通反映服务出现问题，他们从来都是否认。上次网络劫持塞广告如此（说是阿里云的问题，但威胁要向工信部投诉之后，广告就神奇消失了），这次漫游服务也如此（同行的一个亲戚也开通此项服务，短信上说成功开通，同样是用不了，她还是联通员工呢）。这个客服策略真是令人讨厌又倍感无奈。</p>
<p>反思这次出行，最失策的是轻信了联通这项漫游服务，没事先下载香港离线地图和导航，以致亲戚们问这是哪里、该走条路时，我时常只能尴尬地回答“不知道，问人吧”。</p>
<p>不过天无绝人之路，爬完太平山发现香港政府在动植物公园提供免费 wifi 。想想几个大人挤在附近的厕所门外蹭政府 wifi 刷朋友圈，还蛮好笑的。如果这事被同行的小孩觉察，以后大人就没立场说小孩沉迷网络了吧，孩子们这时可是去看猴子了哦。</p>
<p>在亲戚预想中的行程里，“爬爬太平山”跟“夜游维港”还是挺容易安排的，只要补充上落地点、时间等等细节就准备妥当。唯独“逛逛几条有香港特色的街”这点真是很难安排，香港特色的街有不少，但它们都分散开来，老的少的能有体力走多少条呢？所以当时的想法是先记住那么几条（比如有一条叫石板街），然后在行程空隙中安排去逛逛。</p>
<p>最终事情的发展真是出乎意料。走下太平山又歇了半天，时间才下午3点不到，我们的行程安排竟然是如此的不饱满，以致都不知道怎样撑到夜游维港。只好先走到离山脚最近的————“有香港特色的街”————石板街。</p>
<p>我看着靠在厕所蹭 wifi 得来的地图，对怎样走到石板街很有信心，但亲戚们却偏要按向路人打听得来的路线走。一时说服不了他们，只好默默看着他们偏离目标有多远。到了他们也没办法的时候才拿出手机指着地图辨明方向，说声请相信我。</p>
<p>到达石板街，但街景却令人大为失望，街角有幢正在施工的建筑，行人连照相的欲望都提不起来。但我们已经达成“逛逛几条有香港特色的街”这个目标，一路上我们漫步在点缀着教会、教堂的平静街道，走下两旁是坐满外国人的热闹酒吧的半山阶梯，穿过狭窄而有点堵车的小道，沿着奢侈品店夹道的皇后大道向东走，走到终点只是拐了个弯儿。</p>
<p>走下石板街，逛遍金紫荆广场，这时吃饭问题又摆在眼前。同行的一位提议到附近很出名的店吃烤鸭，去到才发现排队等堂食的人有十几桌。那时一行人至少走 10 公里，孩子已经吵着回去很久，老人不说话脸色也很难看了。难得来一次香港，值得吃一顿好的，但除了这家也不知道附近还有哪家，再说了，谁能保证别家人不多呢？我真的不知道怎么办才好，幸好那位提议吃烤鸭的当机立断把堂食改为外带，让我们等着，然后自己去附近找茶餐厅。</p>
<p>那一餐我们在茶餐厅解决了。</p>
<p>茶餐厅一事感触很大。去旅行前应该先做好详细计划以应对各种情况，但同行之中有一个作风果断、敢想敢干的人也很重要。这样旅途既能有条不紊，又能遇事不乱。</p>
<p>类推到工作上，要先抓住重点（吃到特色烤鸭和不能再走），再适当违规、剑走偏锋（茶餐厅通常不能吃外带食品，但先点了菜，人家也不好意思赶走）。能不能排除万难，做到两全其美，有时候真的就看个人的决心和意志力。</p>
<p>当然，看官们也可以把面对这事表现出的束手无策解读为社会经验不足。</p>
<p>行程第二天实际只有半天时间，正好用来购物。</p>
<p>在坐巴士到通菜街时，遇到一个独身老人在车上大解。你没看错，就是在车上大便。当初以为是老年人失禁，但回想老人家面对众人鄙疑仍一脸淡定，下车前还特意用脚碾了碾地上那块X——就像把烟头丢地上，不忘踩灭——然后踩出一行脚印，我更愿意相信这是老人家的恶趣味。</p>
<p>香港社会的老龄化比内地严重。从深圳湾口岸过境，坐B3X巴士，快到屯门市中心时，可以看到路边一幢又一幢的敬老院。每次见到那些老旧建筑，心里总有一股凄凉的感觉。</p>
<p>购物完毕，特意找了家大饭店吃午饭。据本人总结，在外面吃饭，如果饭桌上有老人家，很可能得听上一翻他们对饭菜成本的斤斤计较，那一顿亦是如此。子女花钱痛快，让老人吃点平日吃不上的，却被说得像是当了冤大头似的，何苦呢。</p>
]]></content>
    
    <summary type="html">
    
      在去日本的前两日，被亲戚抓去香港客串导游了
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
      <category term="旅游" scheme="http://judes.me/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="香港" scheme="http://judes.me/tags/%E9%A6%99%E6%B8%AF/"/>
    
  </entry>
  
  <entry>
    <title>sinatra 0.3.0 源码学习</title>
    <link href="http://judes.me/2016/09/06/sinatra-learning-0-3-0/"/>
    <id>http://judes.me/2016/09/06/sinatra-learning-0-3-0/</id>
    <published>2016-09-06T13:11:15.000Z</published>
    <updated>2016-09-11T01:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>本文系 <strong>sinatra 源码系列</strong>第 5 篇。系列的目的是通过 sinatra 学习 ruby 编程技巧。文章按程序运行的先后顺序挑重点分析，前一篇文章分析过的略去不说。水平很有限，所写尽量给出可靠官方/讨论链接，不坑路人。</p>
<h2 id="重要提醒">重要提醒</h2><p><strong>一定要先安装 1.8 版本的 ruby</strong> ，因为 1.9+ 的 ruby ，String 的实例是不响应 each 方法的，这会直接导致 rack 报错。可以使用 <a href="https://rvm.io/" target="_blank" rel="external">rvm</a> 安装 1.8.7 版本的 ruby ，如果使用 rvm ，请先升级到最新版本，否则安装 1.8.7 的 ruby 时也会报错。</p>
<p>列一下本人运行 sinatra 0.3.0 用到的 ruby 和关键 gem 的版本：</p>
<ul>
<li>ruby-1.8.7-p374</li>
<li>rack 1.4.1</li>
<li>mongrel 1.1.5</li>
</ul>
<h2 id="本文主要内容">本文主要内容</h2><ul>
<li>routes splat</li>
<li>ResponseHelpers</li>
<li>middleware</li>
</ul>
<h2 id="routes_splat">routes splat</h2><p>上一篇文章说到 sinatra 没有保存路由中由通配符 * 捕获的参数，这个版本用一个数组保存下来，可以用 <code>params[&#39;splat&#39;]</code> 来访问。具体的实现代码：</p>
<pre><code>PARAM = /(:(#{URI_CHAR}+)|\*)/.freeze unless defined?(PARAM)
SPLAT = /(.*?)/
#...
splats = <span class="operator">0
regex = @<span class="keyword">path</span>.to_s.gsub(PARAM) <span class="keyword">do</span> |<span class="keyword">match</span>|
  # <span class="keyword">match</span> 匹配 /(:(#{URI_CHAR}+)|\*)/
  <span class="keyword">if</span> <span class="keyword">match</span> == <span class="string">"*"</span>
    @param_keys &lt;&lt; <span class="string">"_splat_#{splats}"</span>
    splats += <span class="number">1</span>
    SPLAT.to_s
  <span class="keyword">else</span>
    # 如 /(.)(.)(\<span class="keyword">d</span>(\<span class="keyword">d</span>))/.<span class="keyword">match</span>(<span class="string">"THX1138."</span>).captures =&gt; [<span class="string">"H"</span>, <span class="string">"X"</span>, <span class="string">"11"</span>, <span class="string">"1"</span>]
    # $<span class="number">1</span> 捕获 (:(#{URI_CHAR}+))
    # $<span class="number">2</span> 捕获 (#{URI_CHAR}+)
    @param_keys &lt;&lt; $<span class="number">2</span>
    <span class="string">"(#{URI_CHAR}+)"</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
#...
path_params = param_keys.zip($~.captures.<span class="keyword">map</span>{|s| unescape(s)}).to_hash
params.<span class="keyword">merge</span>!(path_params)
splats = params.select { |<span class="keyword">k</span>, v| <span class="keyword">k</span> =~ /^_splat_\<span class="keyword">d</span>+$/ }.<span class="keyword">sort</span>.<span class="keyword">map</span>(&amp;:<span class="keyword">last</span>)
unless splats.<span class="keyword">empty</span>?
  params.delete_if { |<span class="keyword">k</span>, v| <span class="keyword">k</span> =~ /^_splat_\<span class="keyword">d</span>+$/ }
  params[<span class="string">"splat"</span>] = splats
<span class="keyword">end</span></span>
</code></pre><h2 id="ResponseHelpers">ResponseHelpers</h2><p>这里定义的几个方法，可以在路由时使用，如 <code>redirect</code> ：</p>
<pre><code><span class="keyword">get</span> <span class="string">'/'</span> <span class="keyword">do</span>
  redirect <span class="string">'/home'</span>
end

<span class="keyword">get</span> <span class="string">'/home'</span> <span class="keyword">do</span>
  <span class="string">'welcome!'</span>
end
</code></pre><p><code>last_modified</code> 和 <code>entity_tag</code> 旨在节省网络流量（和节省计算资源,注释是这样说的），假如客户端请求的资源没有发生变化，就返回 304  Not Modified 。</p>
<p><code>last_modified</code> 大体的实现就是在定义路由时，把响应资源的最后修改时间通过响应头传到浏览器，浏览器再次访问时会在请求头带有上一次请求时得到的时间字段，这时再判断响应资源的最后修改时间与传过来的时间时否一致，如果一致则直接抛出异常，返回 304 。</p>
<p><code>entity_tag</code> 跟 <code>last_modified</code> 差不多，只不过比较的不是时间，而是更细粒度、更精确的标记。这个标记可以是用散列函数对资源求值得到哈希值，也可以是硬编码的版本号。</p>
<p>以上两个方法只设置响应头和比较请求头，把时间和标记交由用户管理，这不是很智能。 Rails 用户无需在意某个请求涉及到的一系列资源有没有更新，只要它们都没有更新，前端再次请求时就会得到 304 ，只要更新了一个资源（ partial 或者 layout ），再次请求就会得到最新的响应。</p>
<h2 id="middleware">middleware</h2><p>中间件的概念比较模糊，可以看<a href="http://stackoverflow.com/questions/2256569/what-is-rack-middleware" target="_blank" rel="external">这里</a>。简单来说，中间件可以帮你处理比如验证授权、缓存、打 log 等等的事情，这样你可以专心写业务逻辑。</p>
<p>如果你还是觉得困惑，强烈推荐你看这篇<a href="https://codenoble.com/blog/understanding-rack-middleware/" target="_blank" rel="external">文章</a>，它用简单明了的代码在实现中间件的层层调用时，还说清楚了中间件的原理。</p>
<p>上一个版本的 sinatra 就已经用到中间件：</p>
<pre><code><span class="keyword">def</span> build_application
  app = application
  app = <span class="string">Rack:</span>:<span class="string">Session:</span>:Cookie.<span class="keyword">new</span>(app) <span class="keyword">if</span> Sinatra.options.sessions == <span class="literal">true</span>
  app = <span class="string">Rack:</span>:CommonLogger.<span class="keyword">new</span>(app) <span class="keyword">if</span> Sinatra.options.logging == <span class="literal">true</span>
  app
end
</code></pre><p>上面的 <code>Rack::Session::Cookie</code> 和 <code>Rack::CommonLogger</code> 都是中间件。中间件有如下特征：</p>
<ul>
<li>能响应 <code>new</code> 方法， <code>new</code> 方法的参数是下一个中间件或者是应用；</li>
<li>能响应 <code>call</code> 方法，<code>call</code> 方法的参数是 <code>env</code> ，即 rack 的环境变量。</li>
</ul>
<p>这个版本的 sinatra 维护一个数组变量 <code>middleware</code> ：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">middleware</span></span>
  optional_middleware + explicit_middleware
<span class="keyword">end</span>
</code></pre><p><code>optional_middleware</code> 是由 sinatra 提供的可选的中间件，处于 <code>middleware</code> 的前面位置， <code>explicit_middleware</code> 是由用户自定义的中间件，用户每次调用 <code>use</code> 都会往这个数组的末尾插入新增的中间件。</p>
<p>每一个请求到来时，最终会调用： <code>pipeline.call(env)</code> ，<code>pipeline</code> 是把所有中间件以及业务处理器层层串连起来得到的新应用：</p>
<pre><code>def pipeline
  @pipeline ||=
    middleware.inject(<span class="function"><span class="keyword">method</span><span class="params">(:dispatch)</span>) <span class="title">do</span> |<span class="title">app</span>,<span class="params">(klass,args,<span class="keyword">block</span>)</span>|
      <span class="title">klass</span>.<span class="title">new</span><span class="params">(app, *args, &amp;<span class="keyword">block</span>)</span>
    <span class="title">end</span>
<span class="title">end</span></span>
</code></pre><p><code>@pipeline ||= ...</code> 的写法使调用 <code>use</code> 时重置 <code>pipeline</code> 变得很简单，只要写 <code>pipeline = nil</code> 就行。</p>
<p><code>inject</code> 跟 <code>reduce</code> 一样，根据给出的初始值，遍历处理数组的元素，记住每次处理的结果，并把它传到下一次处理中。</p>
<p><code>method(:dispatch)</code> 是业务处理器，请求经过一系列中间件最后会到达此处。它作为 <code>Method</code> 的实例对象，能响应 <code>call</code> 方法。</p>
<p>可以看到，请求最先被用户自定义的中间件处理，然后是 sinatra 提供的中间件，最后是业务处理器。处于 <code>middleware</code> 数组末尾的中间件最先起作用。</p>
]]></content>
    
    <summary type="html">
    
      通过 sinatra 学习 ruby 编程技巧（系列）
    
    </summary>
    
      <category term="ruby" scheme="http://judes.me/categories/ruby/"/>
    
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="sinatra" scheme="http://judes.me/tags/sinatra/"/>
    
  </entry>
  
  <entry>
    <title>sinatra 0.2.0 源码学习</title>
    <link href="http://judes.me/2016/08/16/sinatra-learning-0-2-0/"/>
    <id>http://judes.me/2016/08/16/sinatra-learning-0-2-0/</id>
    <published>2016-08-16T13:21:48.000Z</published>
    <updated>2016-09-08T00:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>本文系 <strong>sinatra 源码系列</strong>第 4 篇。系列的目的是通过 sinatra 学习 ruby 编程技巧。文章按程序运行的先后顺序挑重点分析，前一篇文章分析过的略去不说。水平很有限，所写尽量给出可靠官方/讨论链接，不坑路人。</p>
<h2 id="重要提醒">重要提醒</h2><p><strong>一定要先安装 1.8 版本的 ruby</strong> ，因为 1.9+ 的 ruby ，String 的实例是不响应 each 方法的，这会直接导致 rack 报错。可以使用 <a href="https://rvm.io/" target="_blank" rel="external">rvm</a> 安装 1.8.7 版本的 ruby ，如果使用 rvm ，请先升级到最新版本，否则安装 1.8.7 的 ruby 时也会报错。</p>
<p>使用命令 <code>git log -1 --format=%ai 0.2.0</code> ，查看 0.2.0 版本 sinatra 的“出厂日期”，得到 <code>2008-04-11 16:29:36 -0700</code> ；而 1.8.7 版本的 ruby 是 2008 年 5 月发布的，两者兼容性应该比较好。</p>
<p>列一下本人运行 sinatra 0.2.0 用到的 ruby 和关键 gem 的版本：</p>
<ul>
<li>ruby-1.8.7-p374</li>
<li>rack 1.4.1</li>
<li>mongrel 1.1.5</li>
</ul>
<h2 id="change_log">change log</h2><ul>
<li>大重构，把功能模块都压缩在一个文件中</li>
<li>增加大量测试用例</li>
</ul>
<h2 id="跑通所有测试用例">跑通所有测试用例</h2><p>首先修改一处代码错误，在 sinatra.rb 文件的 1022 行，将 <code>Rack::File::MIME_TYPES[ext.to_s] = type</code> 改为 <code>Rack::Mime::MIME_TYPES[ext.to_s] = type</code></p>
<p>然后安装一些缺少的 gem ：</p>
<pre><code>gem <span class="operator"><span class="keyword">install</span> builder -v <span class="string">'2.1.2'</span>
gem <span class="keyword">install</span> sass -v <span class="string">'3.1.0'</span>
gem <span class="keyword">install</span> haml -v <span class="string">'1.8.0'</span></span>
</code></pre><p>跑测试用例，发现只有 <code>sym_params_test.rb</code> 文件中的一处跑不通过。</p>
<p>此处的测试是验证可以用 String 和 Symbol 访问参数。实现的关键方法是：</p>
<pre><code># sinatra.rb 663 行
<span class="keyword">h</span> = Hash.new { |<span class="keyword">h</span>, k| <span class="keyword">h</span>[k.to_s] <span class="keyword">if</span> Symbol === k }
</code></pre><p>调用 <code>Hash.new</code> 时传进一个 block ，可以设置当访问某个不存在于 Hash 的 Key 时的一些默认行为，比如上面的代码就是说，当 key 不存在且是 Symbol 时，把 key 转换为字符串再找找（再抢救一下…）</p>
<p><code>Hash.new</code> 还可以用来初始化值为数组的键值对，在记录事件回调时很方便：</p>
<pre><code>@events = Hash.<span class="keyword">new</span> { |hash, key| hash[key] = [] }

<span class="preprocessor"># 出自这个版本的 sinatra.rb 的 738 行</span>
<span class="preprocessor"># 再也不用先判断 key 是否存在，也不用手动初始化一个空数组了</span>
</code></pre><p>回过头来修改代码以跑通测试用例，作者这里粗心写错了请求的方法，应该用 <code>post_it</code> ，而不是 <code>get_it</code> ，还要相应地修改路由：</p>
<pre><code>specify <span class="string">"should be accessable as Strings or Symbols"</span> <span class="keyword">do</span>
  post <span class="string">'/'</span> <span class="keyword">do</span>
    params[<span class="symbol">:foo</span>] + params[<span class="string">'foo'</span>]
  <span class="keyword">end</span>

  post_it <span class="string">'/'</span>, <span class="symbol">:foo</span> =&gt; <span class="string">"X"</span>
  assert_equal(<span class="string">'XX'</span>, body)
<span class="keyword">end</span>
</code></pre><p>要在这个版本的 sinatra 的 get 方法中传递参数，需要把参数写在 uri 中，下面的写法也能通过测试：</p>
<pre><code>specify <span class="string">"should be accessable as Strings or Symbols"</span> <span class="built_in">do</span>
  <span class="built_in">get</span> <span class="string">'/'</span> <span class="built_in">do</span>
    <span class="built_in">params</span>[:foo] + <span class="built_in">params</span>[<span class="string">'foo'</span>]
  <span class="function"><span class="keyword">end</span>

  <span class="title">get_it</span> '/?<span class="title">foo</span>=<span class="title">X</span>'</span>
  assert_equal(<span class="string">'XX'</span>, body)
<span class="keyword">end</span>
</code></pre><h2 id="从_at_exit_说起">从 at_exit 说起</h2><p>还是从 at_exit 开始读代码。</p>
<p><code>$!</code> 记录异常信息，当调用 <code>raise</code> 的时候会设置这个变量，详见<a href="http://ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/variable.html#dquote" target="_blank" rel="external">此处</a>。</p>
<p>调用 <code>load_options!</code> 解释完启动参数后， sinatra 在所有环境设置遇到异常和 404 时的回调方法，在开发环境遇到异常和 404 的回调方法比其他环境暴露更多的信息。</p>
<h3 id="OpenStruct">OpenStruct</h3><p>值得细看的是在非开发环境遇到异常时的回调方法：</p>
<pre><code><span class="keyword">error</span> <span class="keyword">do</span>
  raise request.env[<span class="comment">'sinatra.error'] if Sinatra.options.raise_errors</span>
  <span class="comment">'<span class="xmlDocTag">&lt;h1&gt;</span>Internal Server Error<span class="xmlDocTag">&lt;/h1&gt;</span>'</span>
<span class="keyword">end</span>
</code></pre><p><code>Sinatra.options</code> 实际上是 <code>OpenStruct</code> 的实例。 <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/ostruct/rdoc/OpenStruct.html" target="_blank" rel="external"><code>OpenStruct</code></a> 与 <code>Hash</code> 相似，但它通过元编程提供了不少快捷访问、设置值的方法。 <code>OpenStruct</code> 用法举例：</p>
<pre><code># 1
<span class="keyword">person</span> = OpenStruct.new
<span class="keyword">person</span>.name    = <span class="string">"John Smith"</span>
p <span class="keyword">person</span>.name    #=&gt; <span class="string">"John Smith"</span>

# 2
<span class="keyword">person</span> = OpenStruct.new(:name =&gt; <span class="string">"John Smith"</span>)
p <span class="keyword">person</span>.name    #=&gt; <span class="string">"John Smith"</span>
</code></pre><p>一个简单版本的 <code>OpenStruct</code> 实现：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">OpenStruct</span></span>
  <span class="keyword">attr_accessor</span> <span class="symbol">:h</span>
  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(hash = {})</span></span>
    <span class="variable">@h</span> = hash

    h.each <span class="keyword">do</span> |key, value|
      <span class="keyword">self</span>.<span class="keyword">class</span>.send(<span class="symbol">:define_method</span>, key) <span class="keyword">do</span>
        h[key]
      <span class="keyword">end</span>
      <span class="keyword">self</span>.<span class="keyword">class</span>.send(<span class="symbol">:define_method</span>, <span class="string">"<span class="subst">#{key}</span>="</span>) <span class="keyword">do</span> |value|
        h[key] = value
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">method_missing</span><span class="params">(m, *args)</span></span>
    <span class="keyword">if</span> args.size == <span class="number">1</span>
      <span class="comment"># m is  :name=</span>
      <span class="comment"># change m to :name</span>
      h[m.to_s.chop.to_sym] = args[<span class="number">0</span>]
    <span class="keyword">elsif</span> args.size == <span class="number">0</span>
      h[m]
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">respond_to?</span><span class="params">(m)</span></span>
    h.respond_to?(m) || <span class="keyword">super</span>
  <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">require</span> <span class="string">'test/unit'</span>

<span class="class"><span class="keyword">class</span> <span class="title">TestOS</span> <span class="inheritance">&lt; <span class="parent">Test::Unit</span></span>::<span class="title">TestCase</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>
    <span class="variable">@person_1</span> = <span class="constant">OpenStruct</span>.new
    <span class="variable">@person_2</span> = <span class="constant">OpenStruct</span>.new(<span class="symbol">:name</span> =&gt; <span class="string">'zhu'</span>)
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">test_case_1</span></span>
    assert_equal <span class="keyword">true</span>, <span class="variable">@person_1</span>.respond_to?(<span class="symbol">:name</span>)
    assert_equal <span class="keyword">nil</span>, <span class="variable">@person_1</span>.name
    <span class="variable">@person_1</span>.name = <span class="string">'zhu'</span>
    assert_equal <span class="string">'zhu'</span>, <span class="variable">@person_1</span>.name
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">test_case_2</span></span>
    assert_equal <span class="keyword">true</span>, <span class="variable">@person_2</span>.respond_to?(<span class="symbol">:name</span>)
    assert_equal <span class="string">'zhu'</span>, <span class="variable">@person_2</span>.name
    <span class="variable">@person_2</span>.name = <span class="string">'jude'</span>
    assert_equal <span class="string">'jude'</span>, <span class="variable">@person_2</span>.name
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>以上只是我心血来潮写的， <code>OpenStruct</code> 的实现远远不是上面写的那么简单，有兴趣可以看看源码。</p>
<p><code>Sinatra.options.raise_errors</code> 的值只能在代码里设置，当其值不为 nil 或 false 时，默认在非开发环境下直接抛出异常。要想在命令行启动时设置值，只需要在 <code>load_options!</code> 方法中添加一行：</p>
<pre><code>op.<span class="literal">on</span>(<span class="string">'-r'</span>) { |env| default_options[:raise_errors] = <span class="literal">true</span> }
</code></pre><p>在订制开发环境下的异常和 404 页面时，使用到 <code>%Q(...)</code> 。 ruby 会特殊处理以百分号 ‘%’ 开头的字符串，帮你省去不少转义引号的麻烦：</p>
<blockquote>
<p>The string expressions begin with % are the special form to avoid putting too many backslashes into quoted strings. <a href="http://ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html" target="_blank" rel="external">出处</a></p>
</blockquote>
<p>更多相似的用法见<a href="https://ruby-china.org/topics/18512" target="_blank" rel="external">Ruby 里的 %Q, %q, %W, %w, %x, %r, %s, %i</a>。</p>
<p>在显示异常信息时，用 <code>escap_html</code> 来转义 <code>&amp;</code>,<code>&lt;</code>,<code>&gt;</code>,<code>/</code>,<code>&#39;</code>,<code>&quot;</code> ，把这些 ascii 字符编码成实体编码，防止 XSS 攻击，不过源码有注释说有 bug ：</p>
<blockquote>
<p> On 1.8, there is a kcode = ‘u’ bug that allows for XSS otherwhise</p>
</blockquote>
<p>源码中用正则表达式替换转义字符的<a href="https://github.com/rack/rack/blob/1.4.1/lib/rack/utils.rb#L181" target="_blank" rel="external">实现</a>值得参考。</p>
<p>更多关于 XSS 的知识，可以看看本人之前写的<a href="http://judes.me/2015/10/02/xss-study/">这篇</a>。</p>
<h3 id="lookup">lookup</h3><p>接下来看 Application 的 call 方法。</p>
<p>首先由 <code>lookup</code> 方法实现根据请求找到正确的路由。</p>
<pre><code>def lookup(request)
  <span class="keyword">method</span> = request.request_method.downcase.to_sym
  events[<span class="keyword">method</span>].eject(&amp;[:invoke, request]) ||
    (events[:get].eject(&amp;[:invoke, request]) <span class="keyword">if</span> <span class="keyword">method</span> == :head) ||
    errors[<span class="type">NotFound</span>].invoke(request)
<span class="keyword">end</span>
</code></pre><p>sinatra 在 <code>Enumerable</code> 上扩展了 <code>eject</code> 方法，因为 <code>Array</code> 加载了 <code>Enumberable</code> 模块，所以 <code>Array</code> 实例能用 <code>eject</code> 方法。</p>
<pre><code>def eject(&amp;<span class="keyword">block</span>)
  find { |e| <span class="literal">result</span> = <span class="keyword">block</span>[e] <span class="keyword">and</span> <span class="keyword">break</span> <span class="literal">result</span> }
<span class="keyword">end</span>
</code></pre><p>在 <code>eject</code> 方法内部，使用 <code>find</code> 方法找到第一个产生非 false 结果的 block ，并返回这个结果。<code>find</code> 方法本来会返回第一个符合条件的元素，通过 <code>break</code> 可以订制自己的返回值。</p>
<p>这里 <code>e</code> 是 Event 的实例。 <code>block</code> 是由 Array 实例转化而来的 Proc 。</p>
<p>系列<a href="http://judes.me/2016/06/12/sinatra-learning-0-0-1/">第一篇文章</a>提到过， 如果跟在 <code>&amp;</code> 后面对象的不是 Proc ，首先会调用这个对象的 <code>to_proc</code> 方法得到一个 Proc 实例，最后会调用这个 Proc 的 <code>call</code> 方法。</p>
<p>sinatra 扩展了 Array 的 <code>to_proc</code> 方法：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">to_proc</span></span>
  <span class="constant">Proc.</span>new { |*args| args.shift.<span class="constant">__send__(</span><span class="keyword">self</span>[<span class="number">0</span>], *(args + <span class="keyword">self</span>[<span class="number">1</span>..-<span class="number">1</span>])) }
<span class="keyword">end</span>
</code></pre><p>经过 <code>to_proc</code> 转换， <code>Proc#call</code> 把参数转换为一个数组，把这个数组第一个元素作为 <code>receiver</code> ，把调用 <code>to_proc</code> 方法的数组的第一个元素作为方法，把两个数组余下的元素作为方法的参数，拿前面的代码作例子：</p>
<pre><code><span class="comment"># 在 lookup 方法里下面的这行代码</span>

&amp;[:invoke, request]

<span class="comment"># 会得到这样一个 Proc</span>

<span class="comment">#=&gt; Proc.new { |*args| args.shift.__send__(:invoke, *(args + [request])) }</span>

<span class="comment"># 在 eject 方法定义中</span>

find { |e| <span class="literal">result</span> = <span class="keyword">block</span>[e] <span class="keyword">and</span> <span class="keyword">break</span> <span class="literal">result</span> }

<span class="comment"># block[e] 就是把 e 当作参数调用  Proc#call ，做的事情是： 以 `request` 作为参数，调用 `e` 的 `invoke` 方法。</span>
</code></pre><p><code>block[e]</code> 不能写成 <code>block(e)</code> ，否则 ruby 会把 <code>block</code> 当作是 main 的一个方法来调用。有三种方法可以调用 <a href="https://ruby-doc.org/core-2.2.0/Proc.html#method-i-5B-5D" target="_blank" rel="external"><code>Proc#call</code></a> ：</p>
<pre><code><span class="preprocessor"># <span class="number">1</span></span>
 a_proc.call()
<span class="preprocessor"># <span class="number">2</span></span>
 a_proc.()
<span class="preprocessor"># <span class="number">3</span></span>
 a_proc[]
</code></pre><h3 id="invoke">invoke</h3><p><code>Event#invoke</code> 方法实现路由匹配和参数匹配。除了可以匹配路径，这个版本的 sinatra 还可以匹配 user_agent 和 host :</p>
<pre><code><span class="keyword">if</span> agent = options[<span class="symbol">:agent</span>] 
  <span class="keyword">return</span> <span class="keyword">unless</span> request.user_agent =~ agent
  params[<span class="symbol">:agent</span>] = <span class="variable">$~</span>[<span class="number">1</span>..-<span class="number">1</span>]
<span class="keyword">end</span>
<span class="keyword">if</span> host = options[<span class="symbol">:host</span>] 
  <span class="keyword">return</span> <span class="keyword">unless</span> host === request.host
<span class="keyword">end</span>
</code></pre><p>用法和测试举例如下：</p>
<pre><code>require <span class="string">'sinatra'</span>

<span class="keyword">get</span> <span class="string">'/path'</span>, :agent =&gt; /Windows/
  request.env[<span class="string">'HTTP_USER_AGENT'</span>]
end
<span class="preprocessor"># get_it '/', :env =&gt; { :agent =&gt; 'Windows' }</span>
<span class="preprocessor"># should.be.ok</span>
<span class="preprocessor"># body.should.equal 'Windows'</span>

<span class="preprocessor"># get_it '/', :agent =&gt; 'Mac'</span>
<span class="preprocessor"># should.not.be.ok</span>



<span class="keyword">get</span> <span class="string">'/path'</span>, {},<span class="constant"> HTTP_HOST </span>=&gt; <span class="string">'foo.test.com'</span>
  <span class="string">'in foo'</span>
end

<span class="keyword">get</span> <span class="string">'/path'</span>, {},<span class="constant"> HTTP_HOST </span>=&gt; <span class="string">'bar.test.com'</span>
  <span class="string">'in bar'</span>
end

<span class="preprocessor"># get_it '/foo', {}, 'HTTP_HOST' =&gt; 'foo.test.com'</span>
<span class="preprocessor"># assert ok?</span>
<span class="preprocessor"># assert_equal 'in foo', body</span>

<span class="preprocessor"># get_it '/foo', {}, 'HTTP_HOST' =&gt; 'bar.test.com'</span>
<span class="preprocessor"># assert ok?</span>
<span class="preprocessor"># assert_equal 'in bar', body</span>

<span class="preprocessor"># get_it '/foo'</span>
<span class="preprocessor"># assert not_found?</span>
</code></pre><p><code>request.user_agent</code> 最终调用 <code>env[&#39;HTTP_USER_AGENT&#39;]</code> ，在 /lib/sinatra/test/methods.rb 中， sinatra 重写了 <code>Rack::MockRequest#env_for</code> 方法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Rack::MockRequest</span></span>
  <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span><span class="inheritance">&lt; <span class="parent">self</span></span></span>
    <span class="keyword">alias</span> <span class="symbol">:env_for_without_env</span> <span class="symbol">:env_for</span>
    <span class="function"><span class="keyword">def</span> <span class="title">env_for</span><span class="params">(uri = <span class="string">""</span>, opts = {})</span></span>
      env = { <span class="string">'HTTP_USER_AGENT'</span> =&gt; opts.delete(<span class="symbol">:agent</span>) }
      env_for_without_env(uri, opts).merge(env)
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>这样在测试时就可以传递 <code>:agent =&gt; &#39;Windows&#39;</code> 作为 user_agent 的参数，否则要这样写： <code>&#39;HTTP_USER_AGENT&#39; =&gt; &#39;Windows&#39;</code> 。</p>
<h4 id="call_the_overridden_method_from_the_new">call the overridden method from the new</h4><p>在 ruby 中重写一个方法，新方法中还要调用未被重写前的旧方法，有几个技巧。</p>
<p>一，继承。需要修改每一处用到新方法的 reciever 。</p>
<pre><code>class Foo
  def <span class="keyword">say</span>
    'Hello'
  end
end

class Bar &lt; Foo
  def <span class="keyword">say</span>
    super + ' World!'
  end
end

Foo.new.<span class="keyword">say</span> #=&gt; 'Hello'
Bar.new.<span class="keyword">say</span> #=&gt; 'Hello World!'
# 把 reciever 从 Foo 改为 Bar
</code></pre><p>二，修改祖先链。这与继承类似，但修改的方向不一样。</p>
<pre><code>moudle Bar
  def <span class="keyword">say</span>
    super + ' World!'
  end
end

class Foo
  prepend Bar
  def <span class="keyword">say</span>
    'Hello'
  end
end

Foo.new.<span class="keyword">say</span> #=&gt; 'Hello World!'

# 使用了 prepend 把 Bar 放在 Foo 祖先链的下游，当寻找 <span class="keyword">say</span> 方法时，首先找到 Bar 定义的 <span class="keyword">say</span> 方法
</code></pre><p>三，使用 <a href="http://ruby-doc.org/core-1.9.3/UnboundMethod.html#method-i-bind" target="_blank" rel="external">UnboundMethod</a>  和 <code>define_method</code> 。</p>
<pre><code>class Foo
  def <span class="keyword">say</span>
    'Hello'
  end
end

# 在某处重新打开 Foo

class Foo
  old_say = instance_method(:<span class="keyword">say</span>)
  define_method(:<span class="keyword">say</span>) do
    old_say.bind(self)<span class="comment">[]</span> + ' World!'
    # 调用 instance_method 得到一个 UnboundMethod ，你需要在调用它之前 bind 一个 Foo 的实例
    # 前面说过调用 Proc#call 的三种方法，调用 Method#call 也是一样。这里采用了 <span class="comment">[]</span> ，你也可以用 .()
  end
end
</code></pre><p>四， alias 。就是 sinatra 采用的方法。</p>
<pre><code>class Foo
  def <span class="keyword">say</span>
    'Hello'
  end
end

# 在某处重新打开 Foo

class Foo
  alias :old_say :<span class="keyword">say</span>
  def <span class="keyword">say</span>
    old_say + ' World!'
  end
end

Foo.new.<span class="keyword">say</span> #=&gt; 'Hello World!'
Foo.new.old_say #=&gt; 'Hello'
# 使用这种技巧，仍然可以访问旧的方法
</code></pre><p>更多的技巧，可参考<a href="http://stackoverflow.com/questions/4470108/when-monkey-patching-a-method-can-you-call-the-overridden-method-from-the-new-i" target="_blank" rel="external">这里</a>。</p>
<p>继续看 <code>Event#invoke</code> 的实现，下面代码这行实现匹配路径：</p>
<pre><code>return unless pattern =~ request<span class="class">.path_info</span><span class="class">.squeeze</span>(<span class="string">'/'</span>)
</code></pre><p><code>String#squeeze</code> 方法用单个字符替换连续出现的字符，用法很灵活，参见<a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-squeeze" target="_blank" rel="external">文档</a>。</p>
<p>sinatra 实现路径匹配的参数匹配的思路是：</p>
<ul>
<li>将用户预先定义的路径转换为正则表达式</li>
<li>用这些正则表达式去匹配实际请求的路径</li>
<li>如果匹配成功，则把捕获的参数与定义的参数组成键值对保存起来</li>
</ul>
<p><code>Event#initialize</code> 实现了路径转换正则表达式：</p>
<pre><code><span class="constant">URI_CHAR</span> = <span class="string">'[^/?:,&amp;#\.]'</span>.freeze <span class="keyword">unless</span> <span class="keyword">defined</span>?(<span class="constant">URI_CHAR</span>)
<span class="constant">PARAM</span> = <span class="regexp">/:(<span class="subst">#{<span class="constant">URI_CHAR</span>}</span>+)/</span>.freeze <span class="keyword">unless</span> <span class="keyword">defined</span>?(<span class="constant">PARAM</span>)
<span class="constant">SPLAT</span> = <span class="regexp">/(.*?)/</span>
<span class="keyword">attr_reader</span> <span class="symbol">:pattern</span>

<span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(path, options = {}, &amp;b)</span></span>
  <span class="variable">@path</span> = <span class="constant">URI</span>.encode(path)
  <span class="variable">@param_keys</span> = []
  regex = <span class="variable">@path</span>.to_s.gsub(<span class="constant">PARAM</span>) <span class="keyword">do</span>
    <span class="variable">@param_keys</span> &lt;&lt; <span class="variable">$1</span>
    <span class="string">"(<span class="subst">#{<span class="constant">URI_CHAR</span>}</span>+)"</span>
  <span class="keyword">end</span>

  regex.gsub!(<span class="string">'*'</span>, <span class="constant">SPLAT</span>.to_s)

  <span class="variable">@pattern</span> = <span class="regexp">/^<span class="subst">#{regex}</span>$/</span>
<span class="keyword">end</span>
</code></pre><p>首先把用户定义的路径编码成 URI ，因为 <a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="external">rfc1738</a> 文档规定在 URL 中出现的字符只能是 字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’() 以及一些保留字符：</p>
<blockquote>
<p>only alphanumerics, the special characters “$-_.+!*’(),”, and reserved characters sed for their reserved purposes may be used unencoded within a URL.</p>
</blockquote>
<p>如果在路径或查询参数中出现其他字符，比如中文，需要先转义。</p>
<p>然后把用户在定义路径中的参数找出来，替换为去掉冒号（:）后的正则表达式字符串。</p>
<p><code>PARAM</code> 正则表达式———— <code>/:([^/?:,&amp;#\.]+)/</code>———— 匹配以冒号开头的，接下来的字符不是 <code>/ ? : , &amp; # .</code> 当中任意一个字符的字符串。</p>
<p><code>$1</code> 保存了最近一次正则表达式捕获的第一个匹配结果。</p>
<p>用户还可以定义不具名参数： ‘*’ ，这个功能还不完善，现阶段只能作占位符用，没法获取捕获的参数。</p>
<p>接下来的事情就是把捕获的参数与定义的参数组成键值对保存在 <code>params</code> 中，之前的系列文章有说过。</p>
<p>保存好参数后，调用 <code>Result.new(block, params, 200)</code> 生成 <code>Result</code> ，它是 <code>Struct</code> 的实例。跟 <code>OpenStruct</code> 不同， <code>Struct</code> 只能读、写在初始化时设定的 key ，不能新增 key ：</p>
<pre><code>Bar = Struct.<span class="function"><span class="title">new</span><span class="params">(a,b)</span></span>
bar = Bar.<span class="function"><span class="title">new</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>
bar<span class="class">.a</span> #=&gt; <span class="number">1</span>
bar<span class="class">.c</span> #=&gt; undefined method `c<span class="string">' for #&lt;struct Bar a=1, b=2&gt;</span>
</code></pre><p>sinatra 能正确响应 HEAD 请求方法。根据 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="external">rfc 文档</a>， HEAD 方法跟 GET 方法唯一的区别就是，响应 HEAD 方法时，响应报文不能带有 body 。响应报文的头应该跟 GET 方法的一致。 HEAD 方法主要用于验证资源的有效性、可用性以及最近是否修改过。</p>
<p>如上所述，如果是 HEAD 请求， sinatra 会自动去找对应的 GET 方法回调：</p>
<pre><code>(events[:get].eject(&amp;[:invoke, request]) <span class="keyword">if</span> <span class="function"><span class="keyword">method</span> == :</span>head)
</code></pre><p>在生成 HEAD 请求的响应时，会设置 body 为空字符：</p>
<pre><code><span class="preprocessor"># <span class="keyword">line</span> 839</span>
body = <span class="string">''</span> <span class="keyword">if</span> request.request_method.upcase == <span class="string">'HEAD'</span>
</code></pre><h3 id="to_result">to_result</h3><p>在获取响应的 body 时，不论是正常流程，还是异常流程，都调用了 <code>to_result</code> 方法。 sinatra 在很多类中都扩展了这个实例方法。</p>
<p>正常流程的代码如下：</p>
<pre><code>returned = run_safely <span class="operator"><span class="keyword">do</span>
  catch(:halt) <span class="keyword">do</span>
    filters[:<span class="keyword">before</span>].<span class="keyword">each</span> { |<span class="keyword">f</span>| <span class="keyword">context</span>.instance_eval(&amp;<span class="keyword">f</span>) }
    [:<span class="keyword">complete</span>, <span class="keyword">context</span>.instance_eval(&amp;<span class="keyword">result</span>.<span class="keyword">block</span>)]
  <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">body</span> = returned.to_result(<span class="keyword">context</span>)
# 一切正常时， returned 是 [:<span class="keyword">complete</span>, <span class="keyword">context</span>.instance_eval(&amp;<span class="keyword">result</span>.<span class="keyword">block</span>)]</span>
</code></pre><p>与此相关的两个 <code>to_result</code> 方法是：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">to_result</span><span class="params">(cx, *args)</span></span>
    <span class="keyword">self</span>.shift.to_result(cx, *<span class="keyword">self</span>)
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="class"><span class="keyword">class</span> <span class="title">Symbol</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">to_result</span><span class="params">(cx, *args)</span></span>
    cx.send(<span class="keyword">self</span>, *args)
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p><code>returned.to_result(context)</code> 最终是在 <code>context</code> 上调用 <code>complete</code> 方法，传入的参数是 <code>context.instance_eval(&amp;result.block)</code> 的返回值。</p>
<p>异常流程，如在 before filters 中抛出 <code>:halt</code> ，在 README.doc 文档中详细说明了多种情况：</p>
<blockquote>
<p>Set the body to the result of a helper method</p>
<p>throw :halt, :helper_method</p>
<p>Set the body to the result of a helper method after sending it parameters from the local scope</p>
<p>throw :halt, [:helper_method, foo, bar]</p>
<p>Set the body to a simple string</p>
<p>throw :halt, ‘this will be the body’</p>
<p>Set status then the body</p>
<p>throw :halt, [401, ‘go away!’]</p>
<p>Set the status then call a helper method with params from local scope</p>
<p>throw :halt, [401, [:helper_method, foo, bar]]</p>
<p>Run a proc inside the Sinatra::EventContext instance and set the body to the result</p>
<p>throw :halt, lambda { puts ‘In a proc!’; ‘I just wrote to $stdout!’ }</p>
</blockquote>
<p>在众多应对以上情况的 <code>to_proc</code> 中，值得一提的是以下这两个：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">String</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">to_result</span><span class="params">(cx, *args)</span></span>
    args.shift.to_result(cx, *args)
    <span class="keyword">self</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="class"><span class="keyword">class</span> <span class="title">NilClass</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">to_result</span><span class="params">(cx, *args)</span></span>
    <span class="string">''</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p><code>throw :halt, &#39;this will be the body&#39;</code> 之后，最终会用到 <code>String#to_result</code> 方法，传入的参数只有一个 <code>context</code> ，因此 <code>args</code> 是个空数组， <code>args.shift</code> 得到 <code>nil</code> ，所以得扩展 <code>NilClass#to_result</code> ，但它什么也没做，径直返回空字符串。</p>
<h3 id="context-body">context.body</h3><p>在处理返回报文的正文时，有如下代码：</p>
<pre><code><span class="keyword">context</span>.<span class="keyword">body</span> = <span class="keyword">body</span>.kind_of?(<span class="typename">String</span>) ? [*<span class="keyword">body</span>] : <span class="keyword">body</span>
</code></pre><p><code>kind_of?</code> 方法跟 <code>is_a?</code> 一样，回溯祖先链，找到祖先返回 true ，否则返回 false 。</p>
<p><code>[*body]</code> 中的 <code>*</code> （splat operator）有很多用途，之前也说过它可以把函数的多个参数变为一个数组。此处是另外两种用法。</p>
<p>其一是强制类型转换，把当前类型转换为 Array 类型：</p>
<pre><code><span class="preprocessor"># Range 转换为 Array</span>
a = *(<span class="number">1.</span><span class="number">.3</span>) <span class="preprocessor">#=&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>

<span class="preprocessor"># String 转换为 Array</span>
b = *<span class="string">"one string"</span> <span class="preprocessor">#=&gt; [<span class="string">"one string"</span>]</span>

<span class="preprocessor"># Array 仍然是 Array</span>
c = *[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="preprocessor">#=&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>

<span class="preprocessor"># nil 转换为 Array</span>
d = *nil <span class="preprocessor">#=&gt; []</span>
</code></pre><p>其二是展平数组：</p>
<pre><code>e = [*[<span class="number">1</span>,<span class="number">2</span>],*[<span class="number">3</span>,<span class="number">4</span>]] <span class="preprocessor">#=&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span>

<span class="preprocessor"># 这跟下面是一样的</span>

f = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]].flatten
</code></pre><p>回头看 <code>[*body]</code> ，如果只是把字符串强制转换为数组的话， <code>*body</code> 就够了。但是这里必须用中括号（<code>[]</code>）包着，否则会报语法错误。用中括号包住，解决了语法问题，得到的还是原来的那个数组。</p>
<p><code>*</code> 实际上并不是 operator ，而是 token ，而且很容易就会用错。大致有以下几种用法：</p>
<pre><code><span class="preprocessor"># 用于赋值</span>

first, *rest = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
<span class="preprocessor">#=&gt; first = <span class="number">1</span></span>
<span class="preprocessor">#=&gt; rest = [<span class="number">2</span>,<span class="number">3</span>]</span>

*rest, last = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
<span class="preprocessor">#=&gt; last = <span class="number">3</span></span>
<span class="preprocessor">#=&gt; rest = [<span class="number">1</span>,<span class="number">2</span>]</span>

first, *m, last = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]

<span class="preprocessor"># 收集参数，分解参数</span>

<span class="function">def <span class="title">foo</span><span class="params">(first, *args)</span></span>; end <span class="preprocessor">#=&gt; *args 只能放在最后</span>
foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="preprocessor">#=&gt; args = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span>

<span class="function">def <span class="title">bar</span><span class="params">(a, b)</span></span>; <span class="function">end
<span class="title">bar</span><span class="params">(*[<span class="number">1</span>,<span class="number">2</span>])</span> #</span>=&gt; a = <span class="number">1</span>, b = <span class="number">2</span>

<span class="preprocessor"># 强制类型转换，很容易出语法错误，所以最好用中括号包住</span>
</code></pre><p><code>context#body</code> 由在 Class 类中的 <code>dslify_writer</code> 方法实现：写入 body 的值，并返回这个值。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">dslify_writer</span><span class="params">(*syms)</span></span>
    syms.each <span class="keyword">do</span> |sym|
      class_eval &lt;&lt;-end_eval
        <span class="function"><span class="keyword">def</span> <span class="comment">#{sym}(v=nil)</span></span>
          <span class="keyword">self</span>.send <span class="string">"<span class="subst">#{sym}</span>="</span>, v <span class="keyword">if</span> v
          v
        <span class="keyword">end</span>
      end_eval
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>
  dslify_writer <span class="symbol">:bar</span>
  <span class="comment"># 相当于这样写：</span>
  <span class="comment"># def bar(v=nil)</span>
  <span class="comment">#   self.send('bar=', v) if v</span>
  <span class="comment">#   v</span>
  <span class="comment"># end</span>
<span class="keyword">end</span>
</code></pre><p><code>context</code> 并没有实现 <code>body=</code> 方法，但它有实现 <code>method_missing</code> 方法，把找不到的 method 转发给 <code>@response</code> ，而 <code>@response</code> 是 <code>Rack::Response</code> 的实例，可以读写 <code>body</code> 。</p>
<p>本小节参考文章：</p>
<ul>
<li><a href="http://blog.honeybadger.io/ruby-splat-array-manipulation-destructuring/" target="_blank" rel="external">Using splats to build up and tear apart arrays in Ruby</a></li>
<li><a href="http://jacopretorius.net/2012/01/splat-operator-in-ruby.html" target="_blank" rel="external">Splat Operator in Ruby</a></li>
<li><a href="https://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/" target="_blank" rel="external">The Strange Ruby Splat</a></li>
<li><a href="http://stackoverflow.com/questions/776462/where-is-it-legal-to-use-ruby-splat-operator" target="_blank" rel="external">Where is it legal to use ruby splat operator?</a></li>
</ul>
<h3 id="context-finish">context.finish</h3><p><code>context.finish</code> 也是转发到 <code>response.finish</code> ：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(&amp;block)</span></span>
  <span class="variable">@block</span> = block

  <span class="keyword">if</span> [<span class="number">204</span>, <span class="number">205</span>, <span class="number">304</span>].<span class="keyword">include</span>?(status.to_i)
    header.delete <span class="string">"Content-Type"</span>
    header.delete <span class="string">"Content-Length"</span>
    [status.to_i, header, []]
  <span class="keyword">else</span>
    [status.to_i, header, <span class="keyword">self</span>]
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>包含以下<a href="https://zh.wikipedia.org/wiki/HTTP状态码" target="_blank" rel="external">状态码</a>的响应会被删除响应头的 Content-Type / Content-Length 字段：</p>
<ul>
<li>204 No Content ，服务器成功处理了请求，但不需要返回任何实体内容，浏览器不产生任何文档视图上的变化</li>
<li>205 Reset Content ，服务器成功处理了请求，但不需要返回任何实体内容，浏览器要重置文档视图，比如重置表单</li>
<li>304 Use Proxy ，被请求的资源必须通过指定的代理——在 location 字段中指定——才能被访问</li>
</ul>
<p>并且返回数组中的第三个元素是个空数组，表明响应正文为空。</p>
<p>其他状态码返回数组中的第三个元素是 <code>self</code> ，能这样做的前提是 response 实现了 <code>each</code> 方法。</p>
<h3 id="设置_body">设置 body</h3><p>application_test.rb 里有一个测试用例如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">TesterWithEach</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">each</span></span>
    <span class="keyword">yield</span> <span class="string">'foo'</span>
    <span class="keyword">yield</span> <span class="string">'bar'</span>
    <span class="keyword">yield</span> <span class="string">'baz'</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

specify <span class="string">"an objects result from each if it has it"</span> <span class="keyword">do</span>

  get <span class="string">'/'</span> <span class="keyword">do</span>
    <span class="constant">TesterWithEach</span>.new
  <span class="keyword">end</span>

  get_it <span class="string">'/'</span>
  should.be.ok
  body.should.equal <span class="string">'foobarbaz'</span>

<span class="keyword">end</span>
</code></pre><p>如果没有在 get block 中设置 body 值， sinatra 就会用 block 的返回值作为 body ，如果这个返回值不响应 <code>each</code> 方法， body 就会被设置为空字符。可以模仿这里的 <code>TesterWithEach#each</code> 实现一个简单的 <code>each</code> ：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>
  <span class="keyword">attr_reader</span> <span class="symbol">:bar</span>

  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(*bar)</span></span>
    <span class="variable">@bar</span> = bar
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">each</span></span>
    <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">unless</span> block_given?
    i = <span class="number">0</span>
    <span class="keyword">while</span> i &lt; bar.length
      <span class="keyword">yield</span> bar[i]
      i += <span class="number">1</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment"># foo = Foo.new(1,2,3,4)</span>
<span class="comment"># foo.each { |i| p i  }</span>
</code></pre><p>目前为止， sinatra 的基本功能都已经实现，剩下的扩展功能——如重定向、渲染xml/erb/sass/haml、传输文件等等——都是通过加载模块来实现。</p>
<h2 id="Streaming">Streaming</h2><p>这一模块取自 ActionPack ，目的是用更少的内存消耗传输更大的文件，大体的做法是用流传输取代一次性输出整个文件。</p>
<p>实现 Streaming 的关键代码如下：</p>
<pre><code>class FileStreamer

  #...

  def to_result(cx, *args)
    self
  <span class="operator"><span class="keyword">end</span>

  <span class="keyword">def</span> <span class="keyword">each</span>
    <span class="keyword">File</span>.<span class="keyword">open</span>(<span class="keyword">path</span>, <span class="string">'rb'</span>) <span class="keyword">do</span> |<span class="keyword">file</span>|
      <span class="keyword">while</span> buf = <span class="keyword">file</span>.<span class="keyword">read</span>(options[:buffer_size])
        yield buf
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  #...

<span class="keyword">end</span>

#...

<span class="keyword">def</span> send_file(<span class="keyword">path</span>, options = {})

  #...

  <span class="keyword">if</span> options[:stream]
    throw :halt, [options[:<span class="keyword">status</span>] || <span class="number">200</span>, FileStreamer.<span class="keyword">new</span>(<span class="keyword">path</span>, options)]
  <span class="keyword">else</span>
    <span class="keyword">File</span>.<span class="keyword">open</span>(<span class="keyword">path</span>, <span class="string">'rb'</span>) { |<span class="keyword">file</span>| throw :halt, [options[:<span class="keyword">status</span>] || <span class="number">200</span>, <span class="keyword">file</span>.<span class="keyword">read</span>] }
  <span class="keyword">end</span>

<span class="keyword">end</span></span>
</code></pre><p>如果 <code>options[:stream]</code> 为 true 则通过自身的 <code>each</code> 方法每读入 4096 个字节就对外输出，否则一次性读入内存再输出。</p>
<h3 id="protected">protected</h3><p>Streaming 模块中有两个 protected 方法。 ruby 的 protected 跟 java 的很像，一般情况下被设置为 protected 的实例方法只能从类（或子类）实例方法中访问。（借助 <code>send</code> 方法可以突破这层限制）</p>
<pre><code>class <span class="keyword">Person</span>

  def initialize(age)
    @age = age
  end

  def older_than?(other_person)
    if self.class == other_person.class
      age &gt; other_person.age
    end
  end

  protected

  attr_reader :age

end

class Monkey

  def initialize(age)
    @age = age
  end

  def older_than?(<span class="keyword">person</span>)
    age &gt; <span class="keyword">person</span>.age
  end

  protected

  attr_reader :age
end

p1 = <span class="keyword">Person</span>.new(10)
p2 = <span class="keyword">Person</span>.new(11)
p1.older_than?(p2) #=&gt; false

# p1.age #=&gt; protected method `age' called for #&lt;<span class="keyword">Person</span>:0x007f80cc0263c8 @age=10&gt; (NoMethodError)

m1 = Monkey.new(13)

# m1.older_than?(p1) #=&gt; protected method `age' called for #&lt;<span class="keyword">Person</span>:0x007fd3e4963880 @age=10&gt; (NoMethodError)
</code></pre><p>ruby 的 protected 方法很少用到，如果要用的话，通常用于同类之间的比较（参见上面的 Person 类）。</p>
<p>本小节参考文章：</p>
<ul>
<li><a href="http://nithinbekal.com/posts/ruby-protected-methods/" target="_blank" rel="external">When to Use Protected Methods in Ruby</a></li>
<li><a href="https://tenderlovemaking.com/2012/09/07/protected-methods-and-ruby-2-0.html" target="_blank" rel="external">Protected Methods and Ruby 2.0</a></li>
<li><a href="http://devblog.orgsync.com/2013/05/20/private-and-protected-they-might-not-mean-what-you-think-they-mean/" target="_blank" rel="external">Private and Protected: They might not mean what you think they mean</a></li>
</ul>
<h2 id="RenderingHelpers">RenderingHelpers</h2><p>sinatra 渲染的过程大致可以分为两个步骤：</p>
<ul>
<li>根据传进来的参数 (String/Symbol/Proc) ，找到对应的模板</li>
<li>调用具体的渲染引擎渲染模板</li>
</ul>
<p>第一个步骤是共用的，抽出来形成 RenderingHelpers 。</p>
<p>RenderingHelpers 的实现体现了两个软件设计原则： 1. 依赖反转； 2. 开闭原则（对扩展开放，对修改闭合）。</p>
<p>举例说明一下本人所理解的依赖反转：把高层次的模块比作电器，把低层次的模块比作插座。要使两者配合起来为人所用，高层次的模块必须实现低层次模块指定的接口，这个接口就是特定的插头（或两脚或三脚）。</p>
<p>RenderingHelpers 对外提供 <code>render</code> 方法，但要使用 <code>render</code> 方法，必须实现 <code>render_renderer</code> 方法，这个 <code>render_renderer</code> 就是特定的插头。</p>
<p>这个版本的 sinatra 增加了多个渲染引擎的支持，这些引擎的实现细节各有不同（如 sass 不支持 layout），但增加这些引擎支持都不用修改 RenderingHelpers 里面的代码。你甚至可以加入自己的引擎，无需改动 RenderingHelpers ，只要它提供的 <code>render</code> 方法，并实现自己的 <code>render_renderer</code> 方法。这体现了开闭原则。</p>
<h3 id="use_in_file_templates!">use_in_file_templates!</h3><p>渲染时需要的模板，除了可以放在别的文件中，还可以放在当前文件中：</p>
<pre><code>get <span class="string">'/stylesheet.css'</span> <span class="keyword">do</span>
  header <span class="string">'Content-Type'</span> =&gt; <span class="string">'text/css; charset=utf-8'</span>
  sass <span class="symbol">:stylesheet</span>
<span class="keyword">end</span>

<span class="comment"># 这里需要的模板可以放在 "views/stylesheet.sass" 文件中，假设包含以下内容</span>

  <span class="comment">#  body</span>
  <span class="comment">#    #admin</span>
  <span class="comment">#      :background-color #CCC</span>

<span class="comment"># 也可以放在当前文件中，需要事先调用 use_in_file_templates! ，如下：</span>

use_in_file_templates！

<span class="constant">__END__</span>
<span class="comment">## stylesheet</span>
body
  <span class="comment">#admin</span>
    <span class="symbol">:background-color</span> <span class="comment">#CCC</span>
</code></pre><p><code>use_in_file_templates！</code>实现的细节是首先找到调用 <code>use_in_file_templates！</code> 方法的文件。 <code>caller</code> 方法会以数组形式返回当前方法的调用栈，形式如下：</p>
<pre><code>def a(skip)
  caller(skip)
<span class="operator"><span class="keyword">end</span>
<span class="keyword">def</span> b(<span class="keyword">skip</span>)
  a(<span class="keyword">skip</span>)
<span class="keyword">end</span>
<span class="keyword">def</span> <span class="keyword">c</span>(<span class="keyword">skip</span>)
  b(<span class="keyword">skip</span>)
<span class="keyword">end</span>
<span class="keyword">c</span>(<span class="number">0</span>)   #=&gt; [<span class="string">"prog:2:in `a'"</span>, <span class="string">"prog:5:in `b'"</span>, <span class="string">"prog:8:in `c'"</span>, <span class="string">"prog:10"</span>]
<span class="keyword">c</span>(<span class="number">1</span>)   #=&gt; [<span class="string">"prog:5:in `b'"</span>, <span class="string">"prog:8:in `c'"</span>, <span class="string">"prog:11"</span>]
<span class="keyword">c</span>(<span class="number">2</span>)   #=&gt; [<span class="string">"prog:8:in `c'"</span>, <span class="string">"prog:12"</span>]
<span class="keyword">c</span>(<span class="number">3</span>)   #=&gt; [<span class="string">"prog:13"</span>]</span>
</code></pre><p>然后把这个文件转换为字符串，定位到字符串的一个特殊标记。这里作者写错了这个特殊标记，应该是 <code>__END__</code> ，而不是 <code>__FILE__</code> 。虽然写成 <code>__FILE__</code> 也能跑过测试用例，但这个标记与 <code>__END__</code> 是完全不同的。</p>
<p>ruby 有一个特殊的常量 <a href="https://ruby-doc.org/core-2.3.1/Object.html" target="_blank" rel="external"><code>DATA</code></a> ，它是一个 <code>File</code> 对象，包含了文件中的数据。你可以把数据和代码放在同一个文件当中， ruby 通过 <code>__END__</code> 这个标记分开代码和数据：</p>
<pre><code><span class="preprocessor"># t.rb</span>
puts DATA.gets
__END__
hello world!

<span class="preprocessor"># ruby t.rb </span>
<span class="preprocessor"># =&gt; hello world!</span>
</code></pre><p>定位到数据部分后，把这部分字符串转换为 <a href="http://stackoverflow.com/questions/12592234/what-are-the-advantages-to-using-stringio-in-ruby-as-opposed-to-string" target="_blank" rel="external">StringIO</a> 对象，以便把字符串当作文件逐行解释。</p>
<p>只要匹配到以 <code>##</code> 开头的行，就把捕获的字符串当作新的模板名字，没匹配行的就当作是模板的内容。</p>
<p>全文完。</p>
]]></content>
    
    <summary type="html">
    
      通过 sinatra 学习 ruby 编程技巧（系列）
    
    </summary>
    
      <category term="ruby" scheme="http://judes.me/categories/ruby/"/>
    
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="sinatra" scheme="http://judes.me/tags/sinatra/"/>
    
  </entry>
  
  <entry>
    <title>sinatra 0.1.5 源码学习</title>
    <link href="http://judes.me/2016/08/13/sinatra-learning-0-1-5/"/>
    <id>http://judes.me/2016/08/13/sinatra-learning-0-1-5/</id>
    <published>2016-08-13T01:57:34.000Z</published>
    <updated>2016-08-16T13:57:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>本文系 <strong>sinatra 源码系列</strong>第 3 篇。系列的目的是通过 sinatra 学习 ruby 编程技巧。文章按程序运行的先后顺序挑重点分析，前一篇文章分析过的略去不说。水平很有限，所写尽量给出可靠官方/讨论链接，不坑路人。</p>
<h2 id="重要提醒">重要提醒</h2><p><strong>一定要先安装 1.8 版本的 ruby</strong> ，因为 1.9+ 的 ruby ，String 的实例是不响应 each 方法的，这会直接导致 rack 报错。可以使用 <a href="https://rvm.io/" target="_blank" rel="external">rvm</a> 安装 1.8.7 版本的 ruby ，如果使用 rvm ，请先升级到最新版本，否则安装 1.8.7 的 ruby 时也会报错。</p>
<p>列一下本人运行 sinatra 0.1.5 用到的 ruby 和关键 gem 的版本：</p>
<ul>
<li>ruby-1.8.7-p374</li>
<li>rack 1.4.1</li>
<li>mongrel 1.1.5</li>
</ul>
<h2 id="change_log">change log</h2><ul>
<li>增加 Mutex</li>
<li>支持处理请求前的事件回调</li>
</ul>
<p>这一版改动主要集中在 event.erb 文件里。</p>
<h2 id="event-erb">event.erb</h2><h3 id="Mutex_互斥锁">Mutex 互斥锁</h3><p>当多个线程读写公共资源时，要使用互斥锁保证每个线程在读或写时都是原子操作。</p>
<p>使用互斥锁首先要区分哪些是公共资源，哪些代码会访问这些公共资源，然后用互斥锁隔离这些代码。</p>
<p>sinatra 自身的代码不会既读又写公共资源（要么只读公共资源，要么每个线程使用自己的变量），因此可以在多线程中运行以同时处理多个请求，但是处理请求时执行的用户自定义的代码，有可能访问公共资源，这部分代码（处理请求的代码、处理请求之前和之后的事件回调）可能需要使用互斥锁。 sinatra 默认不使用互斥锁。</p>
<p>sinatra 是否运行在多线程环境中取决于 Rack handler （这一版本的 sinatra 使用的是  Mongrel ）是否支持多线程，并且以多线程的方式运行。详见<a href="http://stackoverflow.com/questions/6278817/is-sinatra-multi-threaded" target="_blank" rel="external">此处</a></p>
<p>接下来看 sinatra 互斥锁的实现。</p>
<p>用 <code>Event</code> 类变量 <code>@@mutex</code> 保存 <a href="http://ruby-doc.org/core-1.9.3/Mutex.html" target="_blank" rel="external">Mutex</a> 实例，之后调用 <code>@@mutex.synchronize do ... end</code> 实现同一时间只有一个线程的代码——这些代码要么是 <code>Event</code> 的类方法，要么是 <code>Event</code> 的实例方法——能访问公共资源。一旦用上了互斥锁，同一时间 sinatra 只能响应一个请求。</p>
<p><code>run_safely</code> 会先检查用户是否在运行程序时设置 <code>use_mutex</code> 为 <code>true</code> 。是则在 <code>synchronize</code> 中执行代码，否则直接执行代码。<code>use_mutex</code> 默认为 <code>false</code> 。</p>
<p>另外几篇参考文章：</p>
<ul>
<li><a href="http://www.tutorialspoint.com/ruby/ruby_multithreading.htm" target="_blank" rel="external">Ruby - Multithreading</a></li>
<li><a href="http://lucaguidi.com/2014/03/27/thread-safety-with-ruby.html" target="_blank" rel="external">Thread Safety With Ruby</a></li>
<li><a href="http://www.tutorialspoint.com/ruby/ruby_multithreading.htm" target="_blank" rel="external">Signals, Traps and Rescues</a></li>
</ul>
<h3 id="before_filters">before_filters</h3><p>用户可以使用 before_filters 来做授权、验证、参数过滤等等事情。</p>
<p>sinatra 把 before_filters 跟 after_filters 合二为一，分别写成 <code>setup_filter</code> 和 <code>call_filters</code> 。</p>
<p>得益于前面使用 cattr_accessor 设置了相应的 setter/getter ，  <code>setup_filter</code> 可以通过 <code>send(filter_set_name)</code> 来动态获取 filters 数组。</p>
<p>只要 before_filters 中没有抛出 <code>:halt</code> 异常的方法，请求就会按照正常的流程执行下去。如果抛出了 <code>:halt</code> 异常，处理请求的方法会被跳过，但 after_filters 仍然会被执行。</p>
<p>抛出 <code>:halt</code> 异常时可以带上参数，如果是 String 或 Symbol 类型的，就会被当作 helper 方法调用，如果是 Fixnum 类型则会被当成状态码。</p>
<p>这里用到 <a href="http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-case" target="_blank" rel="external">Object#case</a> 方法， <code>case</code> 判断一个值是否满足某个条件，用的是这个条件的 <code>===</code> 方法，传入这个值作为参数，举个例子：</p>
<pre><code>x = <span class="number">10</span>

<span class="keyword">case</span> x
<span class="keyword">when</span> <span class="number">10</span>
  p <span class="attribute">'x</span> <span class="keyword">is</span> <span class="number">10</span>'
<span class="keyword">end</span>

# 上面的代码与下面的代码是一样的

<span class="keyword">if</span> <span class="number">10</span> === x
  p <span class="attribute">'x</span> <span class="keyword">is</span> <span class="number">10</span>'
<span class="keyword">end</span>

# 因为 Fixnum 实现了自己的 === 方法，所以下面的用法也没有问题

<span class="keyword">case</span> x
<span class="keyword">when</span> Fixnum
  p <span class="attribute">'x</span> <span class="keyword">is</span> <span class="number">10</span>'
<span class="keyword">end</span>
</code></pre><p>全文完。</p>
]]></content>
    
    <summary type="html">
    
      通过 sinatra 学习 ruby 编程技巧（系列）
    
    </summary>
    
      <category term="ruby" scheme="http://judes.me/categories/ruby/"/>
    
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="sinatra" scheme="http://judes.me/tags/sinatra/"/>
    
  </entry>
  
  <entry>
    <title>试用 Action Cable</title>
    <link href="http://judes.me/2016/08/02/try-actioncable/"/>
    <id>http://judes.me/2016/08/02/try-actioncable/</id>
    <published>2016-08-02T12:54:33.000Z</published>
    <updated>2016-08-06T10:07:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Action_Cable_有什么用">Action Cable 有什么用</h2><p>Action Cable 是一项满足客户端与服务器端实时通讯需求的功能，它基于 WebSocket 协议。在此之前 web 端要满足类似的需求，有 轮询、长轮询、SSE（Server Sent Events ，sinatra 自带一个简单的实现，有兴趣可以看看） 等方法，综合考虑开销和兼容性，基于 WebSocket 的实现是最好的。</p>
<h2 id="WebSocket_的基本知识">WebSocket 的基本知识</h2><p>websocket 是建立在 TCP 协议上面应用层的协议，整个协议由两部分组成： 握手建立连接，数据传输。要建立 websocket 连接，得先由客户端发送一个 http get 请求，带上相关的请求头，只有当服务器端带上正确的响应头回复时，连接才能建立。之后客户端和服务器端可以向对方发送数据。</p>
<p>更详细的说明，可以看<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">这里</a></p>
<p>如果想简单地动手玩玩 websocket ，请参考<a href="https://www.rails365.net/articles/websocket-zhi-ke-hu-duan-yu-fu-wu-qi-duan-di-jiao-hu-er" target="_blank" rel="external">这篇文章</a></p>
<h2 id="Action_Cable_基础概念">Action Cable 基础概念</h2><p>用户打开的每个浏览器标签页都会跟服务器建立一条新连接(connection)，Rails 会为这条连接实例化一个 connection 对象，这个对象负责管理此后发生的订阅事件，它不处理具体的业务逻辑。</p>
<p>客户端可以通过一个连接订阅多个频道(channel)。每个频道都提供多个 websocket 的回调方法，方便写业务逻辑代码。</p>
<p>一个频道可以包含一个或多个流(stream)，如果把频道比作网络游戏平台中的某个分区，那么流就是分区下面的某个房间。流是 Action Cable 中发送、接收消息的最小单位。</p>
<p>服务器可以在建立连接时设置验证（用异步的方式），一旦验证失败，将关闭已建立的连接。</p>
<p>整个 Action Cable 的架构粗略看起来就是下面的样子：</p>
<pre><code><span class="title">connections</span>  &lt;==   channels  &lt;==   streams &lt;--&gt; subscriptions  ==&gt;   connections

&lt;== 表示 一 对 多 的关系

&lt;--&gt; 表示 一对一 的关系

==&gt; 表示 多对一 的关系
</code></pre><h2 id="Action_Cable_基本配置">Action Cable 基本配置</h2><p><strong>以下代码、说明仅在 Rails 5.0.0 版本（不是 beta 版本）测试过，不同版本间 Action Cable 的表现有稍许区别。</strong></p>
<p>既然 websocket 需要由客户端发起(握手请求)，先从前端需要做的事情说起。</p>
<p>运行 <code>rails new my_actioncable</code> 新建一个 Rails 项目。</p>
<p>在 <code>app/assets/javascripts/cable.js</code> ，Rails 已经替你准备好前端的 connection 实例：</p>
<pre><code>(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">this</span>.App || (<span class="keyword">this</span>.App = {});

  App.cable = ActionCable.createConsumer();

}).call(<span class="keyword">this</span>);
</code></pre><p>为方便调试，你可以添加一行启用调试的代码：</p>
<pre><code>(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">this</span>.App || (<span class="keyword">this</span>.App = {});

  App.cable = ActionCable.createConsumer();
  ActionCable.startDebugging(); <span class="comment">// 启用调试</span>

}).call(<span class="keyword">this</span>);
</code></pre><p>连接创建好之后，接着创建一个订阅。在 <code>assets/javascripts/channels</code> 目录下新建 <code>room.js</code> 文件，内容如下：</p>
<pre><code>App.room = App.cable.subscriptions.create(<span class="string">"RoomChannel"</span>, {
  connected: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="comment">// Called when the subscription is ready for use on the server</span>
    },
  disconnected: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="comment">// Called when the subscription has been terminated by the server</span>
  },

  received: <span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{
    <span class="comment">// Called when there's incoming data on the websocket for this channel</span>
  }
});
</code></pre><p>create 方法第一个参数可以是字符串，也可以是对象；如果是字符串，它表示要订阅的频道，如果是对象，则一定要带有 key 为 channel 的字段，其他字段可以传给后台别作它用（比如创建流），如：</p>
<pre><code>{
  <span class="attribute">channel</span>: <span class="string">'RoomChannel'</span>,
  <span class="attribute">label</span>: <span class="string">'1st'</span>
}
</code></pre><p>create 方法第二个参数包含一系列的回调方法，各自用途注释都写得很清楚。</p>
<p>前端的事情就做完了，开始设置后台。</p>
<p>Action Cable 可以独立于我们的应用运行，也可以作为<a href="http://guides.ruby-china.org/engines.html" target="_blank" rel="external">引擎</a>挂载到我们的应用中。这里我们选择挂载。</p>
<p>在 <code>routes.rb</code> 添加一行：</p>
<pre><code>mount ActionCable<span class="class">.server</span> =&gt; <span class="string">'/cable'</span>
</code></pre><p>这样发向 ‘/cable’ 的请求将由 Action Cable 处理。</p>
<p>在 <code>app/channels</code> 目录下新建 <code>room_channel.rb</code> ，内容如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">RoomChannel</span> <span class="inheritance">&lt; <span class="parent">ApplicationCable::Channel</span></span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">subscribed</span></span>
    stream_from <span class="string">'room_channel'</span>
  <span class="keyword">end</span>
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribed</span></span>
    <span class="comment"># Any cleanup needed when channel is unsubscribed</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p><code>steam_from</code> 新建一个流，如果前端在调用 App.cable.subscriptions.create 时第一个参数是对象，可以通过 <code>params</code> 来获取对象的内容：</p>
<pre><code><span class="comment"># 假设 第一个参数是对象</span>
<span class="comment"># {</span>
<span class="comment">#   channel: 'RoomChannel',</span>
<span class="comment">#   label: '1st'</span>
<span class="comment"># }</span>

<span class="function"><span class="keyword">def</span> <span class="title">subscribed</span></span>
  stream_from <span class="string">"room:<span class="subst">#{params[<span class="symbol">:label</span>]}</span>"</span>
<span class="keyword">end</span>
</code></pre><p>运行 <code>rails g controller room show</code> 生成控制器、路由和一个简单的 <code>show</code> 页面。</p>
<p>现在前后台都搭好了，得到一个最简单，什么都不能做的 Action Cable 。运行 <code>rails s</code> 启动服务器端，打开浏览器访问 <code>localhost:3000/room/show</code></p>
<p>在浏览器的控制台可以看到类似以下的信息：</p>
<pre><code>[ActionCable] Opening WebSocket, current state <span class="keyword">is</span> null, subprotocols: actioncable-v1-json,actioncable-unsupported <span class="number">1470455374056</span> action_cable.<span class="keyword">self</span>-<span class="number">1641</span>ec3….js?body=<span class="number">1</span>:<span class="number">50</span> 
[ActionCable] ConnectionMonitor started. pollInterval = <span class="number">3000</span> ms <span class="number">1470455374063</span> action_cable.<span class="keyword">self</span>-<span class="number">1641</span>ec3….js?body=<span class="number">1</span>:<span class="number">50</span> 
[ActionCable] WebSocket onopen <span class="keyword">event</span>, <span class="keyword">using</span> <span class="string">'actioncable-v1-json'</span> subprotocol <span class="number">1470455374081</span> action_cable.<span class="keyword">self</span>-<span class="number">1641</span>ec3….js?body=<span class="number">1</span>:<span class="number">50</span> 
[ActionCable] ConnectionMonitor recorded connect <span class="number">1470455374082</span>
</code></pre><p>切换到控制台的 Network 标签，查看 WebSockets ，可以看到浏览器每隔 3 秒会收到服务器端发过来的 ping 包。</p>
<h2 id="服务器主动向客户端推送消息">服务器主动向客户端推送消息</h2><p>服务器可以主动通过广播向客户端推送消息。</p>
<p>为免阻塞正常的 http 响应，通常会采用 delayed job 来向客户端推送消息。</p>
<p>运行命令 <code>rails g job send_msg</code> 新建一个 delayed job ，在新建的 <code>send_room_msg_job.rb</code> 中的 <code>perform</code> 方法中添加：</p>
<pre><code># 每 3 秒向客户端发送一条信息
1.upto(10) <span class="operator"><span class="keyword">do</span> |<span class="keyword">i</span>|
  <span class="keyword">sleep</span> <span class="number">3</span>
  ActionCable.<span class="keyword">server</span>.broadcast(
      <span class="string">'room_channel'</span>, # 这是流的名字，要跟在 stream_from 定义的保持一致
      title: <span class="string">'the title'</span>,
      <span class="keyword">body</span>: <span class="string">"server send #{i}"</span>
  )
<span class="keyword">end</span></span>
</code></pre><p>然后在 <code>RoomController#show</code> 方法中添加：</p>
<pre><code><span class="tag">SendRoomMsgJob</span><span class="class">.perform_later</span>
</code></pre><p>客户端接收部分，重写 <code>assets/javascripts/channels/room.js</code> 的 <code>received</code> 回调方法：</p>
<pre><code><span class="comment">//...</span>

received: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{
  <span class="keyword">var</span> msg = data[<span class="string">'title'</span>] + <span class="string">'\n'</span> + data[<span class="string">'body'</span>] + <span class="string">'\n'</span>;
  <span class="comment">//简单地打印接收到的信息</span>
  <span class="built_in">console</span>.log(msg);
}
</code></pre><p>重启服务器、重新访问 <code>localhost:3000/room/show</code> ，每隔 3 秒就能看到打印信息。</p>
<h2 id="客户端主动向服务器发送消息">客户端主动向服务器发送消息</h2><p>客户端也可以主动调用服务器端在 channel 中定义的方法。</p>
<p>重写 <code>assets/javascripts/channels/room.js</code> 的 <code>connected</code> 回调方法：</p>
<pre><code><span class="comment">//...</span>

<span class="tag">connected</span>: <span class="tag">function</span>(){
  <span class="tag">this</span><span class="class">.perform</span>(<span class="string">'print_log'</span>, { <span class="attribute">msg</span>: <span class="string">'send from client'</span> });
}
</code></pre><p>在 <code>room_channel.rb</code> 中添加一个 <code>print_log</code> 方法：</p>
<pre><code><span class="comment">#...</span>

<span class="function"><span class="keyword">def</span> <span class="title">print_log</span></span>(data)
  p <span class="string">"&gt;&gt;&gt;&gt; <span class="subst">#{data[<span class="string">'msg'</span>]}</span>"</span>
<span class="keyword">end</span>
</code></pre><p>只要连接一建立，就可以在服务器后台看到打印 <code>&gt;&gt;&gt;&gt; message from client</code></p>
<p>以上就是简单的 Action Cable 试用记录，源码已经上传至 <a href="https://github.com/yiyizym/try_action_cable" target="_blank" rel="external">github</a> 。</p>
<p>参考文章：</p>
<ul>
<li><a href="http://edgeguides.rubyonrails.org/action_cable_overview.html#broadcasting" target="_blank" rel="external">Action Cable Overview</a></li>
<li><a href="https://www.rails365.net/articles/websocket-xu-lie-wen-zhang-mu-lu" target="_blank" rel="external">websocket序列文章</a></li>
<li>Action Cable Source Code ，我翻了两天的源码。。。。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      Rails 5 出来很久了，学习一下 Action Cable
    
    </summary>
    
      <category term="ruby" scheme="http://judes.me/categories/ruby/"/>
    
    
      <category term="action cable" scheme="http://judes.me/tags/action-cable/"/>
    
      <category term="rails" scheme="http://judes.me/tags/rails/"/>
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="websocket" scheme="http://judes.me/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>写写堆排序</title>
    <link href="http://judes.me/2016/07/31/heap-sort/"/>
    <id>http://judes.me/2016/07/31/heap-sort/</id>
    <published>2016-07-31T06:16:09.000Z</published>
    <updated>2016-07-31T09:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理">原理</h2><p>堆排序中的“堆”，它是：</p>
<ul>
<li>一棵完全二叉树</li>
<li>树的每个节点都不比它的两个子节点小（有序）</li>
</ul>
<p>由此得到最有用的信息：根节点是二叉树里面最大的元素</p>
<p>堆排序的过程是：</p>
<ul>
<li>构造有序的堆</li>
<li>输出并删除最大的元素</li>
<li>重复前面两个步骤</li>
</ul>
<h2 id="联想">联想</h2><ul>
<li>用数组表示二叉树，数组从索引 1 开始记录元素。这样做可以很方便地找到完全二叉树中某个节点的及其两个子节点。</li>
<li>从下往上地把二叉树变成堆</li>
<li>交换最大的元素与二叉树的最后一个元素的位置，把二叉树的节点数减 1 ，再把二叉树变成堆</li>
<li>重复上一步骤，直到二叉树只剩下 1 个节点</li>
</ul>
<p>把二叉树变成堆涉及一个重要的基本操作：下沉。就是通过不断比较父节点与子节点，如果父节点比子节点小，就交换两者的位置。如果从根节点开始下沉，会得到整棵树中最大的节点。</p>
<pre><code>def sink(arr, <span class="keyword">index</span>, len)
  <span class="keyword">while</span> <span class="keyword">index</span> * <span class="number">2</span> &lt;= len
    child_index = <span class="keyword">index</span> * <span class="number">2</span> 
    <span class="keyword">if</span> child_index &lt; len &amp;&amp; arr[child_index] &lt; arr[child_index + <span class="number">1</span>]
      child_index += <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">break</span> <span class="keyword">nil</span> <span class="keyword">if</span> arr[child_index] &lt;= arr[<span class="keyword">index</span>]
    exchange(arr, <span class="keyword">index</span>, child_index)
    <span class="keyword">index</span> = child_index * <span class="number">2</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

def exchange(arr, i, j)
  arr[i], arr[j] = arr[j], arr[i]
<span class="keyword">end</span>
</code></pre><h2 id="用法">用法</h2><pre><code><span class="shebang">#!/usr/bin/env ruby</span>
sorted_array = HS.sort(array)
</code></pre><h2 id="大体架构">大体架构</h2><pre><code><span class="class"><span class="keyword">module</span> <span class="title">HS</span></span>
  extend <span class="keyword">self</span>
  <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(array)</span></span>
    heap_sort(array)
  <span class="keyword">end</span>
  private
  <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(array)</span></span>
    <span class="keyword">return</span> array <span class="keyword">if</span> array.length &lt; <span class="number">2</span>
    <span class="comment"># 构建符合格式的数组</span>
    <span class="comment"># 构建堆</span>
    <span class="comment"># 排序</span>

    array[<span class="number">1</span>..-<span class="number">1</span>]
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h2 id="构建符合格式的数组">构建符合格式的数组</h2><p>这个很简单，把数组第 1 个元素插入到数组末尾，然后把第 1 个元素置为 nil</p>
<pre><code><span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[<span class="built_in">array</span>.length] = nil, <span class="built_in">array</span>[<span class="number">0</span>]
</code></pre><h2 id="构建堆">构建堆</h2><p>把符合格式的数组看成是一棵完全二叉树，要构建堆的话，当然可以从数组的第 2 个元素开始下沉，一直到最后一个元素。</p>
<p>但这样的效率很低，单说最大可能交换的次数，假设 N 是树的高度，最大可能的交换次数一共是：</p>
<pre><code><span class="number">2</span>^<span class="number">0</span>*(N-<span class="number">1</span>)+<span class="number">2</span>^<span class="number">1</span>*(N-<span class="number">2</span>)+...+<span class="number">2</span>^(N-<span class="number">2</span>)*<span class="number">1</span>
</code></pre><p>参考黑帮发展的形式可以得到比较好的思路：不用管一众小黑帮的喽啰，只要收拾了它们的头目，就可以掌管这些黑帮。一开始就要找到小黑帮的头目，把他们打沉了，再往上找他们的头目。这样最大可能交换的次数一共是：</p>
<pre><code><span class="number">2</span>^<span class="number">0</span>+<span class="number">2</span>^<span class="number">1</span>+...+<span class="number">2</span>^(N-<span class="number">2</span>)
</code></pre><p>实现这个技巧的代码也很简单：</p>
<pre><code><span class="function">def <span class="title">make_heap</span><span class="params">(<span class="built_in">array</span>)</span>
  index </span>= (<span class="built_in">array</span>.length - <span class="number">1</span>) / <span class="number">2</span>
  <span class="keyword">while</span> index &gt;= <span class="number">1</span>
    sink(<span class="built_in">array</span>, index, <span class="built_in">array</span>.length - <span class="number">1</span>)
    index -= <span class="number">1</span>
  end
  <span class="built_in">array</span>
end
</code></pre><h2 id="排序">排序</h2><p>我们最终要得到一个从小到大的数组，得不断地把堆中最大的元素移到数组的末尾，缩小堆的大小之后，再使堆有序。</p>
<pre><code>def _sort(<span class="built_in">array</span>)
  <span class="built_in">len</span> = <span class="built_in">array</span>.length - <span class="number">1</span>
  <span class="keyword">while</span> <span class="built_in">len</span> &gt; <span class="number">1</span>
    exchange(<span class="built_in">array</span>, <span class="number">1</span>, <span class="built_in">len</span>)
    <span class="built_in">len</span> -= <span class="number">1</span>
    sink(<span class="built_in">array</span>, <span class="number">1</span>, <span class="built_in">len</span>)
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h2 id="完整的代码，加测试用例如下：">完整的代码，加测试用例如下：</h2><pre><code><span class="comment">#!/usr/bin/env ruby</span>

module HS
  extend self
  def<span class="function"> sort(</span>array<span class="function">)</span>
   <span class="function"> heap_sort(</span>array<span class="function">)</span>
  end
 <span class="keyword"> private</span>
  def<span class="function"> heap_sort(</span>array<span class="function">)</span>
   <span class="instruction"> return </span>array<span class="instruction"> if </span>array.length &lt; 2
    <span class="comment"># 构建符合格式的数组</span>
    array<span class="keyword">[</span>0], array<span class="keyword">[</span>array.length] = nil, array<span class="keyword">[</span>0]
    <span class="comment"># 构建堆</span>
   <span class="function"> make_heap(</span>array<span class="function">)</span>
    <span class="comment"># 排序</span>
   <span class="function"> _sort(</span>array<span class="function">)</span>

    array<span class="keyword">[</span>1..-1]
  end

  def<span class="function"> make_heap(</span>array<span class="function">)</span>
    index =<span class="function"> (</span>array.length - 1<span class="function">)</span> / 2
    while index &gt;= 1
     <span class="function"> sink(</span>array, index, array.length - 1<span class="function">)</span>
      index -= 1
    end
   <span class="instruction"> array
</span>  end

  def<span class="function"> _sort(</span>array<span class="function">)</span>
    len = array.length - 1
    while len &gt; 1
     <span class="function"> exchange(</span>array, 1, len<span class="function">)</span>
      len -= 1
     <span class="function"> sink(</span>array, 1, len<span class="function">)</span>
    end
  end

  def<span class="function"> sink(</span>arr, index, len<span class="function">)</span>
    while index * 2 &lt;= len
      child_index = index * 2
     <span class="instruction"> if </span>child_index &lt; len &amp;&amp; arr<span class="keyword">[</span>child_index] &lt; arr<span class="keyword">[</span>child_index + 1]
        child_index += 1
      end
      break nil<span class="instruction"> if </span>arr<span class="keyword">[</span>child_index] &lt;= arr<span class="keyword">[</span>index]
     <span class="function"> exchange(</span>arr, index, child_index<span class="function">)</span>
      index = child_index
    end
  end

  def<span class="function"> exchange(</span>arr, i, j<span class="function">)</span>
    arr<span class="keyword">[</span>i], arr<span class="keyword">[</span>j] = arr<span class="keyword">[</span>j], arr<span class="keyword">[</span>i]
  end

end
<span class="instruction">
if </span>__FILE__ == $0
  require 'test/unit'
  class TestHS &lt; Test::Unit::TestCase
    def test_0
      input = <span class="keyword">[</span>]
      expected = <span class="keyword">[</span>]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'empty<span class="instruction"> array </span>not equal'
    end
    def test_1_0
      input = <span class="keyword">[</span>0]
      expected = <span class="keyword">[</span>0]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'
    end
    def test_1_1
      input = <span class="keyword">[</span>1]
      expected = <span class="keyword">[</span>1]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'
    end
    def test_2_0
      input = <span class="keyword">[</span>0,1]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'two iteHS<span class="instruction"> array </span>not equal'
    end
    def test_2_1
      input = <span class="keyword">[</span>1,0]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'two iteHS<span class="instruction"> array </span>not equal'
    end
    def test_2_2
      input = <span class="keyword">[</span>1,1]
      expected = <span class="keyword">[</span>1,1]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'two iteHS<span class="instruction"> array </span>not equal'
    end
    def test_3_0
      input = <span class="keyword">[</span>0,1,2]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'three iteHS<span class="instruction"> array </span>not equal'
    end
    def test_3_1
      input = <span class="keyword">[</span>0,2,1]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'three iteHS<span class="instruction"> array </span>not equal'
    end
    def test_3_2
      input = <span class="keyword">[</span>2,1,0]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'three iteHS<span class="instruction"> array </span>not equal'
    end
    def test_3_3
      input = <span class="keyword">[</span>2,1,1]
      expected = <span class="keyword">[</span>1,1,2]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'three iteHS<span class="instruction"> array </span>not equal'
    end
    def test_3_4
      input = <span class="keyword">[</span>1,1,1]
      expected = <span class="keyword">[</span>1,1,1]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'three iteHS<span class="instruction"> array </span>not equal'
    end
    def test_4_0
      input = <span class="keyword">[</span>0,1,2,3]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'four iteHS<span class="instruction"> array </span>not equal'
    end
    def test_4_1
      input = <span class="keyword">[</span>3,1,2,0]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'four iteHS<span class="instruction"> array </span>not equal'
    end
    def test_4_2
      input = <span class="keyword">[</span>3,1,2,1]
      expected = <span class="keyword">[</span>1,1,2,3]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'four iteHS<span class="instruction"> array </span>not equal'
    end
    def test_10_0
      input = <span class="keyword">[</span>9,8,7,6,5,4,3,2,1,0]
      expected = <span class="keyword">[</span>0,1,2,3,4,5,6,7,8,9]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'ten iteHS<span class="instruction"> array </span>not equal'
    end
    def test_10_1
      input = <span class="keyword">[</span>9,5,7,3,8,4,6,1,2,0]
      expected = <span class="keyword">[</span>0,1,2,3,4,5,6,7,8,9]
      assert_equal<span class="function"> HS.sort(</span>input<span class="function">)</span>, expected, 'ten iteHS<span class="instruction"> array </span>not equal'
    end
  end
end
</code></pre>]]></content>
    
    <summary type="html">
    
      为什么知道原理还是写不出正确的程序呢？(系列)
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
      <category term="algorithm" scheme="http://judes.me/tags/algorithm/"/>
    
      <category term="heap sort" scheme="http://judes.me/tags/heap-sort/"/>
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>写写归并排序</title>
    <link href="http://judes.me/2016/07/29/try-merge-sort/"/>
    <id>http://judes.me/2016/07/29/try-merge-sort/</id>
    <published>2016-07-28T23:38:54.000Z</published>
    <updated>2016-07-29T14:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理">原理</h2><ul>
<li>将待排序元素分为前后两部分，分别调用归并排序使它们有序</li>
<li>从头开始逐个比较前后两部分的元素，根据比较结果先后放进新数组，最终返回这个新数组</li>
</ul>
<h2 id="联想">联想</h2><ul>
<li>归并排序用到了递归，递归终止的条件是待排序元素数量小于 2</li>
<li>归并排序比较之后不会交换元素，而是生成新的数组</li>
</ul>
<h2 id="用法">用法</h2><pre><code><span class="shebang">#!/usr/bin/env ruby</span>
sorted_array = MS.sort(array)
</code></pre><h2 id="大体结构">大体结构</h2><pre><code><span class="class"><span class="keyword">module</span> <span class="title">MS</span></span>
  extend <span class="keyword">self</span>
  <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(arr)</span></span>
    merge_sort(arr.dup)
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr)</span></span>
    <span class="keyword">return</span> arr <span class="keyword">if</span> arr.length &lt; <span class="number">2</span>
    <span class="comment">#将 arr 一分为二，分别调用归并排序</span>
    <span class="comment">#逐一比较这两部分的元素，根据比较结果生成新数组</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h2 id="将待排序元素一分为二，分别调用归并排序">将待排序元素一分为二，分别调用归并排序</h2><pre><code><span class="function">def <span class="title">merge_sort</span><span class="params">(arr)</span>
  #...

  m_index </span>= arr.length / <span class="number">2</span>
  <span class="preprocessor">#这两部分的命名真是头痛，原谅我英语不好</span>
  low_part = merge_sort(arr[<span class="number">0.</span>..m_index]) <span class="preprocessor"># low_part 不包含位于 m_index 的元素</span>
  high_part = merge_sort(arr[m_index..-<span class="number">1</span>])

  <span class="preprocessor">#...</span>
end
</code></pre><h2 id="逐一比较这两部分的元素，根据比较结果生成新数组">逐一比较这两部分的元素，根据比较结果生成新数组</h2><pre><code><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr)</span></span>
  <span class="comment">#...</span>

  l_index = <span class="number">0</span>
  h_index = <span class="number">0</span>
  new_arr = []

  <span class="keyword">while</span> low_part[l_index] &amp;&amp; high_part[h_index]
    <span class="keyword">if</span> low_part[l_index] &lt; high_part[h_index]
      new_arr &lt;&lt; low_part[l_index]
      l_index += <span class="number">1</span>
    <span class="keyword">else</span>
      new_arr &lt;&lt; high_part[h_index]
      h_index += <span class="number">1</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="comment">#如果第一部分还有未比较的元素，就放进新数组</span>
  <span class="keyword">while</span> low_part[l_index]
    new_arr &lt;&lt; low_part[l_index]
    l_index += <span class="number">1</span>
  <span class="keyword">end</span>

  <span class="comment">#同上</span>
  <span class="keyword">while</span> high_part[h_index]
    new_arr &lt;&lt; high_part[h_index]
    h_index += <span class="number">1</span>
  <span class="keyword">end</span>

  new_arr

<span class="keyword">end</span>
</code></pre><h2 id="完整的代码，加测试用例如下：">完整的代码，加测试用例如下：</h2><pre><code><span class="comment">#!usr/bin/env ruby</span>

module MS
 extend self
 def<span class="function"> sort(</span>arr<span class="function">)</span>
  <span class="function"> merge_sort(</span>arr.dup<span class="function">)</span> 
   end
 def<span class="function"> merge_sort(</span>arr<span class="function">)</span>
  <span class="instruction"> return </span>arr<span class="instruction"> if </span>arr.length &lt; 2
   m_index = arr.length / 2
   low_part =<span class="function"> merge_sort(</span>arr<span class="keyword">[</span>0...m_index]<span class="function">)</span>
   high_part =<span class="function"> merge_sort(</span>arr<span class="keyword">[</span>m_index..-1]<span class="function">)</span>

   l_index = 0
   h_index = 0
   new_arr = <span class="keyword">[</span>]

   while low_part<span class="keyword">[</span>l_index] &amp;&amp; high_part<span class="keyword">[</span>h_index]
    <span class="instruction"> if </span>low_part<span class="keyword">[</span>l_index] &lt; high_part<span class="keyword">[</span>h_index]
       new_arr &lt;&lt; low_part<span class="keyword">[</span>l_index]
       l_index += 1
     else
       new_arr &lt;&lt; high_part<span class="keyword">[</span>h_index]
       h_index += 1
     end
   end

   <span class="comment">#如果第一部分还有未比较的元素，就放进新数组</span>
   while low_part<span class="keyword">[</span>l_index]
     new_arr &lt;&lt; low_part<span class="keyword">[</span>l_index]
     l_index += 1
   end

   <span class="comment">#同上</span>
   while high_part<span class="keyword">[</span>h_index]
     new_arr &lt;&lt; high_part<span class="keyword">[</span>h_index]
     h_index += 1
   end

   new_arr

  end
end
<span class="instruction">
if </span>__FILE__ == $0
  require 'test/unit'
  class TestMS &lt; Test::Unit::TestCase
    def test_0
      input = <span class="keyword">[</span>]
      expected = <span class="keyword">[</span>]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'empty<span class="instruction"> array </span>not equal'
    end
    def test_1_0
      input = <span class="keyword">[</span>0]
      expected = <span class="keyword">[</span>0]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'    
    end
    def test_1_1
      input = <span class="keyword">[</span>1]
      expected = <span class="keyword">[</span>1]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'    
    end
    def test_2_0
      input = <span class="keyword">[</span>0,1]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_2_1
      input = <span class="keyword">[</span>1,0]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_2_2
      input = <span class="keyword">[</span>1,1]
      expected = <span class="keyword">[</span>1,1]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_3_0
      input = <span class="keyword">[</span>0,1,2]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_1
      input = <span class="keyword">[</span>0,2,1]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_2
      input = <span class="keyword">[</span>2,1,0]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_3
      input = <span class="keyword">[</span>2,1,1]
      expected = <span class="keyword">[</span>1,1,2]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_4
      input = <span class="keyword">[</span>1,1,1]
      expected = <span class="keyword">[</span>1,1,1]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_4_0
      input = <span class="keyword">[</span>0,1,2,3]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_4_1
      input = <span class="keyword">[</span>3,1,2,0]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_4_2
      input = <span class="keyword">[</span>3,1,2,1]
      expected = <span class="keyword">[</span>1,1,2,3]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_10_0
      input = <span class="keyword">[</span>9,8,7,6,5,4,3,2,1,0]
      expected = <span class="keyword">[</span>0,1,2,3,4,5,6,7,8,9]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'ten items<span class="instruction"> array </span>not equal'    
    end
    def test_10_1
      input = <span class="keyword">[</span>9,5,7,3,8,4,6,1,2,0]
      expected = <span class="keyword">[</span>0,1,2,3,4,5,6,7,8,9]
      assert_equal<span class="function"> MS.sort(</span>input<span class="function">)</span>, expected, 'ten items<span class="instruction"> array </span>not equal'    
    end
  end
end
</code></pre><p>PS. 想要跑某个特定的测试，可以这样写： <code>ruby test.rb -n test_method_name</code></p>
]]></content>
    
    <summary type="html">
    
      为什么知道原理还是写不出正确的程序呢？(系列)
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
      <category term="algorithm" scheme="http://judes.me/tags/algorithm/"/>
    
      <category term="merge sort" scheme="http://judes.me/tags/merge-sort/"/>
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>一个因挪动 wechat_api 引发的问题，以及问题探究</title>
    <link href="http://judes.me/2016/07/27/wechat-gem-wechat-api/"/>
    <id>http://judes.me/2016/07/27/wechat-gem-wechat-api/</id>
    <published>2016-07-26T23:36:56.000Z</published>
    <updated>2016-07-28T12:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司的微信企业号用了 <a href="https://github.com/Eric-Guo/wechat" target="_blank" rel="external">wechat</a> 这个 gem 包。如果要在各个 controller 中调用 gem 包提供的 api ，就先得在 controller 里调用 <code>wechat_api</code> 。如果要使用微信的 JS-SDK ，也得在 controller 里面调用 <code>wechat_api</code> 。</p>
<p>近日新增一个 controller ，没有用到 wechat 提供的 api ，所以就没调用 <code>wechat_api</code> ，也因为功能简单没有写测试（事后看来不写测试要打屁屁）；在另一次不相干的改动中，我们把微信 JS-SDK 的配置代码移动到 layout 文件中，跑过了所有测试、手动测试了关键功能没发现问题就上线了；几天后才发觉新增的那个 controller 有严重问题，原因是在 layout 中使用微信的 JS-SDK ，而在 controller 中没有调用 <code>wechat_api</code> 。</p>
<p>反思得到的结论，最重要的一个是：新增 controller 没写测试用例，其二是： 新增 controller 没调用 <code>wechat_api</code> 。</p>
<p>测试用例是一定要补上的。</p>
<p>问题是要加上 <code>wechat_api</code> 的调用。今后每增加一个 controller 都要写一遍，这很人肉啊！于是我尝试把这个调用挪动到所有 controller 的共同超类： ApplicationController 中，结果又引发了新问题。</p>
<p>日志显示错误出现在配置 JS-SDK 时， wechat_config_js 这个方法内 controller.wechat 返回 nil 。</p>
<p>首先要看看 wechat_api 究竟做了什么，很快找到它在 wechat_responder.rb 中定义。</p>
<p>它首先 <code>include Wechat::ControllerApi</code> ，这个模块里定义了 <code>wechat</code> 实例方法，而它又调用 <code>self.class.wechat</code> ，里面的注释标明这样做是为了在实例中调用类方法。 而这个类方法实际是个 <code>attr_accessor</code> 。</p>
<p>然后是： <code>self.wechat = load_controller_wechat(opts)</code></p>
<p>先不管 <code>load_controller_wechat</code> 到底做了什么，总之最终就是把它返回的结果赋值给 <code>self.wechat</code> ，就是把这个值保存在类单例变量(wechat)当中。</p>
<p>至此，出错的原因算是找到了：如果在 ApplicationController 中调用 <code>wechat_api</code> ，当在具体的某个 view 里调用 <code>controller.wechat</code> 时，会返回 <code>nil</code> ，因为这个值是保存在 ApplicationController 的类单例里面。</p>
<p>这样设计能做到对不同的 controller 应用不同的配置（<a href="https://github.com/Eric-Guo/wechat#configure-individual-responder-with-different-appid" target="_blank" rel="external">见此</a>）。</p>
<p>要解决这个新问题，比较稳妥的办法就是在各个具体的 controller 中调用 <code>wechat_api</code> 。还有一种办法就是重写 <code>Wechat::ControllerApi</code> 中的 <code>wechat</code> 实例方法，如果类方法 <code>wechat</code> 返回 <code>nil</code> ，就调用它的超类的 <code>wechat</code> 方法：</p>
<pre><code>def wechat
  <span class="keyword">self</span>.<span class="keyword">class</span>.wechat || <span class="keyword">self</span>.<span class="keyword">class</span>.superclass.wechat
  # Make sure user can <span class="keyword">continue</span> access wechat at instance level similar <span class="keyword">to</span> <span class="keyword">class</span> level
<span class="keyword">end</span>
</code></pre><p>测试用都跑过了，就是不知道会不会引发新的 bug 。</p>
]]></content>
    
    <summary type="html">
    
      本想着减少重复代码，把 wechat_api 从各个具体的 controller 挪动到 ApplicationController ，结果出错啦。为了找出原因，我又踏上了阅读源码的不归路。
    
    </summary>
    
      <category term="ruby" scheme="http://judes.me/categories/ruby/"/>
    
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="wechat" scheme="http://judes.me/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>sinatra 0.1.0 源码学习</title>
    <link href="http://judes.me/2016/07/10/sinatra-learning-0-1-0/"/>
    <id>http://judes.me/2016/07/10/sinatra-learning-0-1-0/</id>
    <published>2016-07-10T06:40:17.000Z</published>
    <updated>2016-08-13T01:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>本文系 <strong>sinatra 源码系列</strong>第 2 篇。系列的目的是通过 sinatra 学习 ruby 编程技巧。文章按程序运行的先后顺序挑重点分析，前一篇文章分析过的略去不说。水平很有限，所写尽量给出可靠官方/讨论链接，不坑路人。</p>
<h2 id="重要提醒">重要提醒</h2><p><strong>一定要先安装 1.8 版本的 ruby</strong> ，因为 1.9+ 的 ruby ，String 的实例是不响应 each 方法的，这会直接导致 rack 报错。可以使用 <a href="https://rvm.io/" target="_blank" rel="external">rvm</a> 安装 1.8.7 版本的 ruby ，如果使用 rvm ，请先升级到最新版本，否则安装 1.8.7 的 ruby 时也会报错。</p>
<p>列一下本人运行 sinatra 0.1.0 用到的 ruby 和关键 gem 的版本：</p>
<ul>
<li>ruby-1.8.7-p374</li>
<li>rack 1.4.1</li>
<li>mongrel 1.1.5</li>
</ul>
<h2 id="change_log">change log</h2><ul>
<li>支持设置运行环境</li>
<li>支持 session</li>
<li>支持在路由的资源路径中传入变量</li>
<li>增加测试用例</li>
<li>支持直接输出静态资源</li>
<li>支持渲染 layout</li>
<li>增加处理请求完成后的事件回调</li>
<li>支持后台日志实时打印</li>
</ul>
<h2 id="loader-rb">loader.rb</h2><p>sinatra 用 Loader 模块来加载/重新加载文件。用到 Set ，无需担心重复加载相同的文件。把 <code>load_file</code> 重命名为 <code>load_files</code>，也拯救了有强迫症的程序员。</p>
<p>sinatra 接下来将会这样使用 Loader ：</p>
<pre><code>Sinatra::Loader<span class="class">.load_files</span> Dir.<span class="function"><span class="title">glob</span><span class="params">(SINATRA_ROOT + <span class="string">'/lib/sinatra/core_ext/*.rb'</span>)</span></span>
</code></pre><p>要注意如果 core_ext 目录下有多个文件， Dir.glob 是不保证按一定顺序（比如字母顺序）加载文件的，讨论<a href="http://stackoverflow.com/questions/6220753/does-dir-glob-guarantee-the-order" target="_blank" rel="external">见此</a>， 1.8.7 版本的 ruby ，其 Set 也不保证 each 的顺序一致，来源<a href="http://stackoverflow.com/questions/6590152/is-the-each-iterator-in-ruby-guaranteed-to-give-the-same-order-on-the-same-elem" target="_blank" rel="external">见此</a>。</p>
<h2 id="kernel-rb">kernel.rb</h2><p>这里扩展了一个很有意思的方法 silence_warnings ，如你所见，就是屏蔽警告用的，用法如下：</p>
<pre><code>silence_warnings <span class="operator"><span class="keyword">do</span>
  <span class="keyword">value</span> = noisy_call # <span class="keyword">no</span> <span class="keyword">warning</span> voiced
<span class="keyword">end</span></span>
</code></pre><p>sinatra 只想在调用 silence_warnings 时屏蔽警告，其他时候显示警告。有时候我们也有类似的需求：调用某个方法之前改变某个配置，调用完了再把配置改回去。这涉及到保存配置和处理异常，可以借鉴 sinatra 在此处的做法。</p>
<h2 id="继承关系及至对象模型">继承关系及至对象模型</h2><p>sinatra 在 core_ext 目录下，先后扩展了 Class, Module, Kernel, Object, Hash 等多个类，它们之间是什么关系呢？这个问题又牵扯到另一个终极问题： ruby 的对象模型是什么？当你清楚 ruby 的对象模型后，众多类之间的关系就不在话下了。</p>
<p>空说无益，先教大家几个探索对象模型的方法，打开 irb ，写两个简单的类：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span> <span class="keyword">end</span>
<span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="inheritance">&lt; <span class="parent">A</span></span>;</span> <span class="keyword">end</span>
</code></pre><p>我们知道 B 继承自 A ，B 有一个方法可以显示自己的父类是谁：</p>
<pre><code>B.superclass <span class="comment">#=&gt; A</span>
<span class="comment"># 当 B 继承了 A ，我们就说 A 是 B 的超类（这是 ruby 的中文术语吧，一般都叫父类的）</span>
</code></pre><p>我们从 B 实例化出一个对象 b ，b 也有方法可以打印自己是属于哪个类的实例：</p>
<pre><code><span class="tag">b</span> = B<span class="class">.new</span>
<span class="tag">b</span><span class="class">.class</span> #=&gt; B
</code></pre><p>我们要知道 ruby 中，类也是实例，如果在类上面调用 class 方法会打印什么呢？</p>
<pre><code>A.<span class="keyword">class</span> #=&gt; <span class="keyword">Class</span>
B.<span class="keyword">class</span> #=&gt; <span class="keyword">Class</span>
Hash.<span class="keyword">class</span> #=&gt; <span class="keyword">Class</span>
<span class="keyword">Class</span>.<span class="keyword">class</span> #=&gt; <span class="keyword">Class</span>
<span class="keyword">Module</span>.<span class="keyword">class</span> #=&gt; <span class="keyword">Class</span>
</code></pre><p>就连在 Class 上调用 class 方法也得到 Class 。这里得出一个结论，所有类都是 Class 类的实例。</p>
<p>我们再回到继承这个话题，除了有办法看到一个类的超类，还有办法看到一个类的祖先链：</p>
<pre><code>B.ancestors <span class="preprocessor">#=&gt; [B, A, Object, Kernel, BasicObject]</span>
<span class="preprocessor">#=&gt; 上面的结果是在 ruby <span class="number">2.0</span><span class="number">.0</span> 版本中得到的，你的版本可能有少许不同</span>
</code></pre><p>可以看到 B 继承自 A ，A 继承自 Object , Object 继承自 Kernel , Kernel 继承自 BasicObject 。嗯，这种说法是不对的，实际上 Object 继承自 BasicObject ， Kernel 模块是被 Object include 进来的：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Object</span> <span class="inheritance">&lt; <span class="parent">BasicObject</span></span></span>
  <span class="keyword">include</span> <span class="constant">Kernel</span>
<span class="keyword">end</span>
</code></pre><p>被 include 进来的模块，都是刚好插入到类的祖先链的超类位置。</p>
<p>你会发现，几乎所有的类的祖先链都包含 Object, Kernel, BasicObject 这三个类：</p>
<pre><code>A.ancestors #=&gt; [A, <span class="built_in">Object</span>, Kernel, BasicObject]
Array.ancestors #=&gt; [Array, Enumerable, <span class="built_in">Object</span>, Kernel, BasicObject]
Fixnum.ancestors #=&gt; [Fixnum, Integer, Numeric, <span class="built_in">Comparable</span>, <span class="built_in">Object</span>, Kernel, BasicObject]
<span class="built_in">String</span>.ancestors #=&gt; [<span class="built_in">String</span>, <span class="built_in">Comparable</span>, <span class="built_in">Object</span>, Kernel, BasicObject]
</code></pre><p>这三个类可是继承链的发源地啊。</p>
<p>你会发觉我们还没有讲到 Module ， Module 是 Class 的超类：</p>
<pre><code><span class="keyword">Class</span>.ancestors #=&gt; [<span class="keyword">Class</span>, Module, <span class="keyword">Object</span>, Kernel, BasicObject]
</code></pre><p>以上是基础版的 ruby 对象模型，其实也没说多少。</p>
<h2 id="metaid-rb">metaid.rb</h2><p>sinatra 在这个里做了一个相当顶层的——Object——扩展，要理解这样做的目的，首先要明白 ruby 是怎样寻找一个方法的。打开 irb ，输入：</p>
<pre><code>class A
  def method_1
    puts 'I am instance <span class="keyword">method</span>'
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>首先要知道：方法都是存放在 类 ，而不是类的实例中的。如果类实例调用了某个方法，而在实例的类中找不到该方法，那么会沿着祖先链一直往上面找。如果最终还是找不到，就会转而调用该类的 method_missing 方法，如果该类没定义 method_missing 方法，也会沿祖先链一直往上找，直到 BasicObject(2.3.1 版 ruby ，1.8.7 版 ruby 是在 Kernel 上定义) 的 method_missing 方法。拿上面的例子来说：</p>
<pre><code>a = <span class="type">A</span>.<span class="keyword">new</span>
a.method_1 #=&gt; <span class="symbol">'I</span> am instance method'
<span class="keyword">class</span> <span class="type">A</span>
  def method_missing(method_name, *args, &amp;block)
    puts <span class="string">"you have called method #{method_name}"</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

a.method_2 #=&gt; <span class="symbol">'you</span> have called <span class="keyword">method</span> method_2'

<span class="keyword">class</span> <span class="type">B</span> &lt; <span class="type">A</span>; <span class="keyword">end</span>

b = <span class="type">B</span>.<span class="keyword">new</span>
b.method_1 #=&gt; <span class="symbol">'I</span> am instance method'
b.method_3 #=&gt; <span class="symbol">'you</span> have called <span class="keyword">method</span> method_3'
</code></pre><p>有时候我们还会定义这样的方法：</p>
<pre><code>class A
  def self.method_4
    puts 'I am singleton <span class="keyword">method</span> method_4'
  <span class="keyword">end</span>

  class &lt;&lt; self
    def method_5
      puts 'I am singleton <span class="keyword">method</span> method_5'
    <span class="keyword">end</span>  
  <span class="keyword">end</span>

  def A.method_6
    puts 'I am singleton <span class="keyword">method</span> method_6'
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>以上三种方法不同之处只在于名字不同，它们都是类的单例方法（singleton method）。刚说过：“方法都是存放在 类 ，而不是类的实例中的”，单例方法也是如此，它存在于实例的 metaclass 中（或者叫做 eigenclass ，官方称作 singleton class）。metaclass 一直待在我们的视野范围之外，官方没有提供让它们现形的方法， sinatra 要做的就是扩展一套这样的方法。</p>
<p>metaid.rb 第 6、7 行的写法很帅气，但也很难看懂，稍为整理一下：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">metaclass</span></span>
  <span class="comment">#1</span>
  <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span><span class="inheritance">&lt; <span class="parent">self</span></span> <span class="comment">#2</span></span>
    <span class="comment">#3</span>
    <span class="keyword">self</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="function"><span class="keyword">def</span> <span class="title">meta_eval</span> <span class="title">&amp;</span><span class="title">blk</span></span>
  metaclass.instance_eval &amp;blk
<span class="keyword">end</span>
</code></pre><p>分析 metaclass 方法，在 #1 处，如果把 self 打印出来，这个 self 会是 Object 的实例（具体得看是谁调用 metaclass 方法）；在 #2 处，运用 ruby 提供的语法 <code>class &lt;&lt; self</code> ，把 <code>class &lt;&lt; self; self; end</code> 块中的 self 设置为 Object 实例的 metaclass ；所以在 #3 处，如果把 self 打印出来，这个 self 会是 Object 实例的 metaclass ，而这个 self 会作为块的结果返回， metaclass 方法又将块的结果返回，最终得到 Object 实例的 metaclass 。</p>
<p>附上对 metaclass 的分析参考资料：</p>
<ul>
<li><a href="https://www.amazon.com/Metaprogramming-Ruby-Program-Like-Facets/dp/1941222129" target="_blank" rel="external">Metaprogramming Ruby 2: Program Like the Ruby Pros (Facets of Ruby)</a></li>
<li><a href="http://viewsourcecode.org/why/hacking/seeingMetaclassesClearly.html" target="_blank" rel="external">seeingMetaclassesClearly</a></li>
<li><a href="http://yehudakatz.com/2009/11/15/metaprogramming-in-ruby-its-all-about-the-self/" target="_blank" rel="external">Metaprogramming in Ruby: It’s All About the Self</a></li>
</ul>
<h2 id="symbol-rb">symbol.rb</h2><p>在系列第 1 篇文章说过，可以给 Symbol 定义一个 to_proc 方法，方便与 &amp; 操作符配合使用。 sinatra 定义了一个看上去不一样的 to_proc ：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">to_proc</span></span>
  <span class="constant">Proc.</span>new { |*args| args.shift.<span class="constant">__send__(</span><span class="keyword">self</span>, *args) }
<span class="keyword">end</span>
</code></pre><p>但做的事情跟第 1 篇文章中的一样。</p>
<p><code>*</code> （splat operator）出现了两次，意义刚好相反，第一次出现是把调用方法时传进来的参数变为一个数组，第二次出现是把一个数组拆散成一个个的参数传到方法中。在 1.8 版本的 ruby ，只要是能响应 to_ary 方法的对象都可以这样用：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">to_ary</span></span>
    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
  <span class="keyword">end</span>
<span class="keyword">end</span>

a, *b = <span class="constant">Foo</span>.new <span class="comment">#=&gt; a = 1, b = [2,3]</span>

<span class="function"><span class="keyword">def</span> <span class="title">some_method</span><span class="params">(p1,p2,p3)</span></span>
  p <span class="string">"<span class="subst">#{p1}</span> <span class="subst">#{p2}</span> <span class="subst">#{p3}</span>"</span>
<span class="keyword">end</span>

some_method(*<span class="constant">Foo</span>.new) <span class="comment">#=&gt; 1 2 3</span>
</code></pre><p>上面这个例子出自<a href="https://blog.pivotal.io/labs/labs/ruby-pearls-vol-1-the-splat" target="_blank" rel="external">此处</a>。</p>
<p><code>args.shift</code> 会删除并返回 args 数组第一个元素。</p>
<p><code>__send__</code> 方法跟 <code>send</code> 方法做的事情一样。因为 send 这个单词太普通、常用了，很容易被程序员覆写，所以 ruby 又另外提供一个 <code>__send__</code> ，如果不小心覆写这个方法， ruby 会提示警告：</p>
<pre><code><span class="attribute">warning</span>: <span class="string">redefining `__send__' may cause serious problem</span>
</code></pre><p>附上对这个方法讨论的<a href="http://stackoverflow.com/questions/4658269/ruby-send-vs-send" target="_blank" rel="external">链接</a></p>
<h2 id="module-rb">module.rb</h2><p>module.rb 在 Module 扩展了一个 attr_with_default 方法，这个方法类似 Class 中的 cattr_accessor ，只不过多了个默认值。</p>
<p>这里出现元编程中常见的 <code>define_method</code> 方法，它是定义在 Module 中的私有方法，用来动态地生成方法。完整文档可以看<a href="http://ruby-doc.org/core-2.2.0/Module.html" target="_blank" rel="external">这里</a>。</p>
<p>一般情况下 <code>define_method</code> 只能在定义类时直接调用（此时 self 指向类本身），如：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>
  define_method(<span class="symbol">:m_a</span>) { p <span class="string">'m_a'</span> }
<span class="keyword">end</span>

<span class="constant">A</span>.new.m_a <span class="comment">#=&gt; m_a</span>
</code></pre><p>如果要在实例方法里调用 <code>define_method</code> ，这样写会出报找不到方法错误：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">create_mehtod</span><span class="params">(sym, &amp;block)</span></span>
    define_method(sym, &amp;block)
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="constant">B</span>.new.create_method(<span class="symbol">:m_b</span>) {p <span class="string">'m_b'</span>} <span class="comment">#=&gt; NoMethodError: undefined method `define_method'</span>
</code></pre><p>回顾 ruby 寻找方法的步骤：先到实例的类中找，找不到就沿着类的祖先链找，打印 B 的祖先链，里面并没有 Module ，这就是出错的原因：</p>
<pre><code><span class="keyword">B.ancestors </span>#=&gt; [<span class="keyword">B, </span>Object, Kernel]
</code></pre><p>而在定义类时直接调用 <code>define_method</code> 不报错，是因为此时 self 指向 A ，而 A 作为实例的话，它的类是 Class ，打印 Class 的祖先链，里面就有 Module：</p>
<pre><code><span class="keyword">Class</span>.ancestors #=&gt; [<span class="keyword">Class</span>, Module, <span class="keyword">Object</span>, Kernel]
</code></pre><p>在调用 <code>define_method</code> 时把 self 指向 B ，还是会报错：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">create_mehtod</span><span class="params">(sym, &amp;block)</span></span>
    <span class="keyword">self</span>.<span class="keyword">class</span>.define_method(sym, &amp;block)
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="constant">B</span>.new.create_method(<span class="symbol">:m_b</span>) {p <span class="string">'m_b'</span>} <span class="comment">#=&gt; NoMethodError: private method `define_method' called for B:Class</span>
</code></pre><p>因为 <code>define_method</code> 是私有方法，不能显式调用，官方文档给出了解决办法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">create_mehtod</span><span class="params">(sym, &amp;block)</span></span>
    <span class="keyword">self</span>.<span class="keyword">class</span>.send(<span class="symbol">:define_method</span>, sym, &amp;block)
  <span class="keyword">end</span>
<span class="keyword">end</span>

b = <span class="constant">B</span>.new.create_method(<span class="symbol">:m_b</span>) {p <span class="string">'m_b'</span>}
b.m_b <span class="comment">#=&gt; m_b</span>
</code></pre><h2 id="request-rb">request.rb</h2><p>这里重新打开了 Rack::Request ，扩展了 request_method 方法。这样做的缘由是：html 的 form 元素只支持 GET 和 POST 方法， RESTful 定义的方法至少有 GET/POST/PUT/DELETE 四种，为了让 form 也用上 PUT 和 DELETE 方法， sinatra 检测 POST 请求中的 _method 参数，如果是 PUT 或者 DELETE ，就直接替换 POST 。相关讨论<a href="http://stackoverflow.com/questions/16805956/why-dont-browsers-support-put-and-delete-requests-and-when-will-they" target="_blank" rel="external">见此</a></p>
<h2 id="environment-rb">environment.rb</h2><p>在加载完 core_ext 和 rack_ext 目录下的文件后，会加载 sinatra 目录下的文件，一时不知从何下手分析，看到后面有行代码：</p>
<pre><code><span class="label">Sinatra::</span>Environment.prepare
</code></pre><p>就从 environment.rb 说起吧。</p>
<p><strong> ARGV </strong></p>
<p>Environment 的 prepare 方法用来解释参数。 <code>ARGV</code> 是定义在 Object 中的常量，并且是 Array 的实例，表示在命令行运行脚本文件时传入的参数列表。</p>
<h2 id="options-rb">options.rb</h2><p>parse! 实际上没有用到传进来的参数，它用的还是 ARGV 。</p>
<p>这个版本的 sinatra 开始区分运行脚本的环境（test/development/production），如果当前处在 test 环境， parse! 方法立即返回。</p>
<p>接下来解释参数的任务就交给 <a href="http://ruby-doc.org/stdlib-1.8.7/libdoc/optparse/rdoc/OptionParser.html" target="_blank" rel="external">OptionParser</a> 了。</p>
<p>这里有一句 <code>env.intern</code> 。 env 是一个 String 实例， intern 方法获取字符串在 ruby 的内部实现（internal representation）。 ruby 最终会把字符串转换为符号，所以这个方法跟 to_sym 方法做一样的事情。 参见<a href="https://www.codecademy.com/en/forum_questions/512a675cf116c52d0d00674b" target="_blank" rel="external">相关讨论</a> (PS. 讨论中提及为什么 ruby 给同一个方法取不同的名字，很有启发意义)</p>
<h2 id="logger-rb">logger.rb</h2><p>与前一个版本相比，这个文件多了一行代码：</p>
<pre><code>define_method n <span class="keyword">do</span> |message|
  <span class="variable">@stream</span>.puts message
  <span class="variable">@stream</span>.flush <span class="comment">#多了这一行</span>
<span class="keyword">end</span>
</code></pre><p>@stream 是一个 IO 实例， flush 方法将 IO 实例中缓存的数据写到操作系统中去（<a href="http://ruby-doc.org/core-2.2.3/IO.html#method-i-flush" target="_blank" rel="external">官方文档</a>中解释操作系统仍然有可能缓存起来，所以并没有保证写到设备/文件中）。举个例子，在早期的 ruby 中，下面这段代码会等待 10 秒，然后在同一行打印 5 个点：</p>
<pre><code><span class="number">5</span>.<span class="keyword">times</span> <span class="keyword">do</span>
  <span class="keyword">print</span> <span class="string">'.'</span>
  <span class="keyword">sleep</span> <span class="number">2</span>
end
</code></pre><p>要想每 2 秒打印一个点，可以在 <code>print &#39;.&#39;</code> 下面加上一句 <code>$stdout.flush</code>。</p>
<p>缓存输出，直到打印换行符或者缓存满了，这个特性来源于 c 言语标准库，初衷应该是减少系统调用。后来不知道是 c 言语标准库还是 ruby 作了改动，修复了上面那个问题。</p>
<p>推荐几篇有关 Ruby IO 的文章：</p>
<ul>
<li><a href="https://robots.thoughtbot.com/io-in-ruby" target="_blank" rel="external">IO in Ruby</a></li>
<li><a href="https://www.ruby-forum.com/topic/208856" target="_blank" rel="external">Use of STDOUT.flush after puts</a></li>
<li><a href="https://matt.berther.io/2009/02/11/puts-vs-print-in-ruby/" target="_blank" rel="external">puts vs print in ruby</a></li>
</ul>
<h2 id="irb-rb">irb.rb</h2><p>在运行 sinatra 时加上 -c 参数，就会用 console 模式启动 sinatra 。</p>
<p>这个文件只定义了 start! 方法。在 ruby 中定义末尾带感叹号(!)的方法，意味着这个方法比不带感叹号的危险，要小心使用。</p>
<p>start! 方法首先让 Object 加载 TestMethods 模块， <code>include</code> 方法是 Object 的私有方法，所以要使用 Object.send 加载（还记得这个技巧在 module.rb 那一节说过吗）。</p>
<p>接着给 Object 类扩展了 reload! 和 show! 两个方法（建议现在就运行 sinatra 的 console 模式，动手玩玩这两个方法）。</p>
<p>show! 调用了 IO.popen 方法。如果你想开一个子进程来调用外部命令，而且还想把外部命令的标准输入和标准输出跟 ruby 连接起来，那这个方法能满足你的需求。 popen 里的 p 指代 pipeline （管道）。管道是进程间通信的一种方式。</p>
<p>举个使用 popen 的例子：</p>
<pre><code>IO.popen(<span class="string">'tail -3'</span>, <span class="string">'w+'</span>) <span class="keyword">do</span> |<span class="keyword">pipe</span>|

  <span class="comment"># ruby 会开一个子进程来运行这个 block </span>
  <span class="comment"># 管道中属于 ruby 的这一头会作为参数传进来</span>

  <span class="number">1</span>.upto(<span class="number">100</span>) <span class="keyword">do</span> { |i| <span class="keyword">pipe</span>.puts <span class="string">"line #{i}"</span> } 
  <span class="keyword">pipe</span>.close_write <span class="comment">#在读取流之前一定要先把写入关闭，否则读取会阻塞</span>
  puts <span class="keyword">pipe</span>.<span class="keyword">read</span>
end

<span class="comment"># line 98</span>
<span class="comment"># line 99</span>
<span class="comment"># line 100</span>
</code></pre><p>show! 方法的意图是打开文本编辑器，并写入 TestMethods 模块中的几个方法 status / headers / body 的返回结果。</p>
<p>举个例子，假设你能在命令行使用 <code>subl</code> 命令打开 sublime text 。你可以先跳转到 examples/hello 目录下，输入：</p>
<pre><code>EDITOR=subl ruby hello<span class="class">.rb</span> -c
</code></pre><p>这时你会进入 irb ，然后输入：</p>
<pre><code><span class="function_or_atom">show</span><span class="exclamation_mark">!</span>
</code></pre><p>这时你的 sublime text 就会被打开，里面已经写入了一些内容：</p>
<pre><code><span class="xml"><span class="comment">&lt;!--
        # Status: 404
        # Headers: </span></span><span class="expression">{<span class="string">"Content-Type"</span>=&gt;<span class="string">"text/html"</span>, <span class="string">"Content-Length"</span>=&gt;<span class="string">"0"</span>}</span><span class="xml"><span class="comment">
--&gt;</span></span>
</code></pre><p>推荐一本用 ruby 来描述的关于进程的入门书 <a href="http://www.ituring.com.cn/minibook/347" target="_blank" rel="external">理解Unix进程</a>，里面有提及进程间通信的方式。</p>
<p>还有几个关于 popen 的文档/讨论</p>
<ul>
<li><a href="http://www.rubydoc.info/stdlib/core/IO.popen" target="_blank" rel="external">IO.popen</a></li>
<li><a href="https://www.safaribooksonline.com/library/view/ruby-cookbook/0596523696/ch20s08.html" target="_blank" rel="external">Driving an External Process with popen</a></li>
</ul>
<p>接下来 sinatra 先清空 ARGV 。如果当前目录（启动 sinatra 时所在的目录，而不是当前文件所在的目录， 运行 <code>Dir.pwd</code> 可以看到）下有 ‘.irbrc’ 文件，就把它保存到环境变量中， irb 会在启动时加载这个文件。</p>
<p>当用户退出 irb 时，立即运行 <code>exit!</code> ，这样就退出了 sinatra 。</p>
<p><code>exit!</code> 和 <code>exit</code> 的区别是前者会跳过退出时的处理程序(比如 at_exit )，前者默认的退出状态是 false ，而后者默认的退出状态是 true ( ruby 不同版本有不同的退出返回值， 1.8.7 版本 <code>exit</code> 默认返回 0 ， <code>exit!</code> 默认返回 -1 。 unix 会把返回值 0 当成 true ，其它返回值当成 false )。</p>
<h2 id="server-rb">server.rb</h2><p>Server#start 方法首先调用 Server#tail 方法打印 log file 里面的内容。 tail 方法另开一个线程打开 log file ，然后不断地检查（ 1 秒 1 次）它有没有被改动，如果有则打印自上一次文件流的位置到最新文件流的末尾之间的内容。这段代码可以再精简一点：</p>
<pre><code>File.open(log_file, 'r') <span class="operator"><span class="keyword">do</span> |<span class="keyword">f</span>|
  <span class="keyword">loop</span> <span class="keyword">do</span>
    <span class="keyword">if</span> <span class="keyword">f</span>.mtime &gt; last_checked
      last_checked = <span class="keyword">f</span>.mtime
      puts <span class="keyword">f</span>.<span class="keyword">read</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></span>
</code></pre><p>IO#read 方法会把 cursor 的位置定位到流的末尾，所以不需要手动调用 IO#seek 重新定位 cursor 的位置，这一点可以在调用 IO#read 之后再 打印 IO#pos 的结果证明。</p>
<p>Server#start 最后调用 Thread#kill 方法杀掉这个线程。这一步很有可能是多余的，因为如果当前线程（ main thread ）结束了，所有其他线程都将会被杀死。</p>
<p>sinatra 用到多进程和多线程，两者的区别以及使用时机可参考<a href="http://jayant7k.blogspot.com/2010/01/for.html" target="_blank" rel="external">这篇文章</a>和<a href="http://stackoverflow.com/questions/18575235/what-do-multi-processes-vs-multi-threaded-servers-most-benefit-from" target="_blank" rel="external">这篇文章</a></p>
<p>stackoverflow 的一些讨论：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/3481866/thread-join-blocks-the-main-thread" target="_blank" rel="external">Thread.join blocks the main thread</a></li>
</ul>
<h2 id="dispatcher-rb">dispatcher.rb</h2><p>在开发环境(development)中，sinatra 响应每一个请求前都会重新加载依赖文件以及在命令行中被 ruby 直接执行的脚本文件:</p>
<pre><code>Loader.reload! <span class="keyword">if</span> Options<span class="class">.environment</span> == :development
</code></pre><p>这样在开发环境中改动文件不需要重启就生效。 <code>Loader.reload!</code> 方法会重新加载被执行的脚本文件，看上去会产生循环加载的问题，举个例子，跳转到 examples/hello/ 目录下，在命令行中输入：</p>
<pre><code>ruby hello.rb -c
<span class="preprocessor"># =&gt; 通过 require <span class="string">'sinatra'</span> ， 加载 /lib/sinatra 目录下的相关文件，也把这些文件加载到 loaded_files 中</span>
</code></pre><p>此时在命令行中输入：</p>
<pre><code>reload!
<span class="preprocessor"># =&gt; 重新加载 loaded_files 中的文件，然后加载 hello.rb 文件</span>
</code></pre><p>hello.rb 文件中有 <code>require &#39;sinatra&#39;</code> ，这会不会导致 ruby 重新加载 sinatra 呢？</p>
<p>不会。</p>
<p><code>Kernel#require</code> 方法会在 <code>$LOAD_PATH</code> 中查找要加载的文件，它也会帮你加上 .rb 或者 .so 文件后缀。比如此处的 <code>require &#39;sinatra&#39;</code> ，它会在 lib/ 目录下找到 sinatra.rb 文件。</p>
<p>已经被 <code>Kernel#require</code> 加载过的文件会保存在 <code>$&quot;</code> 变量中，<code>Kernel#require</code> 不会再次加载已经加载过的文件。</p>
<p><code>Kernel#load</code> 方法要求在使用时写上文件路径以及文件后缀，如果文件路径不是绝对路径，会在 <code>$LOAD_PATH</code> 中查找文件。</p>
<p><code>Kernel#load</code> 会再次加载已经加载过的文件。</p>
<p>想关讨论可参考<a href="http://stackoverflow.com/questions/3170638/how-does-load-differ-from-require-in-ruby" target="_blank" rel="external">How does load differ from require in Ruby?</a></p>
<p>ruby 预先定义了不少变量、常量，<a href="http://ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/variable.html#dquote" target="_blank" rel="external">这是列表</a></p>
<h2 id="sessions-rb">sessions.rb</h2><p>Rack::Session::Cookie 实现了基于 cookie 的 session 管理功能，只要浏览器发过来的 cookie 中有 key 为 session_id 的键值对，Rack 就能借此保存、读取数据。</p>
<p>Rack::Session::Cookie 最初并没有实现基于 session_id 读写数据，所有数据都保存在 env[‘rack.session’] 下面，源码<a href="https://github.com/rack/rack/commit/417ac6a3d6b394dc2a2d30d9e1235148170dec50" target="_blank" rel="external">见此</a>。 0.1.0 的 sinatra 应该就是使用这个最初的实现，通过控制台可以看到 cookie 中直接使用 rack.session 保存加密后的数据。</p>
<p>cookie 功能默认开启，如果要关闭它，可以在加载之后调用 dsl.rb 中定义的 <code>sessions</code> 方法：</p>
<pre><code><span class="title">sessions</span> :<span class="built_in">off</span>
</code></pre><p>sinatra 还提供 <code>session</code> 方法返回已保存的 session ，方便使用 cookie 功能，下面是一个例子：</p>
<pre><code><span class="comment">#!usr/bin/env ruby</span>
<span class="comment">#file examples/you_say.rb</span>
<span class="keyword">require</span> <span class="string">'sinatra'</span>

get <span class="string">'/'</span> <span class="keyword">do</span>
  session[<span class="symbol">:you_say</span>] = params[<span class="symbol">:you_say</span>] || <span class="string">'no'</span>
  <span class="comment"># 注意 session 和 params 都要用 symbol 作 key</span>
  <span class="string">'hello'</span>
<span class="keyword">end</span>

get <span class="string">'/session'</span> <span class="keyword">do</span>
  session[<span class="symbol">:you_say</span>]
<span class="keyword">end</span>
</code></pre><p>先访问 <code>localhost:4567/?you_say=hi</code> ，再访问 <code>localhost:4567/session</code> ，能看到页面显示 ‘hi’ 。</p>
<h2 id="event-rb">event.rb</h2><p><strong> EventManager </strong> 负责注册事件、匹配事件。</p>
<p>它调用 <code>determine_event</code> 匹配路由、方法，如果匹配不到，就调用 <code>present_error</code> 去找用户自定义的 404 路由处理器，如果用户没有预先定义，就调用 <code>not_found</code> ，使用默认的 404 处理器。</p>
<p><a href="http://ruby-doc.org/core-1.8.7/Object.html#method-i-method" target="_blank" rel="external">Object#method</a> 根据名字返回方法（或者抛出 NameError 异常），被返回方法的 receiver 就是调用 Object#method 的对象，而且被返回方法就像闭包一样，能访问此对象的实例变量以及方法。举例如下：</p>
<pre><code>class <span class="constant">A</span>
  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(v)
    <span class="variable">@k</span> = v
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">get_put_k_method</span></span>
    method(<span class="symbol">:put_k</span>)
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">put_k</span></span>
    puts <span class="string">"k value is <span class="subst">#{<span class="variable">@k</span>}</span>"</span>
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">get_another</span></span>
    method(<span class="symbol">:set_put_k</span>)
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">set_put_k</span></span>(new_k=<span class="keyword">nil</span>)
    <span class="variable">@k</span> = new_k
    put_k
  <span class="keyword">end</span>
<span class="keyword">end</span>

a = <span class="constant">A.</span>new(<span class="string">'hi'</span>)
m = a.get_put_k_method
m.call <span class="comment">#=&gt; k value is hi</span>

m2 = a.get_another
m2.call(<span class="string">'hello'</span>) <span class="comment">#=&gt; k value is hello</span>
</code></pre><p>Event 类把路由匹配交由 Route 处理，还增加了事件处理回调 after_filters 。</p>
<p>StaticEvent 负责处理静态资源，用法跟其他路由一样：</p>
<pre><code>get <span class="string">'/'</span>, <span class="string">'home'</span>
<span class="keyword">static</span> <span class="string">'/p'</span>, <span class="string">'public'</span>
<span class="preprocessor">#请求 <span class="string">'/p/css/bootstrap.css'</span> 会被映射到 <span class="string">'public/css/bootstrap.css'</span></span>
</code></pre><p>StaticEvent 的 <code>attend</code> 方法中有这样一行： <code>context.body self</code> ，之后还定义了 <code>each</code> 方法。这样做全因为 Rack 要求 http body 对象响应 each 方法。</p>
<p><code>each</code> 方法用二进制读取模式打开静态文件。 <a href="http://ruby-doc.org/core-2.2.0/IO.html#method-i-read" target="_blank" rel="external">IO#read</a> 接受字节长度作为参数，从流中读取指定长度的字节，如果一开始就读到 EOF ，会返回 nil 。</p>
<p>8192 字节（8KB）是常用的 chunk size 。</p>
<p>在设置响应头的 Content-Type 时，用到了<code>#[]</code>方法：</p>
<pre><code>File.extname(<span class="constant">@filename</span>)[<span class="number">1.</span>.-<span class="number">1</span>]
<span class="preprocessor"># <span class="string">'.rb'</span>[1..-1] =&gt; <span class="string">'rb'</span></span>
</code></pre><p>此处传入的 Range 参数（(1..-1)），表示的范围是：从左边数起第 2 个元素到右边数起第 1 个元素。</p>
<h2 id="renderer-rb">renderer.rb</h2><p>EventContext 加载了 Sinatra::Renderer 模块，此模块为其他渲染方法提供基础方法，比如 Sinatra::Erb 和 Sinatra::Haml ，你还可以定制自己的渲染方法。注释里写了一个定制的例子，如果还有不清楚的地方，可以查看对应的测试用例： renderer_test.rb 。 </p>
<p><code>render</code> 方法会根据参数 renderer ，动态调用真正实现渲染的方法 result_method 。</p>
<p><code>render</code> 方法把传进来的 block 当作 layout 的来源之一。如果请求有对应的 layout ，在第二次调用 result_method 方法时把 layout 当成是 template 参数传进去。</p>
<h2 id="route-rb">route.rb</h2><p>在实例化每个 Event 时，会一并实例化一个 Route 。而每一次调用 <code>Event#attend</code> ，会先把 <code>@route.params</code> 合并到 <code>request.params</code> 中。这就把用户具体的请求路径与路由的 symbol 对应起来。如：</p>
<pre><code>get '/:controller/:<span class="keyword">method</span>' <span class="keyword">do</span>
  <span class="string">"you #{params[:controller]} #{params[:method]}"</span>
<span class="keyword">end</span>
<span class="comment"># 当用户请求 '/say/hi' 时</span>
<span class="comment"># 会返回 "you say hi"</span>
</code></pre><p><code>Route#extract_keys</code> 把路由中的 symbol 提取出来，如：</p>
<pre><code>temp_arr = <span class="string">"/:some/:words"</span>.scan(/:\w+/)
<span class="preprocessor">#=&gt; temp_arr = [<span class="string">":some"</span>,<span class="string">":words"</span>]</span>
temp_arr.map { |raw| <span class="built_in">eval</span>(raw) } <span class="preprocessor">#=&gt; [:some, :words]</span>
</code></pre><p><code>Route#genereate_route</code> 生成用于匹配用户请求的路由。路由又分两种，带格式(format)和不带格式的，默认格式是 html 。</p>
<p><code>Route#to_regex_route</code> 把路由转换成正则表达式，在点(.)前面加上反斜杠，把 <code>symbol</code> 替换成 <code>&#39;([^\/.,;?]+)&#39;</code>。在匹配成功后可以用 <code>captures</code> 方法找到用户请求的路径。如：</p>
<pre><code>class A
  def to_regex_route(<span class="keyword">template</span>)
    /^<span class="comment">#{template.gsub(/\./,'\.').gsub(/:\w+/,'([^\/.,;?]+)')}$/</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
a = A.new
reg = a.to_regex_route('/:path/:to/:file.html')
<span class="comment"># reg =&gt; (?-mix:^\/([^\/.+,;?])\/([^\/.+,;?])\/([^\/.+,;?])\.html$)</span>
'/a/b/c.html'.match(reg).captures
<span class="comment"># =&gt; ['a','b','c']</span>
</code></pre><p><code>/([^\/.,;?]+)/</code> 匹配不是斜杠(/)，点(.)，逗号(,)，分号(;)，问号(?)的其他字符。</p>
<p><code>Route#recognize</code> 会在 <code>Event#attend</code> 中调用，所以每次都得先清空 <code>@params</code> 。</p>
<p>如果成功匹配用户请求的路径，接下来就把 symbol 和具体的路径组合起来：</p>
<pre><code>@keys.<span class="function"><span class="title">zip</span><span class="params">(param_values)</span></span>.to_hash
</code></pre><p><code>Array#zip</code> 方法用法举例：</p>
<pre><code>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].zip([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="preprocessor">#=&gt; [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">6</span>]]</span>
</code></pre><p><code>Array#to_hash</code> 方法是 sinatra 扩展的。</p>
<p>一些方法参考： </p>
<ul>
<li><a href="http://ruby-doc.org/core-1.8.7/Object.html" target="_blank" rel="external">Object#freeze</a></li>
<li><a href="http://ruby-doc.org/core-1.8.7/Array.html#method-i-compact" target="_blank" rel="external">Array#compact</a></li>
<li><a href="http://ruby-doc.org/core-1.8.7/Object.html" target="_blank" rel="external">Object#dup</a></li>
<li><a href="http://stackoverflow.com/questions/10183370/whats-the-difference-between-rubys-dup-and-clone-methods" target="_blank" rel="external">What’s the difference between Ruby’s dup and clone methods?</a></li>
</ul>
<h2 id="dsl-rb">dsl.rb</h2><p>dsl.rb 文件的最后调用 <code>include Sinatra::Dsl</code> 把 Sinatra::Dsl 模块放到 main 对象祖先链的父节点位置，这样就可以把 Sinatra::Dsl 定义的方法当作实例方法调用。</p>
<p>也可以把 <code>include Sinatra::Dsl</code> 替换成 <code>extend Sinatra::Dsl</code> ，后者把 Sinatra::Dsl 定义的方法当作单例方法调用。</p>
<p>看出问题了吗？</p>
<p>main 对象同时作为 Object class 的实例以及 Object class 本身去调用方法，否则不能解释它既可以调用实例方法又可以调用单例方法。</p>
<p>有一篇<a href="https://banisterfiend.wordpress.com/2010/11/23/what-is-the-ruby-top-level/" target="_blank" rel="external">文章</a>展示了神奇 main 对象。</p>
<h2 id="test">test</h2><p>这一版本补充了单元测试。跑测试用例之前要先安装两个 gem ： mocha(0.5.6), test-spec(0.10.0) 。</p>
<p>还要在 test/helper.rb 文件中，加载 mocha 和 test/sepc 时把 <code>stringio</code> 也加载进来，否则 request_test.rb 会跑不过。</p>
<p>helper.rb 里把 <code>Sinatra::TestMethods</code> <code>include</code> 到 <code>Test::Unit::TestCase</code> 中，因而每个测试都可以使用 Sinatra::TestMethods 提供的方法。</p>
<p><code>Rack::MockRequest</code> 让 <code>Sinatra::TestMethods</code> 模块里的几个方法不需要产生真实的 http 请求，就能调用到 sinatra 定义的请求处理器。详见<a href="http://www.rubydoc.info/github/rack/rack/Rack/MockRequest" target="_blank" rel="external"> MockRequest 的文档</a>。</p>
<p>要跑所有测试用例，可以在根目录下运行：</p>
<pre><code><span class="keyword">find</span> .<span class="regexp">/test/</span>sinatra -name <span class="string">'*.rb'</span> | xargs -n1 ruby
</code></pre><p>全文完。</p>
]]></content>
    
    <summary type="html">
    
      通过 sinatra 学习 ruby 编程技巧（系列）
    
    </summary>
    
      <category term="ruby" scheme="http://judes.me/categories/ruby/"/>
    
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="sinatra" scheme="http://judes.me/tags/sinatra/"/>
    
  </entry>
  
  <entry>
    <title>写写希尔排序</title>
    <link href="http://judes.me/2016/07/07/shell-sort/"/>
    <id>http://judes.me/2016/07/07/shell-sort/</id>
    <published>2016-07-07T00:11:43.000Z</published>
    <updated>2016-07-08T00:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>希尔排序不应该放在这个系列的，因为并不十分清楚它的原理，想要完整了解的朋友请看<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a></p>
<p>下面是原理的简单解释：</p>
<h2 id="原理">原理</h2><p>希尔排序是”插入排序的一种更高效的改进版本”，从这个角度理解，它继承了插入排序的优点：</p>
<ul>
<li>对大体已排好序的集合有相当高的效率</li>
</ul>
<p>解决了插入排序的一点不足：</p>
<ul>
<li>每次比较只能把待排序元素移动一位，如果待排序元素离最终位置比较远，需要多次操作</li>
</ul>
<p>希尔排序依靠变化的比较、交换步长解决这点不足：先用较大的步长把集合整理在大体有序，最后使用步长为 1 的插入排序整理成完全有序。</p>
<h2 id="联想">联想</h2><p>希尔排序的内核是插入排序，在插入排序的外面再包裹一层循环——让步长从某个初始值逐渐变小到 1 。这个初始值定为待排序集合长度的 1/3 处。</p>
<h2 id="用法">用法</h2><pre><code><span class="shebang">#!/usr/bin/env ruby</span>
sorted_array = SS.sort(array)
</code></pre><h2 id="大体结构">大体结构</h2><pre><code><span class="comment">#!/usr/bin/env ruby</span>
class SS
  class &lt;&lt; self
    def sort<span class="instruction"> array
</span>     <span class="instruction"> return </span>array<span class="instruction"> if </span>array.size &lt;= 1
      step =<span class="function"> (</span>array.size / 3.0<span class="function">)</span>.ceil
      while step &gt;= 1
        <span class="comment"># insertion sort  </span>
        step -= 1
      end
     <span class="instruction"> array
</span>    end
  end
end
</code></pre><h2 id="插入排序部分">插入排序部分</h2><p>插入排序可以参考之前写过的<a href="/2016/07/05/insertion-sort/">文章</a>，要点是对插入排序的内、外两层循环都应用可变步长</p>
<pre><code>#!/usr/bin/env ruby
<span class="keyword">class</span> SS
  <span class="keyword">class</span> &lt;&lt; self
    def sort <span class="built_in">array</span>
      <span class="built_in">len</span> = <span class="built_in">array</span>.size
      return <span class="built_in">array</span> <span class="keyword">if</span> <span class="built_in">len</span> &lt;= <span class="number">1</span>
      <span class="keyword">step</span> = (<span class="built_in">len</span> / <span class="number">3.0</span>).ceil
      <span class="keyword">while</span> <span class="keyword">step</span> &gt;= <span class="number">1</span>
        tag = <span class="keyword">step</span>
        <span class="keyword">while</span> tag &lt; <span class="built_in">len</span>
          inner_tag = tag
          <span class="keyword">while</span> inner_tag &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">array</span>[inner_tag] &lt; <span class="built_in">array</span>[inner_tag - <span class="keyword">step</span>]
            exchange(<span class="built_in">array</span>, inner_tag, inner_tag - <span class="keyword">step</span>)
            inner_tag -= <span class="keyword">step</span>
          <span class="keyword">end</span>
          tag += <span class="keyword">step</span>
        <span class="keyword">end</span>
        <span class="keyword">step</span> -= <span class="number">1</span>
      <span class="keyword">end</span>
      <span class="built_in">array</span>
    <span class="keyword">end</span>
    def exchange <span class="built_in">array</span>, i, j
      <span class="built_in">array</span>[i], <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j], <span class="built_in">array</span>[i]
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h2 id="完整的代码，加测试用例如下：">完整的代码，加测试用例如下：</h2><pre><code><span class="comment">#!/usr/bin/env ruby</span>

class SS
  class &lt;&lt; self
    def sort<span class="instruction"> array
</span>      len = array.size
     <span class="instruction"> return </span>array<span class="instruction"> if </span>len &lt;= 1
      step =<span class="function"> (</span>len / 3.0<span class="function">)</span>.ceil
      while step &gt;= 1
        tag = step
        while tag &lt; len
          inner_tag = tag
          while inner_tag &gt;= 1 &amp;&amp; array<span class="keyword">[</span>inner_tag] &lt; array<span class="keyword">[</span>inner_tag - step]
           <span class="function"> exchange(</span>array, inner_tag, inner_tag - step<span class="function">)</span>
            inner_tag -= step
          end
          tag += step
        end
        step -= 1
      end
     <span class="instruction"> array
</span>    end
    def exchange array, i, j
      array<span class="keyword">[</span>i], array<span class="keyword">[</span>j] = array<span class="keyword">[</span>j], array<span class="keyword">[</span>i]
    end
  end
end
<span class="instruction">
if </span>__FILE__ == $0

  require 'test/unit'

  class TestSS &lt; Test::Unit::TestCase
    def test_0
      input = <span class="keyword">[</span>]
      expected = <span class="keyword">[</span>]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'empty<span class="instruction"> array </span>not equal'
    end
    def test_1_0
      input = <span class="keyword">[</span>0]
      expected = <span class="keyword">[</span>0]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'    
    end
    def test_1_1
      input = <span class="keyword">[</span>1]
      expected = <span class="keyword">[</span>1]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'    
    end
    def test_2_0
      input = <span class="keyword">[</span>0,1]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_2_1
      input = <span class="keyword">[</span>1,0]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_2_2
      input = <span class="keyword">[</span>1,1]
      expected = <span class="keyword">[</span>1,1]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_3_0
      input = <span class="keyword">[</span>0,1,2]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_1
      input = <span class="keyword">[</span>0,2,1]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_2
      input = <span class="keyword">[</span>2,1,0]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_3
      input = <span class="keyword">[</span>2,1,1]
      expected = <span class="keyword">[</span>1,1,2]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_4
      input = <span class="keyword">[</span>1,1,1]
      expected = <span class="keyword">[</span>1,1,1]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_4_0
      input = <span class="keyword">[</span>0,1,2,3]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_4_1
      input = <span class="keyword">[</span>3,1,2,0]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_4_2
      input = <span class="keyword">[</span>3,1,2,1]
      expected = <span class="keyword">[</span>1,1,2,3]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_10_0
      input = <span class="keyword">[</span>9,8,7,6,5,4,3,2,1,0]
      expected = <span class="keyword">[</span>0,1,2,3,4,5,6,7,8,9]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_10_1
      input = <span class="keyword">[</span>9,5,7,3,8,4,6,1,2,0]
      expected = <span class="keyword">[</span>0,1,2,3,4,5,6,7,8,9]
      assert_equal<span class="function"> SS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
  end
end
</code></pre>]]></content>
    
    <summary type="html">
    
      为什么知道原理还是写不出正确的程序呢？(系列)
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
      <category term="algorithm" scheme="http://judes.me/tags/algorithm/"/>
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="shell sort" scheme="http://judes.me/tags/shell-sort/"/>
    
  </entry>
  
  <entry>
    <title>写写插入排序</title>
    <link href="http://judes.me/2016/07/05/insertion-sort/"/>
    <id>http://judes.me/2016/07/05/insertion-sort/</id>
    <published>2016-07-05T00:06:17.000Z</published>
    <updated>2016-07-08T00:34:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个基础算法系列，主题是：为什么知道原理还是写不出正确的程序呢？</p>
<p>第一篇已经写好，叫做<a href="">我尝试去写快排，结果。。。</a>。文章结构都差不多：原理、联想、用法、框架、分步实现、完整代码及测试用例。</p>
<h2 id="原理">原理</h2><p>插入排序的原理是：</p>
<ul>
<li>将集合分为两个部分：已排好的部分和待排序的部分</li>
<li>每次从待排序部分抽一个元素跟已排好部分中的元素逐一比较，直到找到合适的位置，插入待排序元素</li>
<li>合适的位置可以是第一个比待排序元素小（大）的，也可能是已排好部分的下界</li>
</ul>
<h2 id="联想">联想</h2><ul>
<li>可以用一个数组下标将集合分成两部分，比下标小的是已排好部分，比下标大的是待排序部分</li>
<li>整个排序过程可以用嵌套两层循环，外层遍历待排序部分，内层遍历已排好部分</li>
<li>每次比较都有可能发生一次元素交换</li>
</ul>
<h2 id="用法">用法</h2><pre><code><span class="shebang">#!/usr/bin/env ruby</span>
sorted_array = IS.sort(array)
</code></pre><h2 id="大致框架">大致框架</h2><pre><code><span class="comment">#!/usr/bin/env ruby</span>
<span class="class"><span class="keyword">class</span> <span class="title">IS</span></span>
  <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span><span class="inheritance">&lt; <span class="parent">self</span></span></span>
    <span class="function"><span class="keyword">def</span> <span class="title">sort</span> <span class="title">array</span></span>
      <span class="keyword">while</span> condition1
        <span class="keyword">while</span> condition2

        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span> <span class="title">array</span>, <span class="title">i</span>, <span class="title">j</span></span>
      array[i], array[j] = array[j], array[i]
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h2 id="外层循环的上下界">外层循环的上下界</h2><p>容易想到外层循环的下界小于数组的大小，但上界是什么呢？选 0 是可以的，只是会浪费一次外层循环（因为它前面没有可比较元素），出于不浪费的考虑，选 1 。源码：</p>
<pre><code><span class="comment">#!/usr/bin/env ruby</span>
<span class="class"><span class="keyword">class</span> <span class="title">IS</span></span>
  <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span><span class="inheritance">&lt; <span class="parent">self</span></span></span>
    <span class="function"><span class="keyword">def</span> <span class="title">sort</span> <span class="title">array</span></span>
      <span class="comment"># 外层循环</span>
      index = <span class="number">1</span>
      len = array.size
      <span class="keyword">while</span> index &lt; len
        <span class="comment">#inner loop</span>
      index += <span class="number">1</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h2 id="内层循环要做什么？">内层循环要做什么？</h2><p>内层循环要做的就是把待排序元素的第一个元素通过一次次比较，放到已排序集合中合适的位置。循环的上界是外层循环中的 index ，下界是什么呢？ 因为每次都是与索引值小 1 的元素比较，为免数组越界，当前索引值最小是 1 。源码：</p>
<pre><code>#!/usr/bin/env ruby
<span class="keyword">class</span> <span class="keyword">IS</span>
  <span class="keyword">class</span> &lt;&lt; <span class="keyword">self</span>
    def sort <span class="keyword">array</span>
      <span class="keyword">index</span> = <span class="number">1</span>
      len = <span class="keyword">array</span>.size
      <span class="keyword">while</span> <span class="keyword">index</span> &lt; len
        inner_index = <span class="keyword">index</span>
        # 内层循环
        <span class="keyword">while</span> inner_index &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">array</span>[inner_index] &lt; <span class="keyword">array</span>[inner_index - <span class="number">1</span>]
          exchange(<span class="keyword">array</span>, inner_index, inner_index - <span class="number">1</span>)
          inner_index -= <span class="number">1</span>
        <span class="keyword">end</span>
        <span class="keyword">index</span> += <span class="number">1</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h2 id="完整的代码，加测试用例如下：">完整的代码，加测试用例如下：</h2><pre><code><span class="comment">#!/usr/bin/env ruby</span>
class IS
  class &lt;&lt; self
    def sort<span class="instruction"> array
</span>      index = 1
      len = array.size
      while index &lt; len
        inner_index = index
        while inner_index &gt;= 1 &amp;&amp; array<span class="keyword">[</span>inner_index] &lt; array<span class="keyword">[</span>inner_index-1]
         <span class="function"> exchange(</span>array, inner_index, inner_index-1<span class="function">)</span>
          inner_index -= 1
        end
        index += 1
      end
     <span class="instruction"> array
</span>    end
    def exchange array, i, j
      array<span class="keyword">[</span>i], array<span class="keyword">[</span>j] = array<span class="keyword">[</span>j], array<span class="keyword">[</span>i]
    end
  end
end
<span class="instruction">
if </span>__FILE__ == $0

  require 'test/unit'

  class TestIS &lt; Test::Unit::TestCase
    def test_0
      input = <span class="keyword">[</span>]
      expected = <span class="keyword">[</span>]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'empty<span class="instruction"> array </span>not equal'
    end
    def test_1_0
      input = <span class="keyword">[</span>0]
      expected = <span class="keyword">[</span>0]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'    
    end
    def test_1_1
      input = <span class="keyword">[</span>1]
      expected = <span class="keyword">[</span>1]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'one item<span class="instruction"> array </span>not equal'    
    end
    def test_2_0
      input = <span class="keyword">[</span>0,1]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_2_1
      input = <span class="keyword">[</span>1,0]
      expected = <span class="keyword">[</span>0,1]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_2_2
      input = <span class="keyword">[</span>1,1]
      expected = <span class="keyword">[</span>1,1]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'two items<span class="instruction"> array </span>not equal'    
    end
    def test_3_0
      input = <span class="keyword">[</span>0,1,2]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_1
      input = <span class="keyword">[</span>0,2,1]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_2
      input = <span class="keyword">[</span>2,1,0]
      expected = <span class="keyword">[</span>0,1,2]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_3
      input = <span class="keyword">[</span>2,1,1]
      expected = <span class="keyword">[</span>1,1,2]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_3_4
      input = <span class="keyword">[</span>1,1,1]
      expected = <span class="keyword">[</span>1,1,1]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'three items<span class="instruction"> array </span>not equal'    
    end
    def test_4_0
      input = <span class="keyword">[</span>0,1,2,3]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_4_1
      input = <span class="keyword">[</span>3,1,2,0]
      expected = <span class="keyword">[</span>0,1,2,3]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
    def test_4_2
      input = <span class="keyword">[</span>3,1,2,1]
      expected = <span class="keyword">[</span>1,1,2,3]
      assert_equal<span class="function"> IS.sort(</span>input<span class="function">)</span>, expected, 'four items<span class="instruction"> array </span>not equal'    
    end
  end
end
</code></pre>]]></content>
    
    <summary type="html">
    
      为什么知道原理还是写不出正确的程序呢？(系列)
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
      <category term="algorithm" scheme="http://judes.me/tags/algorithm/"/>
    
      <category term="insertion sort" scheme="http://judes.me/tags/insertion-sort/"/>
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>微信浏览器 location reload 失效解决办法</title>
    <link href="http://judes.me/2016/07/02/wechat-reload/"/>
    <id>http://judes.me/2016/07/02/wechat-reload/</id>
    <published>2016-07-02T14:45:16.000Z</published>
    <updated>2016-07-02T19:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司在微信企业号上开发了一个功能，用户通过这个功能完成一个个任务后可以获取奖励：</p>
<ul>
<li>用户首先进入页面 A 查看任务列表，列表中每一个任务都有各自的状态，一共有 5 个： 从状态 1 到状态 5 ；</li>
<li>用户点击页面 A 中的某个条目进入页面 B 查看任务详情，用户需要先后进行 5 个操作更新任务状态，每个操作都会刷新页面 B 。</li>
</ul>
<p>在微信开发者工具上测试一切正常。但测试 Android ——苹果上没有问题—— 真机就发现一个很严重的 BUG ：每个操作成功后页面 B 并不刷新。</p>
<p>刷新用的方法是简单的 <code>location.reload()</code> ，据网友反馈，失败的原因是微信浏览器缓存了 reload 请求。</p>
<p>一提到解决浏览器缓存问题，自然会想到给资源加上指纹。</p>
<p>这能解决问题，不过不管怎么说都是特殊处理： html 也加指纹，不希望应用到别处。也就是说，只针对 Android 微信浏览器使用。</p>
<p>首先判断请求是否来自 Android 微信浏览器：</p>
<pre><code><span class="keyword">var</span> isAndroidWechat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">return</span> (<span class="regexp">/android/i</span>).test(<span class="built_in">window</span>.navigator.userAgent) &amp;&amp; (<span class="regexp">/micromessenger/i</span>).test(<span class="built_in">window</span>.navigator.userAgent)
};
</code></pre><p>如果 isAndroidWechat 为 true ，则在 url 上加上指纹：</p>
<pre><code><span class="keyword">var</span> reload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">var</span> hash = +(<span class="keyword">new</span> <span class="built_in">Date</span>());
  <span class="keyword">var</span> new_search = (<span class="regexp">/wechat_hash/</span>).test(location.search) ? 
    <span class="comment">// 如果之前有添加过指纹，就更新它</span>
    location.search.replace(<span class="regexp">/wechat_hash=\d+(&amp;?)/</span>,<span class="string">'wechat_hash='</span> + hash + <span class="string">'$1'</span>) :
    <span class="comment">// 如果 search 为空</span>
    location.search == <span class="string">""</span> ?
    <span class="string">'?wechat_hash='</span> + hash :
    <span class="comment">// 如果 search 不为空</span>
    location.search + <span class="string">'&amp;wechat_hash='</span> + hash;
  <span class="comment">// 重新加载页面</span>
  location.reload(<span class="literal">true</span>);
}
</code></pre><p>这样看着还不错，不过很快就遇到新问题：如果在页面 B 先后进行了 4 次操作，这时点击后退按钮 ，还是会停留在页面 B ，要点击 4 次才能回到页面 A 。浏览器历史忠实地记录了我们先后 4 次更改 location.search 的操作。要立即返回页面 A ，我们还得更改历史：</p>
<pre><code><span class="keyword">var</span> reload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">var</span> hash = +(<span class="keyword">new</span> <span class="built_in">Date</span>());
  <span class="keyword">var</span> new_search = (<span class="regexp">/wechat_hash/</span>).test(location.search) ? 
    <span class="comment">// 如果之前有添加过指纹，就更新它</span>
    location.search.replace(<span class="regexp">/wechat_hash=\d+(&amp;?)/</span>,<span class="string">'wechat_hash='</span> + hash + <span class="string">'$1'</span>) :
    location.search == <span class="string">""</span> ?
    <span class="comment">// 如果 search 为空</span>
    <span class="string">'?wechat_hash='</span> + hash :
    <span class="comment">// 如果 search 不为空</span>
    location.search + <span class="string">'&amp;wechat_hash='</span> + hash;
  <span class="comment">// 修改浏览器历史</span>
  <span class="keyword">var</span> current_title = <span class="built_in">document</span>.title;
  <span class="keyword">var</span> new_uri = location.origin + location.pathname + new_search;
  history.replaceState(<span class="literal">null</span>, current_title, new_uri);
  <span class="comment">// 重新加载页面</span>
  location.reload(<span class="literal">true</span>);
};
</code></pre><p>最后，完成的代码及测试例子已上传到 <a href="https://github.com/yiyizym/wechat_reload" target="_blank" rel="external">github</a> 。</p>
]]></content>
    
    <summary type="html">
    
      微信自家浏览器总有莫名其妙的 bug
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
      <category term="reload" scheme="http://judes.me/tags/reload/"/>
    
      <category term="微信" scheme="http://judes.me/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="浏览器" scheme="http://judes.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>我尝试去写快排，结果。。。</title>
    <link href="http://judes.me/2016/06/23/see-how-i-write-quick-sort/"/>
    <id>http://judes.me/2016/06/23/see-how-i-write-quick-sort/</id>
    <published>2016-06-23T12:56:50.000Z</published>
    <updated>2016-07-05T00:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>《编程珠玑》第 32 页，提到：“尽管第一个二分查找程序于1946年就已经公布了，但是第一个没有 bug 的二分查找程序在 1962 年才出现。”还说参加课堂测试的专业程序员中， 90% 写的二分查找程序都有 bug 。</p>
<p>真的有那么难吗？我心血来潮，动手写起了快排（不要问为什么不是二分查找）。隐约记得快排的原理如下：</p>
<ul>
<li>在要排序的元素集合中选定一个元素作比较标杆；其他元素分别与此标杆比较，比它小的放在标杆前面，比它大的放在它后面；</li>
<li>这样集合就一分为二，对这两部分分别应用步骤一的方法，直到每部分只有一个元素。</li>
</ul>
<p>简单地写几个测试用例。结果第二个测试就跑不过。<strong>为什么知道原理还是写不出正确的程序呢？</strong></p>
<p>聪明的人很快就能调试好出错的程序；记忆力好的，大概见过一次正确的写法后就不会忘。可惜普通人这两样都不占。</p>
<p>那如果普通人的目标是以后能很快地写出快排，应该怎样做呢？我暂时能想到：</p>
<ul>
<li><p>在原理之上唤醒更多写快排的基本算法思想：一分为二用到分治法；算法会反复用到步骤一，所以有递归；算法不需要额外空间。</p>
</li>
<li><p>用少量的待排序元素辅助书写算法。</p>
</li>
<li><p>用测试用例保证算法正确性。</p>
</li>
</ul>
<p>根据这个思路，首先要定义使用快排程序的方法：</p>
<pre><code><span class="shebang">#!/usr/bin/env ruby</span>
sorted_array = QS.sort(array)
</code></pre><p>然后定义程序的大致框架：</p>
<pre><code><span class="comment">#!/usr/bin/env ruby</span>

module QS
  extend self
  def sort<span class="instruction"> array
</span>    inner_sort array, 0, array.size - 1
   <span class="instruction"> array
</span>  end
  def inner_sort array, low_pos, hight_pos
  end
  def divide array, low_pos, hight_pos
  end
  def exchange array, i, j
  end

end
</code></pre><p>inner_sort 跟 divide 为什么要接受两个位置参数？我们没有额外储存空间可用，所以要用上下边界划定排序的作用范围。inner_sort 没有返回值，而 divide 要返回一个位置，确立递归排序的界限。exchange 用来交换元素。</p>
<p>开始写 inner_sort ：</p>
<pre><code><span class="preprocessor">#!/usr/bin/env ruby</span>

module QS
  ...

  def inner_sort <span class="built_in">array</span>, low_pos, hight_pos
    <span class="keyword">return</span> <span class="keyword">if</span> low_pos &gt;= hight_pos
    division = divide <span class="built_in">array</span>, low_pos, hight_pos
    inner_sort <span class="built_in">array</span>, low_pos, division - <span class="number">1</span>
    inner_sort <span class="built_in">array</span>, division + <span class="number">1</span>, hight_pos
  end

  ...

end
</code></pre><p>程序会递归调用 inner_sort 。写递归要注意两点：</p>
<ul>
<li>递归要有终止条件</li>
<li>每次递归都要朝着终止条件迈一步</li>
</ul>
<p>接下来写 divide ：</p>
<pre><code>#!/usr/bin/env ruby

<span class="keyword">module</span> <span class="type">QS</span>
  ...

  def divide <span class="built_in">array</span>, low_pos, hight_pos
    target = <span class="built_in">array</span>[low_pos]
    lo = low_pos
    hi = hight_pos
    <span class="keyword">while</span> low_pos &lt; hight_pos
      <span class="keyword">while</span> <span class="built_in">array</span>[low_pos] &lt;= target &amp;&amp; low_pos &lt; hi
        low_pos += <span class="number">1</span>
      <span class="keyword">end</span>
      <span class="keyword">while</span> <span class="built_in">array</span>[hight_pos] &gt;= target &amp;&amp; hight_pos &gt; lo
        hight_pos -= <span class="number">1</span>
      <span class="keyword">end</span>
      exchange(<span class="built_in">array</span> low_pos, hight_pos) <span class="keyword">if</span> low_pos &lt; hight_pos
    <span class="keyword">end</span>
    exchange(<span class="built_in">array</span>, lo, hight_pos)
    hight_pos
  <span class="keyword">end</span>

  ...

<span class="keyword">end</span>
</code></pre><p>divide 方法是快排中最难写、最容易出错的，为免出错：</p>
<ul>
<li>要记住重排元素的技巧<br>  从待排序集合的头部开始找到一个比标杆元素大的，从尾部开始找到一个比标杆元素小的，然后交换两者位置</li>
<li>要正确写出比较、查找的上下界限<br>  在遍历元素时要注意数组越界问题和交换元素位置的附加条件： low_pos 必须小于 hight_pos</li>
<li>最后要把标杆元素与某个元素交换位置<br>  把标杆元素摆到中间，至于是通过跟 low_pos 还是跟 hight_pos 交换达到这个目的。可以用简单的例子（这个例子是尝试出来的，记不住也没关系）确定，假设待排序的元素集是 <code>[2,1,3]</code>，很容易就能得到要跟 hight_pos 交换。</li>
</ul>
<p>把 exchange 方法补充好，测试用例也写上，完整的程序是这样的：</p>
<pre><code><span class="comment">#!/usr/bin/env ruby</span>
<span class="comment"># usage QS.sort(array) =&gt; sorted array</span>

module QS
  extend self

  def sort<span class="instruction"> array
</span>    inner_sort array, 0, array.size - 1
   <span class="instruction"> array
</span>  end

  def inner_sort array, low_pos, hight_pos
   <span class="instruction"> return </span>if low_pos &gt;= hight_pos
    division = divide array, low_pos, hight_pos
    inner_sort array, low_pos, division - 1
    inner_sort array, division + 1, hight_pos
  end

  def divide array, low_pos, hight_pos
    target = array<span class="keyword">[</span>low_pos]
    lo = low_pos
    hi = hight_pos
    while low_pos &lt; hight_pos
      while array<span class="keyword">[</span>low_pos] &lt;= target &amp;&amp; low_pos &lt; hi
        low_pos += 1
      end
      while array<span class="keyword">[</span>hight_pos] &gt;= target &amp;&amp; hight_pos &gt; lo
        hight_pos -= 1
      end
     <span class="function"> exchange(</span>array low_pos, hight_pos<span class="function">)</span><span class="instruction"> if </span>low_pos &lt; hight_pos
    end
   <span class="function"> exchange(</span>array, lo, hight_pos<span class="function">)</span>
    hight_pos
  end

  def exchange array, i, j
    array<span class="keyword">[</span>i], array<span class="keyword">[</span>j] = array<span class="keyword">[</span>j], array<span class="keyword">[</span>i]
  end

end
<span class="instruction">
if </span>__FILE__ == $0
  require 'test/unit'
  class TestQS &lt; Test::Unit::TestCase
    def test_0
     <span class="instruction"> array </span>= <span class="keyword">[</span>]
      expected = <span class="keyword">[</span>]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_1
     <span class="instruction"> array </span>= <span class="keyword">[</span>1]
      expected = <span class="keyword">[</span>1]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_2_0
     <span class="instruction"> array </span>= <span class="keyword">[</span>1,2]
      expected = <span class="keyword">[</span>1,2]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_2_1
     <span class="instruction"> array </span>= <span class="keyword">[</span>2,1]
      expected = <span class="keyword">[</span>1,2]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_2_2
     <span class="instruction"> array </span>= <span class="keyword">[</span>1,1]
      expected = <span class="keyword">[</span>1,1]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_0
     <span class="instruction"> array </span>= <span class="keyword">[</span>1,2,3]
      expected = <span class="keyword">[</span>1,2,3]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_1
     <span class="instruction"> array </span>= <span class="keyword">[</span>1,3,2]
      expected = <span class="keyword">[</span>1,2,3]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_2
     <span class="instruction"> array </span>= <span class="keyword">[</span>3,2,1]
      expected = <span class="keyword">[</span>1,2,3]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_3
     <span class="instruction"> array </span>= <span class="keyword">[</span>2,1,3]
      expected = <span class="keyword">[</span>1,2,3]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_4
     <span class="instruction"> array </span>= <span class="keyword">[</span>1,1,2]
      expected = <span class="keyword">[</span>1,1,2]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_5
     <span class="instruction"> array </span>= <span class="keyword">[</span>1,1,1]
      expected = <span class="keyword">[</span>1,1,1]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_6
     <span class="instruction"> array </span>= <span class="keyword">[</span>1,2,1]
      expected = <span class="keyword">[</span>1,1,2]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
    def test_3_7
     <span class="instruction"> array </span>= <span class="keyword">[</span>2,1,1]
      expected = <span class="keyword">[</span>1,1,2]
      assert_equal expected,<span class="function"> QS.sort(</span>array<span class="function">)</span>
    end
  end
end
</code></pre>]]></content>
    
    <summary type="html">
    
      为什么知道原理还是写不出正确的程序呢？
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
      <category term="algorithm" scheme="http://judes.me/tags/algorithm/"/>
    
      <category term="quick sort" scheme="http://judes.me/tags/quick-sort/"/>
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>sinatra 0.0.1 源码学习</title>
    <link href="http://judes.me/2016/06/12/sinatra-learning-0-0-1/"/>
    <id>http://judes.me/2016/06/12/sinatra-learning-0-0-1/</id>
    <published>2016-06-12T12:14:30.000Z</published>
    <updated>2016-07-10T06:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>本文系 <strong>sinatra 源码系列</strong>第 1 篇。系列的目的是通过 sinatra 学习 ruby 编程技巧。文章按程序运行的先后顺序挑重点分析，前一篇文章分析过的略去不说。水平很有限，所写尽量给出可靠官方/讨论链接，不坑路人。</p>
<h2 id="重要提醒">重要提醒</h2><p><strong>一定要先安装 1.8 版本的 ruby</strong> ，因为 1.9+ 的 ruby ，String 的实例是不响应 each 方法的，这会直接导致 rack 报错。可以使用 <a href="https://rvm.io/" target="_blank" rel="external">rvm</a> 安装 1.8.7 版本的 ruby ，如果使用 rvm ，请先升级到最新版本，否则安装 1.8.7 的 ruby 时也会报错。</p>
<p>列一下本人运行 sinatra 0.0.1 用到的 ruby 和关键 gem 的版本：</p>
<ul>
<li>ruby-1.8.7-p374</li>
<li>rack 1.4.1</li>
<li>mongrel 1.1.5</li>
</ul>
<h2 id="前期准备">前期准备</h2><p>把 <a href="https://github.com/sinatra/sinatra" target="_blank" rel="external">sinatra</a>克隆下来，用 <code>git tag</code> 可以看到最开始的版本是 0.0.1 。</p>
<p>checkout 到 0.0.1 分支可以看到目录十分简单</p>
<pre><code>├── examples
│   └── hello
│       ├── test<span class="class">.rb</span>
│       └── views
│           └── index<span class="class">.erb</span>
├── files
│   ├── default_index<span class="class">.erb</span>
│   └── not_found<span class="class">.erb</span>
├── lib
│   ├── sinatra
│   │   ├── core_ext
│   │   │   ├── class<span class="class">.rb</span>
│   │   │   └── hash<span class="class">.rb</span>
│   │   ├── dispatcher<span class="class">.rb</span>
│   │   ├── dsl<span class="class">.rb</span>
│   │   ├── event<span class="class">.rb</span>
│   │   ├── logger<span class="class">.rb</span>
│   │   └── server<span class="class">.rb</span>
│   └── sinatra<span class="class">.rb</span>
├── test
│   ├── helper<span class="class">.rb</span>
│   └── sinatra
│       ├── dispatcher_test<span class="class">.rb</span>
│       └── event_test<span class="class">.rb</span>
└── vendor
    └── erb
        ├── init<span class="class">.rb</span>
        └── lib
            └── erb<span class="class">.rb</span>

<span class="number">12</span> directories, <span class="number">17</span> files
</code></pre><p>跳到 examples/hello 目录下运行 <code>ruby test.rb</code> ，用浏览器打开 localhost:4567 便看到一个提交表单的页面。把文件里的路由都玩一遍，就能感觉到 sinatra 麻雀虽小，但五脏俱全。</p>
<p>test.rb 采用 <code>$LOAD_PATH.unshift &#39;../../lib/&#39;</code> 把 lib 目录放进加载路径中。</p>
<p>这种写法会导致如果在别的目录下，比如根目录，执行 <code>ruby examples/hello/test.rb</code> 报错，可以改为：</p>
<p><code>$LOAD_PATH.unshift File.expand_path(&#39;../../lib&#39;,File.dirname(__FILE__))</code></p>
<h2 id="rubygems_和_rack">rubygems 和 rack</h2><p>根据 lib/sinatra/sinatra.rb 里加载文件的顺序，逐一看看这个版本的 sinatra 做了些什么。</p>
<p>sinatra.rb 第1到7行加载 两个 gem</p>
<pre><code><span class="string">%w(rubygems rack)</span>.each <span class="keyword">do</span> |library|
  <span class="keyword">begin</span>
    <span class="keyword">require</span> library
  <span class="keyword">rescue</span> <span class="constant">LoadError</span>
    raise <span class="string">"== Sinatra cannot run without <span class="subst">#{library}</span> installed"</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><ul>
<li><p>rubygems 对 ruby 1.9+ 来说已经是多余的，见<a href="http://guides.rubygems.org/patterns/#requiring_rubygems" target="_blank" rel="external">链接</a></p>
</li>
<li><p>rack 是 sinatra 以及 rails 的基础，简介以及基本用法见<a href="http://rack.github.io/" target="_blank" rel="external">官网</a>，用一句话描述 rack ：为 web 服务器向 ruby 应用提供简洁的接口。再详细点描述怎样应用 rack ：</p>
<ul>
<li>运行 rack 时需要提供一个能响应 call 方法的对象</li>
<li>这个对象的 call 方法必须返回一个包含三个元素的数组</li>
<li>这个返回数组第一个元素是 http 状态码，第二个是 http 响应头，第三个是 http body 对象</li>
<li>body 对象要求能响应 each 方法</li>
</ul>
</li>
</ul>
<h2 id="核心扩展_core_ext">核心扩展 core_ext</h2><p>接下来 sinatra 加载两个核心扩展 core_ext/class.rb 以及 core_ext/hash.rb</p>
<p><strong> class.rb </strong></p>
<p>ruby 内置了 <code>attr_reader/attr_writer/attr_accessor</code> 方法，可以方便地在类实例中生成 getter/setter 方法，core_ext/class.rb 重新打开了 Class 类，对应地在类中生成 getter/setter 方法。</p>
<p><code>class_eval</code> 在这当中起到重要作用。</p>
<p>在 class.rb 中，因为没有显式调用 <code>class_eval</code> ，其 receiver 会指向 self ，而当前的 self 就是 Class 类的实例，即普通类，假设为 class 。 <code>class_eval</code> 把 self 指向 class ，也会重新打开 class ，当你需要动态地为类添加方法时很有用。如下例：</p>
<pre><code><span class="comment">#!/usr/bin/env ruby</span>
class <span class="type">TestClassEval</span>
<span class="keyword">end</span>

<span class="type">TestClassEval</span>.class_eval <span class="keyword">do</span> 
  def instance_method
    P 'instance <span class="keyword">method</span>'
  <span class="keyword">end</span>
  def self.class_method
    p 'class <span class="keyword">method</span>'
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="type">TestClassEval</span>.class_method <span class="comment"># 'class method'</span>
<span class="type">TestClassEval</span>.new.instance_mehtod <span class="comment"># 'instance method'</span>
<span class="type">TestClassEval</span>.instance_mehtod <span class="comment"># NoMethodError</span>
</code></pre><p>顺便说说 <code>instance_eval</code> ，<code>instance_eval</code> 把 self 指向 实例 ，也会重新打开实例的 singleton class ，为其添加单例方法，继续用上面的 TestClassEval 作例，下面的写法在其上定义了另一个类方法。</p>
<pre><code><span class="comment">#!/usr/bin/env ruby</span>
<span class="type">TestClassEval</span>.instance_eval <span class="keyword">do</span>
  def another_class_method
    p 'another class <span class="keyword">method</span>'
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="type">TestClassEval</span>.another_class_method <span class="comment"># 'another class method'  </span>
</code></pre><p><strong> hash.rb </strong></p>
<p>hash.rb 里使用了 inject 方法 symbolize  hash 的 key </p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">symbolize_keys</span></span>
  <span class="keyword">self</span>.inject({}) { |h, (k, v)| h[k.to_sym] = v;h}
<span class="keyword">end</span>
</code></pre><h2 id="事件处理_event-rb">事件处理 event.rb</h2><p><strong> EventManager </strong></p>
<p>EventManager 模块里有一个 extend self 方法调用，值得学习。</p>
<p>extend 方法是把 module 的实例方法加入到 class 的类单例方法中，其常规用法如下：</p>
<pre><code>module M
  def p_method
    p '<span class="keyword">method</span>'
  <span class="keyword">end</span>
<span class="keyword">end</span>

class C
  extend M
<span class="keyword">end</span>

C.p_method <span class="comment"># 'method'</span>
</code></pre><p>如果不使用 extend ，也有其他途径的实现，如下：</p>
<pre><code><span class="class"><span class="keyword">module</span> <span class="title">M</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">p_method</span></span>
    p <span class="string">'method'</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="class"><span class="keyword">class</span> <span class="title">D</span></span>
  <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span><span class="inheritance">&lt; <span class="parent">self</span></span></span>
    <span class="keyword">include</span> <span class="constant">M</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="constant">D</span>.p_method <span class="comment"># 'method'</span>
</code></pre><p>在 EventManager 中，self 指向 module 自身， 因此 extend self 是用来高效地生成单例方法，可见<a href="http://ozmm.org/posts/singin_singletons.html" target="_blank" rel="external">链接</a> </p>
<p><strong> EventContext </strong></p>
<p>为 block 提供执行上下文， block 借此可以访问 request/params ，可以设置和访问 status/headers/body</p>
<p>这里用到 alias, <code>alias :header :headers</code> ， ruby 中类似的用法还有 alias_method ，如果使用 alias_method ，要这样写 <code>alias_method :header, :headers</code> ，多一个逗号。</p>
<p>alias 与 alias_method 还有其他区别，前者是关键字，后者是定义在 Module 的方法，这意味着 alias_method 可以被重写；调用 alias 时，其 self 是在定义时就已经决定下来，而 alias_method 的 self 是在运行时才决定的，见下面的例子<a href="http://blog.bigbinary.com/2012/01/08/alias-vs-alias-method.html" target="_blank" rel="external">(出自)</a>:</p>
<pre><code><span class="comment"># alias_method</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>

  <span class="function"><span class="keyword">def</span> <span class="title">full_name</span></span>
    puts <span class="string">"Johnnie Walker"</span>
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">add_rename</span></span>
    alias_method <span class="symbol">:name</span>, <span class="symbol">:full_name</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="inheritance">&lt; <span class="parent">User</span></span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">full_name</span></span>
    puts <span class="string">"Geeky geek"</span>
  <span class="keyword">end</span>
  add_rename
<span class="keyword">end</span>

<span class="constant">Developer</span>.new.name <span class="comment">#=&gt; 'Gekky geek'</span>

<span class="comment"># alias</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>

  <span class="function"><span class="keyword">def</span> <span class="title">full_name</span></span>
    puts <span class="string">"Johnnie Walker"</span>
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">add_rename</span></span>
    <span class="keyword">alias</span> <span class="symbol">:name</span> <span class="symbol">:full_name</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="inheritance">&lt; <span class="parent">User</span></span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">full_name</span></span>
    puts <span class="string">"Geeky geek"</span>
  <span class="keyword">end</span>
  add_rename
<span class="keyword">end</span>

<span class="constant">Developer</span>.new.name <span class="comment">#=&gt; 'Johnnie Walker'</span>
</code></pre><p>基于上面的介绍，社区推荐使用 alias_method 。</p>
<p><strong> Event </strong></p>
<p>Event 在定义 initialize 方法时<strong>最后一个参数</strong>是 <code>&amp;block</code> ，这表明在调用 Event.new 时如果接收到一个 block ，用 &amp; 操作符把 block 转化为 proc 之后，在 initialize 方法内部可以调用 proc 的 call 方法。</p>
<p>如果没有在方法内部调用 call 方法的需求，或者没有把 block 当成变量传给别的方法的需求，就没必要在定义方法时写上 &amp;block ，直接用 yield 关键字调用就行。</p>
<p>可以用 &amp; 把 proc 转变为 block 。这个技巧用在 attend 方法里面，因为 instance_eval 只有<a href="http://ruby-doc.org/core-1.9.3/BasicObject.html#method-i-instance_eval" target="_blank" rel="external">两种调用方式</a>：要么接收一个字符串，要么接收一个 block ，所以要把 proc 转变为 block 当作参数传进去。</p>
<p>如果跟在 &amp; 操作符后面的对象不是 proc ，&amp; 会调用跟在它后面的对象的 :to_proc 方法。 symbol 对象也有自己的 :to_proc 方法，你经常能看到类似下面的代码：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">tag_names</span></span>
  <span class="variable">@tag_names</span> || tags.map(&amp;<span class="symbol">:name</span>).join(<span class="string">' '</span>)
<span class="keyword">end</span>
</code></pre><p>事实上这跟下面的代码是等效的：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">tag_names</span></span>
  <span class="variable">@tag_names</span> || tags.map({ |tag| tag.name }).join(<span class="string">' '</span>)
<span class="keyword">end</span>
</code></pre><p>symbol 对象的 :to_proc 方法最早是 Rails 引进的，后面合并到 ruby 1.8.7 版本：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Symbol</span></span>
  <span class="function"><span class="keyword">def</span> <span class="title">to_proc</span></span>
    <span class="constant">Proc</span>.new <span class="keyword">do</span> |obj, *args|
      obj.send <span class="keyword">self</span>, *args
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>上面整个例子都出自 <a href="http://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby" target="_blank" rel="external">stackoverflow</a></p>
<p>关于 &amp; ，更多资料可以看看<a href="http://weblog.raganwald.com/2008/06/what-does-do-when-used-as-unary.html" target="_blank" rel="external">这篇文章</a></p>
<h2 id="路由请求，封装响应_dispatcher-rb">路由请求，封装响应 dispatcher.rb</h2><p>dispatcher 负责将请求转发到对应的 event ，经 event 处理后，返回符合 rack 要求的响应。</p>
<p>rack 会直接调用 dispatcher 的 call 方法，传入 env ，利用 rack <a href="http://www.rubydoc.info/gems/rack/Rack/Request" target="_blank" rel="external">提供的方法</a>可以得到 request 对象。</p>
<p>用 array 的 detect 方法实现转发功能， detect 接受一个 <a href="http://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-detect" target="_blank" rel="external">ifnone 参数</a>，如果找不到合适的 event ，就调用 ifnone 的 call 方法，将 call 方法的返回值作为 detect 的返回值，借此实现大家都熟悉的 404 。</p>
<p>这里的 ifnone 是一个 lambda</p>
<pre><code><span class="title">lambda</span> { <span class="title">not_found</span> }
</code></pre><p>调用 lambda 的 call 会执行 not_found 方法，而 not_found 返回一个 Event 实例。</p>
<h2 id="server-rb">server.rb</h2><p><a href="https://github.com/rack/rack/tree/2.0.0.alpha" target="_blank" rel="external">rack 2.0</a> 开始不支持 Mongrel 的 handler 。</p>
<p><code>trap(&quot;INT&quot;) do ... end</code> 这段代码会捕获用户输入的 <code>ctrl + c</code> ，从而调用 Mongrel::HttpServer 的 <a href="https://github.com/mongrel/mongrel/blob/master/lib/mongrel.rb#L344" target="_blank" rel="external">stop</a> 方法。</p>
<h2 id="dsl-rb">dsl.rb</h2><p>重新打开 Kernel ，增加 4 个 http 方法。</p>
<p>所有 ruby 类（除了 BasicObject）都继承模块 Kernel ，这意味着一旦 require 这个文件，就连字符串都带这4个方法。</p>
<p>可以打开 irb 验证一下，查看类的祖先链的方法是 ancestors ，如 <code>String.ancestors</code></p>
<h2 id="erb">erb</h2><p><strong> init.rb </strong> 里有这样一行：</p>
<pre><code><span class="constant">Sinatra:</span><span class="symbol">:EventContext</span>.send(<span class="symbol">:include</span>, <span class="constant">Sinatra:</span><span class="symbol">:Erb</span><span class="symbol">:</span><span class="symbol">:InstanceMethods</span>)
</code></pre><p>ruby 里的方法调用其实就是向被调用方发送（send）一个方法，所以被调用方又叫 receiver 。 EventContext include 了 Erb::InstanceMethods ，就是把 Erb::InstanceMethods 插入到 EventContext 继承链的父亲节点，这样 EventContext 的实例就都可以调用 Erb::InstanceMethods 里面的方法。你也可以直接打开 EventContext 达到同样的目的：</p>
<pre><code>class <span class="constant">Sinatra:</span><span class="symbol">:EventContext</span>
  <span class="keyword">include</span> <span class="constant">Sinatra:</span><span class="symbol">:Erb</span><span class="symbol">:</span><span class="symbol">:InstanceMethods</span>
<span class="keyword">end</span>
</code></pre><p><strong> erb.rb </strong></p>
<p>erb.rb 实现找到正确的模板，然后把渲染后的值赋给 EventContext 的实例变量 @body。</p>
<p>在找模板时使用到一个全局变量 <code>$0</code> ，官方文档的<a href="http://ruby-doc.org/core-2.0.0/doc/globals_rdoc.html" target="_blank" rel="external">描述</a>： </p>
<blockquote>
<p>Contains the name of the script being executed. May be assignable.</p>
</blockquote>
<p>可以用它来实现类似 Python 判断当前文件是否被直接运行的功能（用来写测试用例）：</p>
<pre><code><span class="keyword">if</span> __FILE_<span class="number">_</span> == <span class="variable">$0</span>
  <span class="comment"># code goes here</span>
<span class="keyword">end</span>
</code></pre><p>sinatra 用它来实现寻找模板的默认路径。</p>
<p>ERB 的 result 方法接收一个 binding 参数，默认值是 TOPLEVEL_BINDING 。 binding 是 Kernel 的方法，它会返回 当前作用域(local scope)。因为 binding 是在 EventContext 的某个实例里面运行，它返回的是那个实例的作用域，所以可以访问实例变量及实例方法，如 params 。举例如下：</p>
<pre><code>class <span class="constant">MyClass</span>
  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(x)
    <span class="variable">@x</span> = x
  <span class="keyword">end</span>
  <span class="function"><span class="keyword">def</span> <span class="title">get_binding</span></span>
    binding
  <span class="keyword">end</span>
  <span class="function"><span class="keyword">def</span> <span class="title">print</span></span>
    p <span class="string">'print out something'</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

my_instance = <span class="constant">MyClass.</span>new(<span class="number">1</span>)
my_binding = my_instance.get_binding

eval <span class="string">'@x'</span>, b <span class="comment"># 1</span>
eval <span class="string">'print'</span>, b <span class="comment"># 'print out something'</span>
</code></pre><h2 id="最后，_at_exit">最后， at_exit</h2><p>at_exit 也是 Kernel 里的方法，它接受一个 block ，并将其转换成 Proc ，当程序退出时会调用 Proc 。如果调用了多次 at_exit 。那么这些 Proc 按倒序执行，如：</p>
<pre><code>at_<span class="built_in">exit</span> <span class="keyword">do</span>
  puts <span class="string">'再见！'</span>
end

at_<span class="built_in">exit</span> <span class="keyword">do</span>
  puts <span class="string">'已经写完，'</span>
end

at_<span class="built_in">exit</span> <span class="keyword">do</span>
  <span class="built_in">print</span> <span class="string">'sinatra 0.0.1 版本源码学习'</span>
end
</code></pre>]]></content>
    
    <summary type="html">
    
      通过 sinatra 学习 ruby 编程技巧（系列）
    
    </summary>
    
      <category term="ruby" scheme="http://judes.me/categories/ruby/"/>
    
    
      <category term="ruby" scheme="http://judes.me/tags/ruby/"/>
    
      <category term="sinatra" scheme="http://judes.me/tags/sinatra/"/>
    
  </entry>
  
</feed>
