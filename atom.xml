<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jude&#39;s life</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://judes.me/"/>
  <updated>2017-01-23T03:48:42.000Z</updated>
  <id>http://judes.me/</id>
  
  <author>
    <name>jude zhu</name>
    <email>yiyizym@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我所经历的敏捷开发</title>
    <link href="http://judes.me/2017/01/23/my-so-call-agile/"/>
    <id>http://judes.me/2017/01/23/my-so-call-agile/</id>
    <published>2017-01-23T03:36:06.000Z</published>
    <updated>2017-01-23T03:48:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 以下关于敏捷开发的内容，只是我个人经历和感想，没打算说点“正确”的话，看官觉得我说的错得离谱的话，大可以认为我经历的是假的敏捷开发 </strong></p>
]]></content>
    
    <summary type="html">
    
      从慢慢建立，到彻底崩坏
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
      <category term="工作" scheme="http://judes.me/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="感想" scheme="http://judes.me/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="敏捷开发" scheme="http://judes.me/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>科学说需求 读书笔记</title>
    <link href="http://judes.me/2017/01/18/%E7%A7%91%E5%AD%A6%E8%AF%B4%E9%9C%80%E6%B1%82/"/>
    <id>http://judes.me/2017/01/18/科学说需求/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-08-01T08:31:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>张五常的经济学说对本人影响很大，重读他的《科学说需求》卷一，希望能对这门学说有新的感悟。同时想让对经济学感兴趣的朋友瞧瞧这门非主流但解释力一流的学说，本人认为《科学说需求》卷一最适合经济学入门。</p>
<p>神州版序<br>  张五常喜欢在文章中提及他的师友，当中获得诺贝尔经济学奖的有 费里德曼、科斯、施蒂格勒。</p>
<p>  他还喜欢说自己在中年时决定“少读书甚至不读他家之作，喜欢独自思考”。之所以不读他家之作，是因为他读到过的著作“中所说的所谓事实，大部分没有依凭，有些书引用的全部是假”。</p>
<p>  “世界复杂，我把经济理论简化到只剩需求定律”。有点大道至简的感觉，不过他用了整本书的篇幅来阐述需求定律的应用又显得一点都不简单。</p>
<p>原序<br>  “在科学的范畴内，问题来来去去只有一条：为什么？是的，‘怎么办’是工程学的问题，而‘好不好’则是伦理上的问题了。”<br>  张五常画了一个圈，他所认同的经济学不得越此雷池半步，即经济学关注和回答的是“为什么”，而不是“怎么办”，更不是“好不好”。大众在谈及经济学现象时，张嘴就评论“好不好”，继而提出“怎么办”，全然不顾“为什么”，恰恰与张五常背道而驰。</p>
<p>  “我决定了一幅图表、一条方程式也不用”。向斯密致敬，这是我认为此书最适合经济学入门的原因之一。但很快我就看到了一条方程式，orz</p>
<p>  “某部分看不懂，跳到看得懂的地方吧。”</p>
<p>第一章 科学的方法</p>
<p>  “科学不是求对，也不是求错：科学所求的是‘可能被事实推翻’。可能被事实推翻而没有被推翻，就算是被证实了”。</p>
<p>  即科学是可推翻的，不科学就是不可推翻的。</p>
<p>第一节 现象必有规律</p>
<p>  “僭建的房子没有地权，比有地权的房子简陋得多了。”就似地摊货的质量比不上专柜货，怎样用经济学解释这个现象呢？</p>
<p>  科学的三个重要信念（共识）：<br>  1.“凡是现象或行为，其存在是靠主观的判断，而大家不能在这主观上有分歧。”<br>  2.“所有被众所认同的现象，都是有迹可寻，有规律的。”<br>  3.“一定要坚信任何事情的发生不会是无缘无故的。”</p>
<p>  很多时候在吵架的最后关头时，才发现不满足上面的第一条。</p>
<p>第二节 事实不能解释事实</p>
<p>  如题，否则还要理论来干什么？</p>
<p>第三节 特殊理论与套套逻辑</p>
<p>  科学的理论是可被推翻的。如果某个理论被推翻了，是不是就可以说这个理论是错误的呢？是不是这个理论就不能用呢？<br>  不是这样的，举个工（理）科生都知道的例子：牛顿第二定律在20世纪之前都是可推翻（只要你找到 F != ma 的例子）而没有被推翻的正确理论，在相对论面世之后，人们证实在接近光速时 F != ma，于是牛顿第二定律被推翻了。但牛顿第二定律至今还被广泛应用，也不被认为是错误的，原因是我们打了个补丁——在低速环境中——使它成立。</p>
<p>  科学理论的进化之路就是：提出可被推翻的理论，被推翻，打补丁，再被推翻，再打补丁……直到有朝一日这个理论，就像衣服全身都是补丁不能穿，走到生命的尽头。</p>
<p>  全身满是补丁的衣服也不是不能穿，至少你能看到流浪汉在穿。这是一个特殊的例外，没有普遍性。</p>
<p>  张五常称这种“满是补丁”的理论为特殊理论，它谈不上有一般性的解释能力。他认为“科学的进步，不是因为对的理论替代了错的，而是有较广泛解释力的，替代了较狭窄的。”</p>
<p>  与特殊理论相对的是套套逻辑，套套逻辑“不可能错，因为没有内容”，没有内容指不能从中获取信息，比如“四足动物有四只脚”。因为不可能错，所以不能被推翻，所以套套逻辑不是科学理论。</p>
<p>  “特殊理论内容太多了，而套套逻辑则没有内容。可取的理论，一定是在特殊理论与套套逻辑之间。”</p>
<p>  他提到弗里德曼写下的一则评语：“愚蠢的问题，当然会得到愚蠢的答案！”，让我联想到最近比较热门的问题：党大还是法大？对党来说，这是个愚蠢的问题，我们当然会得到愚蠢的答案。（会不会被和谐呢。。。）</p>
<p>第四节 可能被事实推翻的重要性</p>
<p>  张五常把 可被推翻 排在所有科学方法要素的首位。</p>
<p>  他所举“白痴开汽油站”的例子十分有意思：<br>  1.经济学假设每个人都会明智地争取自身最大的利益。但白痴显然不明智，所以假设是错的。<br>  2.话说有一群白痴觉得开加油站很好玩，都跑去开加油站，他们不懂得选址，有的把加油站开在深山老林中，有的开在大海上，也有的糊里糊涂地开在了公路边。过了不久，选址不好的因没有客源都倒闭了，只有开在公路边上的活下来。<br>  3.前面提到每个人都会明智地争取自身最大的利益的假设是错的。用这个假设来选址得出加油站最合适的地址是公路边上却与事实不谋而合。</p>
<p>  这个例子也可以用在张五常经济学说本身，这个学说很非主流，没有数学模型来准确描述经济现象，因而不能用数学来证明它的对错。退一步来说，假设它本身是错的，但如果它能准确地推断未发生的事，或合理解释已发生的事，直到它对这两者之一无能为力之前，它都是对的。这就是可推翻而未被推翻的科学理论。</p>
<p>第五节 模糊不清与互相矛盾</p>
<p>  又一次不厌其烦地论述 可推翻 的重要。</p>
<p>  “科斯写道：‘模糊不清的思想，是永远不能清楚证明是错的。’”</p>
<p>  张五常对马克思开炮：剩余价值的概念模糊不清是因为马克思本人不清楚生产成本不单只有工资。</p>
<p>第六节 非事实与无限制</p>
<p>  张五常十分看重事实，需求定律（假若一种物品的价格下降，消费者对那物品的需求量增加。）中的“需求量”是消费者的欲望或意图，看不见、摸不着，因而这个定律本身是不可推翻的。</p>
<p>  但我们可以假设需求定律是对的，运用需求定律，“依照逻辑推理，在某一种可以观察到的情况下，‘甲’的发生会导致‘乙’的发生，而‘甲’与‘乙’都是可以被观察到的事实”，“假若‘乙’的不发生却有‘甲’的发生，那么需求定律就大有问题”，要么打补丁，要么算是被事实推倒。</p>
<p>  他把打补丁的行为称作 增加局限条件，没有局限条件的理论不是科学的理论，因为它能不凭借任何限制解释一切现象，是套套逻辑。</p>
<p>第七节 理论的真实性</p>
<p>  对上一节的补充论述：理论可以不是事实，但有解释力的理论要能推导出可以被验证的含意（事实）。</p>
<p>  理论可以包含抽象的概念，可以简化真实环境，可以描述不详尽，但它的局限条件必须是真实存在的，不能脱离真实世界。要求真实的局限条件是张五常经济学说中最要命的地方，要找出真实的局限条件得花时间心血，他说过（大意）“经济学是老人家的学问”，得熬。</p>
<p>第八节 经济科学的方法</p>
<p>  第一章没怎么说经济学，说的是逻辑学和知识理论，所以看不懂也不苛求。张五常安排这么一章是因为他觉得中国读者被各种主义荼毒已久需要补充科学方法论。</p>
<p>  他认为经济学是一门验证或实证科学，本质与自然科学相同，不同的是经济学的实验室是真实的世界，还有就是研究人员与被研究的都是活生生的人。因此经济学要作出客观的判断比自然科学要难。</p>
<p>  他吐糟一些“应用经济学的书……先提出一个理论，然后找真实世界的例子塞进去。基本上这是求对，违反了科学验证的主旨，求‘错’但希望没有被事实推翻。”</p>
<p>  经济学研究要尽量避免使用无从观察或不是真有其物的变量，他只用一个：需求量，而如今经济学界充斥着诸如此类的变量：博弈、动机、机会主义，“听起来可信，有点宗教味道”。要我说这类变量怎能少了“刚需”呢！？</p>
<p>第二章 从自私说起</p>
<p>  不要争论科学的基础假设。如果在出发点上就有争议，科学就走不远了。</p>
<p>第一节 个人作决策</p>
<p>  经济学是以推断人的行为来解释现象的科学。</p>
<p>  经济学的第一个基础假设：“个人”是所有经济分析的基本单位。</p>
<p>  第二个基础假设：每个人都会作选择。所有的经济问题，都是选择问题。人在说“他没有别的选择，只能blabla..”的时候，他其实还有另一个备选项：“不作选择”。</p>
<p>  第三个基础假设：每个人作出的选择，事前都可以被推测。</p>
<p>  串起来就是经济学的第一个公理：任何人的行为，都是由个人作出可以被推测的选择而起。</p>
<p>第二节 理论要约束行为</p>
<p>  要推测行为，得先加上约束条件。否则所谓“推测”无从谈起。</p>
<p>第三节 自私是一个约束</p>
<p>  第四个基础假设：每个人在有局限的情况下会为自己争取最大的利益。简单来说，人都自私。</p>
<p>  人的本质究竟是否自私无关宏旨。重要的不是人究竟是怎样，而是我们要假设人是怎样。就如人本性是善还是恶并不重要，重要的是，我们是假设人性本善来设计规章制度，还是假设人性本恶。</p>
<p>第四节 人的自私本质</p>
<p>  “自私”成为一个基础假设是十九世纪末期、新古典经济学举起以后的事。</p>
<p>  斯密在《国富论》中写到：“很多时候，一个人需要兄弟朋友的帮助，但假如他真的要依靠他们的仁慈之心，将会失望。倘若在需求中他能引起对方的利己之心，使对方知道帮助他们是对自己有益的事，那么这个人的成功机会较大。……我们认为他们给我们供应，并非行善，而是为了他们的自利。……在一般的情形下，一个人为求私利而无心对社会作出贡献，其对社会的贡献远比有意图作出的大。”</p>
<p>  张五常指出斯密轻视了自私也会给社会带来害处，且斯密认为人的“自私”是为环境所逼，而不是天性如此。也有研究表明基因决定人的自私天性。</p>
<p>第五节 结论</p>
<p>  经济学不关心人的本质是否自私，但“自私”作为基础假设不容争辩。等到以自私为出发点，附带其他假设推出的可能被事实推翻的含意被事实推翻时，再作“自私”检讨也不迟。</p>
<p>  由自私假设得出的一个结论：一个基于人的自私可以被更改的“主义”，其制度政策会失败。到底是什么主义，大家心知肚明。</p>
<p>第三章 缺乏与竞争</p>
<p>  这个世界只剩两个人，也存在竞争。</p>
<p>第一节 物品的定义</p>
<p>  物品是英语 goods 的直译，既包括商品、服务，也包含 友情、空气、幽静 等等。<br>  凡“有胜于无”的，都是经济学意义上的物品。</p>
<p>  物品又分两种：“多胜于少”的经济物品；“供过于求，无所谓多少”的免费物品。<br>  “多胜于少”中的“胜”指客观上优胜，不涉及主观和价值观判断。</p>
<p>  免费物品与经济物品之间可以转变，关键就在于是不是供过于求。比如清新空气，海口的清新空气是免费物品，北京的清新空气就是经济物品。比如大旱之后的雨水是经济物品，连续下三个月的雨水就是免费物品。</p>
<p>第二节 什么是缺乏</p>
<p>  “多胜于少”意味着“供不应求”，也就是“缺乏”(scarcity)。凡是经济物品都是缺乏的。</p>
<p>  既然是“多胜于少”，人总会想多要点，同时因为“供不应求”，要想多得到一点，总得付出代价（要多吃口饭也总得伸手张口消耗点能量是不是？）。从另外一个角度来看：凡是有人愿意付出或多或少的代价来争取多一点的物品，都是缺乏的，都是经济物品。</p>
<p>  在市场上，我们要付的代价是价格，凡是有价格的物品都是缺乏的。价格高低意味缺乏程度不一样。</p>
<p>第三节 竞争的本质</p>
<p>  （经济学意义上的）竞争发生在人与人之间。在鲁滨逊的荒岛上，有免费物品，也有经济物品，但没有竞争。因为只有鲁滨逊一个人。<br>  真实世界的经济学之所以复杂，就是因为世界上不只有一个人。分析两个人的方法与分析三个人或者几亿人倒是没本质区别，都划分为某人和其他人。</p>
<p>  竞争的定义：不只一人对某种经济物品有需求。竞争源于某种经济物品给了甲之后就不能给乙，甲乙之间要想方设法在不付出过大代价的前提下胜过对方。</p>
<p>  竞争几乎无处不在。通常人们说垄断造成没有竞争是不成立的。垄断只要存在一天，就会有人竞争垄断的权力，也会有人提供相似的经济物品来替代现有的。</p>
<p>第四节 游戏规则与产权制度</p>
<p>  由缺乏引起的竞争，一要有竞争规则，来界定每个参与者的权利和禁忌；二要有判断胜负的准则。</p>
<p>  在社会的经济竞争中，无论是法律（国法）、纪律（党纪）或习俗，都是以有约束性的办法来界定人与人之间的权利。这种权利界定就是产权制度，就是竞争的游戏规则。（按，忽然提起 产权制度 吓我一跳，这是什么鬼？）</p>
<p>  产权制度中的一种是私有产权。</p>
<p>  回过头来看产权。产权中的“产”，英语为 property 。经济学意义上，“产”指的是有多于一个人竞争的经济物品。</p>
<p>第五节 竞争准则的含意</p>
<p>  在市场上，价格是决定胜负的准则，价高者得是也。私有产权则是决定这准则的游戏规则。</p>
<p>  游戏规则与决定胜负的准则有直接的连带关系：前者决定后者，而后者决定社会的经济运作。</p>
<p>  张五常认为规则先于决胜准则出现，我认同他的看法。但如此一来又怎样看待规则决定决胜准则呢？总不能由后出现的事物决定早已出现的吧？应该说游戏规则是围绕着决胜准则逐步完善的。我们可以从一个稳定下来的游戏规则得知其中的决胜准则是什么。</p>
<p>  竞争的决胜准则决定社会的经济运作。从大的方面说，社会成员的财富或收入的分配，是该准则决定的。在不同准则下，每种类型的人优胜机会不同。比如善于经营生产的人，私有产权的竞争准则对他们有利；善于玩弄政治的人，在非私产的制度下会如鱼得水；善于墨守成规地工作，不懂应变的人，以年龄资历作准则对他们大有好处。（分别映射美国、改革开放前的中国、日本）<br>  从小的方面说，准则对人的收入、享受有决定性的作用。一个人要在市场中利益，他要么努力生产、要么发明产品、要么创造更有效率的经营方式。如果扼杀市场，所有物品以配给的方法分配，那么人就会选择走后门找关系，或谋求一官半职来获取多点物品。</p>
<p>  经济学意义上的浪费，指有其他方法，或用其他资源使用的分配，可使社会的财富或收入增加，但这些“其他”办法却莫名其妙地不予采用。如此说来，排队——人们站在队伍里不能离开干点别的事——就是一种浪费，为减少浪费，人们发明了取号机。甚至开辟VIP区，给钱多的客户不用排队。</p>
<p>  在众多竞争准则中，只有一种没有浪费的竞争准则，就是市价。（如何论证这个论断？我的初步想法是：社会财富的增加全靠普通人努力生产、发挥聪明才智创造新产品、提高生产效率。价高者得的准则使得人们要努力生产、发挥才智赚更多的钱以便在竞争中获胜。价高者得造就了一种社会财富不断增加的良性循环。）</p>
<p>第六节 经济分析与价值观</p>
<p>  重申一遍 经济学无关好坏，不回答价值判断的问题。</p>
<p>第七节 经济学的范畴</p>
<p>  第一，在知道有关的局限条件或游戏规则产前提下，推断所用的竞争准则是什么。</p>
<p>  第二，得知竞争准则，推断人的行为会怎样，资源的使用会怎样，财富或收入的分配会怎样。（作者顺带吐槽一下传统经济学分析大都以市价为准则，只能用于私有产权制度下，很狭窄）</p>
<p>  第三，解释游戏规则是怎样形成的。（我认为做到这点，要了解历史、文化、地理、政治、军事甚至医学，已经是经济学帝国主义了）</p>
<p>第四章 功用的理念</p>
<p>  utility 一词，通常被翻译为 效用 ，而在这里翻译成 功用 。</p>
<p>  “功用”只是用来排列选择的次序，本身没有意义。</p>
<p>  本章完。张五常回顾历史，最终得出“功用的理念可以不用”，所以没兴趣的可以跳过本章。</p>
<p>第一节 悲哀的发展</p>
<p>  功用，由边沁提出，有三个含意：<br>  第一，功用代表快乐或享受的指数；<br>  第二，每个人都争取这指数愈高愈好；<br>  第三，一个人的收入增加，其收入在边际上的功用会减少。</p>
<p>  边沁假设每个人对收入的多少有相同的享受（把钱花在相同的地方或许就会有相同的享受），那么富人的边际收入功用低，穷人的边际收入功用高，社会整体最高的福利，是人与人之间的收入相等。</p>
<p>  今天的经济学者认为人与人之间的功用指数不能相比。富人对一块钱的看法，可能比乞丐要看得重要。</p>
<p>  萨缪尔森指出，一个社会的总国民收入增加，不管增加多少，只要有一些人（哪怕只有一个）的收入减少，经济学就不能证实社会福利有所长进。</p>
<p>  如果我们要用功用的理论去解释人的行为，那么功用的理念要与主观的快乐或享受脱离关系，主观的快乐或享受因人而异，无法量度，而且要解释人的行为并不需要知道他是不是以增加快乐为动机。</p>
<p>  张五常反对功用理论，一如既往地，因为“功用”的想像出来的概念，在真实世界不存在。</p>
<p>第二节 功用是数字的定名</p>
<p>  （这一节太绕了。）<br>  推断人的行为即推断人的选择，假设某人春节回家有三个选择：高铁、特快硬卧、拼车自驾，他首选拼车自驾，如果凑不齐人他再抢特快硬卧，过年前两天还抢不到，他碰运气看看高铁有没有退票，竟然捡到了一张。这里拼车自驾的功用排第一，特快硬卧的功用第二，高铁排第三。</p>
<p>  功用除这种用法之外，没别的用处。</p>
<p>  功用不能相加：某人作选择的功用如下：牛奶第一，咖啡第二，红茶第三。三者之中他会选择牛奶。不能把选择的功用相加得出如果要他选择 1.牛奶咖啡 2.牛奶红茶（奶茶），他会选择 奶茶 。他完全有可能选择 牛奶咖啡。</p>
<p>  功用不能相减：沿用上例，牛奶与咖啡之间的差距，与咖啡跟红茶的差距，孰大孰小，根本没法知道。比较差距没有意义。</p>
<p>第三节 费雪的贡献</p>
<p>  （张五常引用费雪的论文解释功用不能相加、也不能相减。我看不懂他的解释，解释中夹杂不少私货。）</p>
<p>第四节 替换定理与等优曲线</p>
<p>  功用理论要解释人的行为，需要增加一些约束，替换定理就是其中之一。</p>
<p>  替换定理：每一个人都愿意牺牲任何物品来换取任何其他物品。只要你牺牲的足够少，得到的足够多，你就愿意。</p>
<p>  等优曲线（indifference curve），在大陆翻译成 无差异曲线 （香港译作等优曲线，这是张五常的发明。张对香港经济学界影响还真大）。</p>
<p>  因为愿意舍甲而取乙，我们在甲乙之间可以找到一条曲线，线上的每一点功用相同（也就是说选甲选乙都一样，甲乙的功用可能是排第一，也可能是排第三，或者排第N）。</p>
<p>  以甲为纵轴乙为横轴，这条等优曲线一定是向右下倾斜的（人愿意用尽量少的代价换取尽量多的收益），在曲线外、右上方的点，都比线上的每一点有较高的功用（自己画两条曲线，上面的那条是不是意味着，付出同样的代价，收益更多），更为可取，而曲线外、左下方的点则相反。等优曲线有无限多条，两两不相交。</p>
<p>  在局限条件下（局限条件有很多，收入算一个），人会选择可以达到最高功用的那条等优曲线。</p>
<p>第五节 内凸定理</p>
<p>  再给功用理论增加一个约束：等优曲线一定是内凸（向坐标原点弯曲）的。因为假如是外凸的话，曲线总会与坐标轴相交，意味着替换定理不成立。</p>
<p>  内凸定理有另外一个名字：边际替换意图下降定理。指在同一等优曲线上，一个人拥有甲物品愈多，其愿意以乙物品换取甲物品的意图必定下降。</p>
<p>  内凸定理的推论：如果某物品的价格下降，在同一等优曲线上（假定价格下降不影响人们对此物品的功用）此物品的需求量必定增加。因为价格永远是相对的，某物品的价格下降意味着需要付出的其他物品的代价下降了（相当于比以前拥有更多的“其他物品”，根据边际替换意图下降定理，人们愿意用某物品换取“其他物品”的意图必定下降，因而对某物品的需求量增加）。</p>
<p>  这推论要假设等优曲线不变，但某物品的价格下降，购买此物品的人的实质收入是增加了的，此物品的等优曲线会变为较高的那条（这里的“物品”是指经济物品，越多越好。收入约束了人们对等优曲线的选择）。</p>
<p>第六节 贫穷物品与吉芬反论</p>
<p>  inferior goods ，此处译作 贫穷物品 ，指收入增加而需求量减少了的经济物品。贫穷物品因人而异，任何物品都可以是贫穷物品。比如啤酒，人穷的时候喜欢喝，有钱之后可能会少喝，改为喝葡萄酒；比如肥肉，人穷时吃不起肉，能买到一点肥肉就很不错，有钱之后追求健康，肥肉的需求就减少。</p>
<p>  一种贫穷物品的价格下降，降价本身会使该物品的需求量增加，但降价引起的实质收入增加会使贫穷物品需求量下降。如果两者相抵，最终的效果是此物品的需求量下降。这种物品就是吉芬物品。</p>
<p>  吉芬物品只在一个人的世界里（即没有竞争）存在，至于为什么，张五常卖了个很大的关子，答案在第七章揭晓。</p>
<p>第七节 功用理念可以不用</p>
<p>  不用功用理念的理由最终还是那些理由：功用非真实存在。</p>
<p>  看到最后：我们不需要功用这个理念。（似乎我们为理解功用那一套理论付出的努力都白费了）</p>
<p>第五章 需求定律</p>
<p>  需求定律是说任何物品的价格下降，其需求量必定上升。以纵轴为价、横轴为量（也可以反过来，纵轴为量、横轴为价），画出来的需求曲线一定向右下倾斜。</p>
<p>第一节 观察与验证</p>
<p>  需求定律不限于价格或市价的变动与需求量的关系。如果一样物品没有价格或市价，我们可以用代价来表示。任何局限的转变都可以阐释为代价的转变。</p>
<p>第二节 弗里德曼的分析</p>
<p>  需求定律指 价格 和 需求量 这两个变量 负相关。在真实世界中，影响需求量的不止 价格 这一个因素，要维护需求定律的解释力，就得假定其中一些因素不变，另一些因素可变。</p>
<p>第三节 不变量的选择</p>
<p>  忽然下起倾盆大雨，卖雨伞的坐地起价，雨伞价格上升，需求量不减反增。这是不是推翻了需求定律呢？<br>  增加雨伞需求的不是上升的价格，而是忽然下起来的大雨。注意这里的字眼是需求而不是需求量。</p>
<p>  需求量与需求不同，前者因为价格变动而变动，后者因价格之外的因素变动而变动。大雨影响了雨伞的需求，使整条需求曲线向右移动（大雨增加的是需求，而不是价格，所以不是向上移动），这一移动使需求量增加了。要用需求定律来描述雨伞价格与需求量的关系，必须假设天气这个因素不变。</p>
<p>  只要需求定律的验证含意不被事实推翻，假设不变的因素是愈少愈好。假设因素变与不变有以下三个原则：</p>
<ol>
<li>凡是直接影响价格的其他因素，可变；</li>
<li>凡是直接影响需求量的其他因素，不可变；</li>
<li><p>凡是由价格变动引发，继而影响需求量变动的其他因素，可变；</p>
<p>第三点可以反过来，由需求量变动引发，继而影响价格变动的其他因素，可变。</p>
</li>
</ol>
<p>第四节 品味不变的假设</p>
<p>  真实世界存在品味这回事，一个人的品味也的确会改变。<br>  很难描述一个人的品味是怎样的，更难判断他的品味是不是改变了，什么时候改变了，变成什么样了。<br>  用“品味改变”可以解释一切的行为，因而变成了套套逻辑。<br>  如果能找出品味改变的原因，可以完全不用“品味”，或者假设品味不变。</p>
<p>第五节 用值与换值的理念</p>
<p>  斯密指出价值有两种：用值，是某物品给所有者（或使用者）带来的最高收益，也可以说，是所有者（或使用者）愿意为此物品付出的最高代价；换值，是获取某物品所需要付出的代价。</p>
<p>第六节 何谓价</p>
<p>  价，是一个消费者对某物品在边际上所愿意付出的最高代价。“边际上”，指多买一个。<br>  在边际上，他愿意付出的最高代价就是该物品在边际上对他的最高用值。</p>
<p>  以市场为例，代价就是市价。<br>  对某人来说，某物品的边际用值比市价高，他就会买一点，反过来，市价比边际用值要高，他就会卖一点。最终这个人对此物品的边际用值会等于市价。</p>
<p>  价格永远是相对价格。甲物品的价格，永远是要付出的乙物品或其他物品的“量”。在市场上，钱只不过是一个中介，代表着要付出的物品的边际用值。</p>
<p>  价格通常用现值量度————将来才付之价要用利率折现。</p>
<p>第七节 何谓量</p>
<p>  这里的量，指需求量，不是成交量，也不是供应量。需求量指在不同的价格下，消费者想要换取的最高的量。</p>
<p>  量，可分为三种：“有质”的，“委托”的，“有质”与“委托”混合的。</p>
<p>  每单位数量的物品，人们量度出影响其价格的所有因素，此时的量就是有质的量。比如说香港人说的九九金，金的纯度被量度之后，每一克都是有质的量。</p>
<p>  工厂工人的劳动，若以工件计数，劳动的量就是有质的；若以工作时长来计数，就是委托的。工作时长本身不代表工人劳动的价值，工作时长只是工人劳动产出的大概估量。</p>
<p>  市场上的产品也有以“有质”和“委托”量混合算价的。比如按斤卖的西瓜。重量本身是影响价格的一个因素，而西瓜的含糖量、成熟度、籽多不多等等因素也影响价格，但没有被计价。</p>
<p>  需求定律永远用于价格及其直接联系着的量之间的关系。</p>
<p>第八节 消费者的盈余</p>
<p>  用值与换值的差额就是消费者的盈余。<br>  榨取消费者盈余的方法：1.收取入场费；2.要么都让你买走，要么一个都不卖给你，全部或零地销售。</p>
<p>第九节 需求的价格弹性</p>
<p>  单价下降，本身会让商家收入减少，同时价格下降会使需求量上升，又会令商家收入增加。</p>
<p>  价格弹性 = 需求量变动的百分比 / 价格变动的百分比</p>
<p>  价格弹性大于一，即谓价格有弹性，价格下降会使出售方的收入增加；价格弹性小于一，即谓价格无弹性，价格下降会使出售方的收入减少。</p>
<p>  价格弹性是以某个价位来算的，一条需求曲线有无数个价位，每个价位的弹性不尽相同。</p>
<p>  要算出价格弹性系数极为困难，它对现实没什么指导意义。</p>
<p>第十节 需求第二定律不能成立</p>
<p>  阿尔钦和施蒂格勒分别提出了需求第二定律：弹性系数的大小与时间是正相关的。即某物品价格变动之后，变动之后的价位的弹性系数会随着时间变长会增加。<br>  原理是：一种物品的价格弹性，除了该物品本身的性质外，主要是由其他替代物品的多少及它们的价格决定。替代物品愈多，愈相近，价格愈低，该物品的价格弹性系数就愈高。找寻替代物品来替换是需要时间的。时间愈长，替换的机会愈大，所以该物品的价格弹性系数与时间正相关。</p>
<p>  张五常认为如果需求第二定律推出成立的话，应该可以推出香港的计程车在多次加价之后，其顾客量会大幅下降。但事实恰恰是在加价初期顾客量的确下降不少，随着时间的增长，顾客量恢复到加价之前。</p>
<p>  他推测是因为有些替代物品是众所周知的，不需要花时间找寻。因为在某物品加价之后，消费者立即转用已知的替代物品，但用了一段时间后，觉得不如之前的物品，就又转了回去。</p>
<p>第六章 小试牛刀</p>
<p>  一种行为的代价下降，这种行为的需求就会上升。</p>
<p>第一节 无知的含意</p>
<p>  衡量一件物品的质量需要大量时间和专业知识，而这俩我们都缺乏。一般来说，无知，加上自己以往的经验，同类之物，我们往往见到价格较高就会认为质量较好。这样的判断不一定对，但对的机率较大，因为市场已经替我们作了鉴别。</p>
<p>第二节 验证的条件</p>
<p>  依照需求定律，以逻辑推出来的假说，在某种情况下，甲的出现会导致乙的出现。这里所说的情况，就是验证条件。</p>
<p>  约束人的行为的所有条件（包含验证条件、价格等等）称为局限条件。</p>
<p>  解释世事有三大难处：</p>
<p>  世界的局限条件——约束每个人争取最大利益的局限——非常复杂。我们将之简化时一定要与真实世界大致吻合。<br>  验证含意必须是真实世界中可以观察到的。需求定律本身是不可以验证的（因为需求量不是事实，无从观察）。我们要以需求定律，加上局限条件的变化，从逻辑推出可以被事实验证的含意。（概括为：从抽象中来，到现实中去）<br>  其他因素的变与不变的选择。（前面有述）</p>
<p>第三节 不管成交量的含意</p>
<p>  （一上来就吐槽股票投资中的技术分析是风水派）</p>
<p>  以需求定律解释行为，（因为需求量是抽象概念）我们可以用逻辑把需求量与成交量挂勾，或者以需求量转变的含意来阐释现象。后者比较浅显，前者将在后面章节重点讲述。</p>
<p>第四节 单质的需求验证</p>
<p>  以单质的物品为例，示范指定验证条件而使需求量与成交量挂钩。</p>
<p>  假设大学教授享有一项补贴，名义上用于复印资料。补贴发放有方式有两种：一是打到工资卡，随教授支配；二是发票报销，严格限于复印资料。受补贴影响，哪种发放方式下教授复印资料的数量较多？显然是第二种。假设补贴总额是一千块钱，复印一张纸市场价格是5毛，第一种方式是随教授支配，对他来说这一千块就值一千块；第二种方式要发票报销，只能用于复印资料，一千块就不值一千块了。前者复印一张还是5毛，后者就不值5毛一张。价格下降需求量就增加了。</p>
<p>第五节 多质的需求验证</p>
<p>  美国华盛顿盛产苹果，其中以红苹果（香港人叫蛇果）质量最高，最贵。有人发现上佳的红苹果大都运到外地去卖，本地反而很少见到。如何解释这个现象呢？</p>
<p>  苹果的定价直接委托于物理质量，其他未直接算价的因素至少包括：糖分、水分、外观色泽，影响苹果价格最重要的因素应该是糖分。<br>  红苹果质量最高、最贵，原因在于它含糖量高（当然外观也好看，为简化分析不提）。</p>
<p>  假设要运送两种苹果到外地贩卖：A苹果含糖量为1个单位/只，B苹果含糖量为2个单位/只。运费都为1块钱/只。<br>  又假设消费者为每单位含糖量支付1块钱，销售者不赚钱。<br>  那么消费者为每只苹果支付的价钱分别为：A苹果2块钱，B苹果3块钱。<br>  算上运费，消费者为每单位含糖量最终支付：A苹果2块钱，B苹果1.5块钱。</p>
<p>  显然含糖量高的苹果最终到达外地消费者手上时比含糖量低的要便宜。</p>
<p>  以上。买苹果不是买糖，但分析思路可以用于其他很多地方：店租贵的地方，卖的商品也不便宜；地价贵、房价也不会低；宝剑赠英雄，好马配好鞍；美女用的化装品一定比普通人贵。</p>
<p>第六节 成衣配额的分析示范</p>
<p>  直接看这篇文章吧，就不多说了。<br>  <a href="http://blog.sina.com.cn/s/blog_47841af7010003yg.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_47841af7010003yg.html</a></p>
<p>第七章 交易理论与市场需求</p>
<p>  只因世界多于一人，经济解释的困难上升不止百倍。</p>
<p>第一节 交易是上下交征利</p>
<p>  ……这庞大的利益增加，主要是由于每个人专业生产，然后交易。不谈生产而单论交易，利益还是有的，但比起有专业生产的存在，其交易的利益少很多，近于微不足道。</p>
<p>  没有生产的交易，大家有利可图，主要是因为大家对物品的边际用值不同。</p>
<p>  假设整个市场只有甲、乙二人，唯一商品苹果的总供应量只有六个，甲、乙的需求曲线如下：</p>
<p>  苹果数量： 1 2 3 4 5 6<br>  甲边际用值：  1 0.9 0.8 0.7 0.6 0.5<br>  乙边际用值：  2 1.6 1.2 0.8 0.4 0</p>
<p>  甲、乙的边际用值遵循边际递减规律，具体数值随意捏造。<br>  第五章说过，市场的参与者为赚取最大利益，最终会令市价等于自己的边际用值。</p>
<p>  假设6个苹果皆为甲所有，那么因为此时甲的边际用值比0.5还要小，乙的为2，只要市价在0.5~2的范围内，都会有交易。每出售一个苹果，甲的边际用值就会增加，乙的会减少，直到甲与乙的边际用值相等（0.8），甲乙之间不再交易。</p>
<p>  假设一次交易就令甲乙的边际用值相等（等于成交价），那么甲的消费者盈余是0.6=（0.8-0.5）+（0.8-0.6）+（0.8-0.7），乙的消费者盈余是2.4=（2-0.8）+（1.6-0.8）+（1.2-0.8）</p>
<p>  从上例可以看出：</p>
<p>  一、没有生产的情况下，市场的每个人都是需求者与供应者兼于一身的。<br>  二、在均衡下，市价等于市场每个人的边际用值。<br>  三、吉芬物品不存在于交易当中。假设对甲来说，苹果是吉芬物品，即甲的需求曲线向右上升，对应的边际用值与拥有的苹果数量正相关。于是甲在一开始就会把所有苹果占为己有，根本不会卖出去。</p>
<p>第二节 市场需求否决剪刀分析</p>
<p>  市场需求由众多个人需求加起来而成。</p>
<p>  物品有私用品与共用品之分，前者只能供一个人享用，比如苹果；后者则相反，比如音乐、美景。私用品不一定是私有，共用品不一定是公有。（第八章有述）</p>
<p>  私用品的市场需求曲线，由个别需求者的不同需求曲线向右横加而成：每个价格对应的所有个别需求者的需求量。市场需求曲线于是代表所有需求者的边际用值与总需求量的关系。</p>
<p>  假设交易费用不存在，数之不尽的需求者和供应者，各自争取最高的交易利益，以自己的边际用值与面对的价格相比，或购入，或沽出，而这些行动或使价格上升，或使价格下降。当达到每个需求者的边际用值与价格相等时，大家的边际用值相等，市价就此形成。</p>
<p>第三节 交易的局限条件</p>
<p>  交易的局限条件只能在社会存在。</p>
<p>  一个人的世界没有产权，也没有交易费用，两者都只存在于社会。</p>
<p>  前面章节对市场的分析有一个重要的前提：交易费用不存在。市场是一种制度，而制度是因为有交易费用的存在而产生的，交易费用不存在，市场也就不存在。</p>
<p>  科斯定律也有相同的前提，私有产权是一种制度，交易费用不可能不存在。</p>
<p>  这个矛盾，将在经济解释第三卷详述。</p>
<p>第八章 共用品的经济分析</p>
<p>  共用品（public goods），不是公用品。</p>
<p>第一节 共用品的性质</p>
<p>  私用品的市场需求曲线由每个价格对应的所有需求量相加而成（以价格为纵轴，量为横轴，向右横加所有市场参与者的需求曲线）。</p>
<p>  共用品，可以多人共享而且相互间不干扰。食物不是共用品，一人吃了，另一人就没有了；知识是共用品，清风明月是共用品，电视节目也是共用品。</p>
<p>  私用品可以是公有，比如我国的城市用地；共用品可以私有，比如张五常的经济解释学说。</p>
<p>  在讨论共用品时，共用品的量只有一个。所以共用品的市场需求曲线，由所有需求者的个人边际用值叠加而成。（即所有市场参与者的需求曲线向上叠加）</p>
<p>  帕累托条件，资源的使用及物品的交易可以达到一个情况或条件，满足了这个条件，我们不可能改变资源的使用，使一个人利益而没有其他人受损。</p>
<p>  共用品收费有以下困难：</p>
<p>  1.与私用品相比，难以隔离不付费享用者。隔离的办法也有很多：与私用品捆绑销售，比如把知识写到书上；销售入场门票。</p>
<p>  2.难以得知各个消费者的边际用值；共用品的量只有一个，各个消费者的需求曲线只有一个点，且各不相同。</p>
<p>  3.以不同的价格向不同的消费者提供相同品质、数量的物品叫做价格分歧，因为难以得知各个消费者的边际用值，所以价格分歧难以实施。</p>
<p>第二节 大师之见有问号</p>
<p>  因为可以多人共享，共用品多供应一个人使用，其边际费用或成本为零。<br>  共用品收费如果低于平均成本，一定亏本；如果高于平均成本，那一定高于边际成本（共用品的边际成本为零）。</p>
<p>  有人认为既然多供应一个人使用的边际成本为零，那么就不应该收费（不收费是为达到传统的帕累托最优），而不收费则无利可图没人愿意提供共用品，所以他们主张共用品由政府直接提供或资助私人提供，并限定价格（直接提供则限定价格为零）。</p>
<p>第三节 横看成岭侧成峰</p>
<p>  共用品可供多人享用，但有时会出现挤迫情况，不是完全没有干扰，但无论怎样挤迫，有一点是不变的：共用品的量不会变。凡是享用人数增加但物品的量不增加，都属于共用品。</p>
<p>  严格来说，几乎所有物品都同时具有共用品和私用品的性质。以一场演奏会为例，就音乐来说，一人享受音乐并不影响别一人享受，演奏会是共用品；但换个角度，从座位来说，一人坐了A1座位，另一人就不能再坐在A1，演奏会是私用品。</p>
<p>  共用品与私用品的分析方法大为不同，首先需求曲线就不一样，前者向上叠加，后者向右横加。此外需求定律中的量与价都不一样。</p>
<p>  市场一般偏向以私用特质的量度作价及量（即偏向把物品当成私用品），因为比较容易隔离不付费的享用者。</p>
<p>本书完。</p>
]]></content>
    
    <summary type="html">
    
      本文是《科学说需求》卷一的读书笔记，以章节为索引整理重点和感悟
    
    </summary>
    
      <category term="reading" scheme="http://judes.me/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>I&#39;ve made it</title>
    <link href="http://judes.me/2017/01/18/2013-11-10-ive-made-it/"/>
    <id>http://judes.me/2017/01/18/2013-11-10-ive-made-it/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本人一直有写博客的习惯，最近在 阮一峰 的博客上看到这篇文章：</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门</a>，</p>
<p>好奇心起动手跟着做起来。</p>
<p>阮大神这篇文章只是教你搭建最简（jian）单（lou）的博客，仅是依靠阮大神的文章是做不到现在这个博客的样子的，在搭建博客的时候，我先后参考了以下好几篇文章：</p>
<p><a href="http://www.lizherui.com/pages/2013/08/17/build_blog.html" target="_blank" rel="external">一步一步打造Geek风格的技术博客</a>，从中我接触到主题boostrap2，安装第三方评论系统以及添加Google Analytics。</p>
<p><a href="http://yanping.me/cn/blog/2011/12/15/building-static-sites-with-jekyll/" target="_blank" rel="external">【译文】用Jekyll构建静态网站</a>，这篇文章用一个完整的实例介绍了jekyll的语法和实现原理，十分不错。</p>
<p><a href="http://calefy.org/2012/03/03/my-process-of-building-jekyll-blog.html" target="_blank" rel="external">Jekyll建站之旅</a>，看到这篇文章，对博客的主题印象好感十足，我决定本博客最初的主题就采用与之相同的：Jekyll Bootsharp。</p>
<p><a href="http://jekyllbootstrap.com/usage/jekyll-quick-start.html" target="_blank" rel="external">Jekyll QuickStart</a>，最后要看看jekyll的官方文档，学习如何创建文章/页面。</p>
<p>因为用的是markdown语言，而本人很屌丝地用linux系统，所以好用的编辑器比较难找，我要求很简单：可以边写边浏览实际效果。后来总算找到了这个<a href="http://pad.haroopress.com/user.html" target="_blank" rel="external">Haroopad</a>。</p>
]]></content>
    
    <summary type="html">
    
      借助 jekyll 终于折腾出第一篇文章了。
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>林书豪：被忽视的屌丝、最耀眼的金子</title>
    <link href="http://judes.me/2017/01/18/2013-11-17-JemeryLin/"/>
    <id>http://judes.me/2017/01/18/2013-11-17-JemeryLin/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:34:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>由 黑泡教父 发表在虎扑篮球·火箭专区 <a href="http://bbs.hupu.com/6876428.html" target="_blank" rel="external">http://bbs.hupu.com/rockets</a>    </p>
<p>在我们现实生活中，总会有这样一类特别的人，就像福利斯特·阿甘似得，他们或许从来都不是最出色的、最厉害的那一个，但在别人眼里却永远都足够幸运。是的，那是因为这类人从来就没有停止过奔跑。在NBA里面，林书豪就是这样一个家伙。</p>
<p><strong>他和你一样，是个屌丝</strong></p>
<p>在最近流行的短剧《万万没想到》中，片头、片尾曲都有这样一句歌词：想做英雄，却还是那倒霉的王大锤。此话套用在林书豪身上也再合适不过了，只需要把锤锤换成豪豪这么简单。</p>
<p>和绝大多数黄种人一样，林书豪来自一个和篮球几乎没有任何联系的家庭，他父母身高只有168CM，幸好他的外祖母家那边身高都很高，外曾祖父甚至超过180CM。也就是说，林书豪没有从父母那儿捞到任何和体育相关的优秀DNA，反倒隔代遗传，从祖父母那边沾到了点光。另外虽然从小出生在美国，但林书豪整体家庭教育氛围还是有点中国风。在我们这边，小孩子在读书时期打球都有点罪过的意思，你在学校打，万恶的教导主任们会把你喊过去，然后把球给没收了。你在家里打，严苛的父母们甚至会跑到球场大喊：二狗子、XX，还不回家写作业看书，明儿个还要考试呢，想不想读大学啦！虽然林书豪没有这么深层次的感受过中国教育，但在他爸妈耳边，总还是有一群阿姨阿婆的在唠叨：你家小林子，这么打下去，会不会影响学习啊？好在林家父母还算是开明，林书豪自己也算是争气，书读得还不错，那就接着打呗。</p>
<p>和国内复杂的选拔环境不同，在美国那边，林书豪还是有机会往上爬，往更高层次的联赛打球。但这过程却异常艰辛，当时打完高中的林书豪和现在刚刚毕业满怀憧憬的大学生一样，虽然自己来自小学校小地方，但目标还是很高的，他当时最向往的去处是UCLA，这不得了啊，篮球名校，出过雷吉·米勒，威斯布鲁克，而且地方也不错，娱乐之都洛杉矶。但结果就和很多找工作碰壁的大学生一样，林书豪精心制作了简历，还把自己高中时候的表现做成了光盘，然后一一寄出。可是漫长的等待过后，他收到的回复却是：额，你还是不错的，不过我们不能给你提供奖学金。当然这还是能听得下去的了，剩下说话直白的就跟《喜剧之王》里导演一样怒喊“你个死跑龙套的”一样，对林书豪说：不好意思，我们只能让你打打替补，轮换轮换。这种感觉，就跟喊了一群朋友去跟女神表白，结果女神把花扔地上啥也不说就走了，然后小伙伴扯着自己的衣袖说：算了吧，就这么算了吧。不过，倔强的林书豪的回答是：不行，我要曲线救国。</p>
<p>后来我们都知道，林书豪接下来的故事成了一段佳话，什么“哈佛高材生”、“篮球天才”之类的光环都加上了，但这都是后话。在当时只不过是无数拒绝后的选择，就跟你梦想着去苹果当员工，然后YY加薪升职迎娶白富美，结果却被无情地送去富士康一样，虽然同是干和“苹果”相关的活儿，但得到的却完全不是一个级别的待遇。而对林书豪来说，也是如此，同样是打篮球，常春藤赛区受到的关注简直少的可怜。</p>
<p>面对这种情况，很多人渐渐就会选择放弃，用“我可能不适合、我也许有更好地出处”来作为理由和借口，而林书豪依然站在那里，就像樱木输给陵南后仍然站在那里喊“比赛还没结束”似得。他们，都没有选择离开，也许在大多数人眼里，这样的行为已经可以和傻X划分在一起，但林书豪就是在那里，不考虑任何未来可能，充分享受当下，做一个特立独行、活在自己世界里、别人永远学不来的傻X。</p>
<p>所以，以上这些苦兮兮的经历，在很多时候都发生在很多人身上，林书豪的故事甚至都可以拿来直接拍一集《万万没想到》番外篇，然后博得所有人阵阵欢笑。可是，就跟这部短剧值得人们回味的地方一样，他确实是不折不扣的屌丝，但他有梦想、有故事，所以有了他自己与众不同、让人感动的地方。</p>
<p><strong>他和你不同，是块金子</strong></p>
<p>我是金子，我要发光的。</p>
<p>是的，所有打过球的、看球的人都不会对哈佛有什么好感，甚至带着嗤之以鼻的蔑视神情。</p>
<p>但林书豪不管。刚刚到哈佛的时候，甚至都是球队里最弱的那一个，也就是NCAA最差分区里的最差球员。而这也无所谓，差，就练呗。到了二年级的时候，林书豪场均场均可以得到12.6分，并且入选了长春藤联盟第二阵容。而到了他大三赛季，更是成为了NCAA第一级别联赛中唯一一位在得分（17.8），篮板球（5.5），助攻（4.3），抢断（2.4），盖帽（0.6），投篮命中率（.502），罚球命中率（.744），三分球命中率（.400）均排名联盟前10位的球员。最后到了大四，林书豪甚至成为了象征大学篮球最高荣誉的约翰·伍登奖候选人。也许看到这里那些挑刺的围观者依然可以找出很多理由来说明他的幸运，但现实是，在这四年时间里，他从哈佛最差的那一个，变成了最优秀的那一个。</p>
<p>是的，所有人都不会记得那些在发展联盟打球的家伙，甚至觉得这些人根本就是联盟随时可以清理掉的垃圾。</p>
<p>但林书豪不管。他选秀失败，没关系，不是还有试训和夏季联赛吗，我去参加就是了。后来林书豪参加了小牛举行的迷你训练营，在此之前，其他教练看到他的表现，都是摇头说NO，《纽约时报》就说过林书豪是“一个聪明的传球手，但同时是一个跳投有缺陷以及身体单薄的球员，很可能没有足够的力量和运动能力在NBA中完成防守，但是可以自己创造投篮机会或者杀入禁区攻击篮筐。”但这一次，小牛总经理尼尔森看完却表示：“他拥有与大多数人不同的视野。”这应该是他第一次，在NBA被人们发现拥有其他球员所不具备的素质。而接下来的夏季联赛中，林书豪场均出场18.6分钟，可以得到9.8分，3.2个篮板，1.8次助攻以及1.2次抢断，并且54.5%的两分球投篮命中率排名全队第一位。最终，达拉斯小牛队、洛杉矶湖人队、金州勇士队以及一支东部球队提供了报价合同，而他选择了自己的家乡球队勇士。</p>
<p>是的，在所有球迷看来，那些一直坐冷板凳的家伙就是该死的饮水机守护神，他们除了打酱油什么都不会。</p>
<p>在初来勇士的那个赛季里，林书豪没有得到太多的出场机会，多次回到他熟悉的发展联盟里，各项数据也都可以忽略不计，所以理所当然的，他变成了皮球，在各个球队间踢来踢去，先是被勇士抛弃，然后去了火箭，结果在被火箭签约后的第12天就被扫地出门。当然幸运的是，2011年12月27日，尼克斯向林书豪抛来了橄榄枝，而且随后球队大面积伤病，这就像是之前攒人品突然大爆发一样，林书豪第一次在NBA得到了真正的机会，当然，你不要说这是幸运，在每个人的生命中，都有机会出现，只不过林书豪抓住了而已。接下来发生的事情从一个篮球界屌丝的爆发变成了全社会连扫地大妈、看门大叔都关心的热点新闻。没错，“林疯狂”来了，2月4日，在战胜新泽西网队的比赛中，林书豪得到25分，5个篮板以及7次助攻——全部都是生涯新高。2月10日，林书豪砍下职业生涯新高的38分，并送出7次助攻，带领尼克斯队以92-85战胜了洛杉矶湖人队。2月14日，在对阵多伦多猛龙队的比赛中，在离比赛结束不足一秒的情况下，林书豪投入一记三分制胜球，帮助尼克斯队击败对手。</p>
<p>是的，和所有自信满满的专家预言的一样，林疯狂在赛季末段戛然而止了。后来他又以自由球员的身份来到了火箭，在休斯敦人的期待中度过了一个和之前相比完全平淡的赛季。最后就是所有人茶余饭后说的：“现在火箭，就是想交易林书豪，也交易不出去，没人要啊！”</p>
<p>没人要？林书豪不会关心这个，只要还在球队里，那就继续打下去。所以当哈登、霍华德成为焦点、所有人都不再关注火箭7号的时候，他自己又杀回来了。2013-14新赛季，在人们都讨论何时交易林书豪、阿西克的时候，揭幕战打山猫，林书豪16分；接着打小牛14分，然后战犹他20分，总共7场比赛下来，场均得到火箭时期创新高的14分，更难得的是，林书豪是整个火箭最高效的球员。接着就和绝杀猛龙一样，在打猛龙的比赛中，林书豪独得全场最高的31分，并且在第二个加时中命中关键抛投。人们突然发现，当年的林疯狂又会回来了。</p>
<p>其实，对于林书豪自己来说，他根本就没有离开过。从始至今，他只是在做一件事：在篮球这条路上不断奔跑。那些耀眼的时刻只是他道路上鲜明的路标，而那些苦难也只是已经被跨越过去的绊脚石。</p>
<p>所有的不同在于，有的人停留原地，而他早已远走。</p>
]]></content>
    
    <summary type="html">
    
      一个真实的奋斗在NBA的哈佛高才生的屌丝故事
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>多彩的侦探故事</title>
    <link href="http://judes.me/2017/01/18/2013-11-23-storiesOfDetective/"/>
    <id>http://judes.me/2017/01/18/2013-11-23-storiesOfDetective/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2014-11-22T15:17:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>要我选一本书来看的话，推理侦探和科幻题材估计排不上号。但事实上我的确是看了不少侦探故事。</p>
<p>我发现，同样是由推理搭台，唱戏的可以是各色各样的“人物”。</p>
<p>比如 金田一 ，每集不死上几个人金田一一那脑子是不会开窍的。这下你可知道比见到柯南更倒霉的是见到谁了吧？</p>
<p>比如 古烟任三郎 ，一开始凶手就在你面前大模大样杀起人来。接着那个缠人、总是不知道从哪里窜出来的猥琐大叔（才想起人家还是个“绅士刑警”）带你找出证据。作者的心思显然是：光写答案，没有证明，零分哦。</p>
<p>比如 冰菒 ，都是些中学生之间鸡毛蒜皮的芝麻绿豆事，有次就两个人在放课后听广播YY了一整集。但你就不得不佩服作者为了推理已经无所不用了。</p>
<p>比如 大侦探波罗 ，作者先安排各种人物轮番登场，把我这个面盲搞得晕头转向，再让那个有洁癖、留小胡子、一口一个“波罗”的大侦探揪出一个又一个罪犯。Oh My !!! 我TMD的连人都没认清楚，案子就结了？！这不科学啊！</p>
<p>比如 一朵桔梗花 ，这也算是推理嘛！从头到尾都是主角在猜测。要是那个犯人——多半早已见上帝去了——有机会开口说一句，哼，你可真能想哦！你说我有罪，你有证据吗，拿出来给我看啊？我估计主角那伟大光荣正确的身影会瞬间萎下去，像那只爆了的大黄鸭一样。最后我还得说一句，全书弥漫抑郁气息，只有最后一个 向阳科探案记——如其名，是欢乐一点点的，还是个 good ending 耶，我终于不用担心作者会因心理问题自绝人世了。事实上他是因病逝世的。</p>
<p>说点题外话：</p>
<p>看过一篇文章，用词语分析加统计的方法推断“韩寒”写的文章到底是不是韩寒本人写的。结合对自身写作习惯的考察， 我也倾向认为这事有蹊跷。虽然我大体上还是坚持 要确信一个越惊人的事实，就必需提供一个与之相应的铁证。</p>
<p>以上这段文字的重点在于：我对自身写作习惯作过考察   ^_^ ，其中一个结论是：我太喜欢用“了”这个字，很多时候这只是习惯了句子末尾加上这个废字。是毛病，得改。。。</p>
]]></content>
    
    <summary type="html">
    
      最近因为看了不少侦探故事引发的感想
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>年终总结</title>
    <link href="http://judes.me/2017/01/18/2013-12-14-lookBackTo2013/"/>
    <id>http://judes.me/2017/01/18/2013-12-14-lookBackTo2013/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:39:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚偶然看到论坛职版号召大家写年终总结，大除夕都不放假，不写年终总结还要干什么呢？！</p>
<p>哈哈，说得对！</p>
<p>旧日还是学生时很喜欢看前辈们写的今年自己遇到什么事，有什么收获、教训，因为不论成败，都是别人精彩的故事，而我只是个读得津津有味的看客。</p>
<p>如今，我已工作了一年半有余。如果某人替我写一篇年终总结，我自己会否也看得津津有味，不会，我只会看得满眼迷茫。</p>
<p>当初选择这个公司不是因为自己坚持，其实只是因为春季已剩下不多，我没有更好的选择而已。深圳、离家近、薪水不低还能锻炼一下自己与人打交道的能力，以上原因是当时拿来安慰自己，现在想来也的确是这么一回事。</p>
<p>深圳是个年轻有活力又不排外的城市，离家近使我能每两个月得以回一趟家，薪水养活自己绰绰有余还能定期汇点钱给家里；做人做事也比刚出来时积极许多，也不怕与人接触打交道（想当初自己连打个电话都怕自己说不好而犹豫再三）。</p>
<p>一切看起来都像是当初选择对了。</p>
<p>只是一年半后，上司把我叫到小房间里劝我离职。说我这一年多来进步不大，我性格太弱势，这个职位不适合我。无谓再呆下去，对自身和公司都不好，趁早做好找下一份工作的准备。后面还说了句，年终奖不用担心，会有的。</p>
<p>我有什么话要说呢？我无话可说，要是我愿意说的，我早就说了。我清楚被劝离职也是自找的，一直以来我都觉得自己上司气场不合。有不少事情我都懒得与他争论，要么他说什么我就做什么，要么明知道他冤枉我但我也认了。刻意不去跟他搞好关系，有事就找他，没事就不理他。工作的以外的事从来不跟他掺和在一起。</p>
<p>工作与非工作我分得很开，从来不跟他瞎聊。或者正是由于这样，两个人没机会交流，我也就没取得他的信任，日积月累最终给我一个劝退的结果吧。</p>
<p>我对此的感受一开始就似明知两人要分手，只是因为被对方先开口了，感到非常不爽。但后来总有点自责，工作上的事情我可以做得更好的。但我唯一没有后悔的是我刻意跟他拉开距离，我不觉这是错。</p>
<p>或者我是无药可救吧。这辈子我都改不了 生人勿近 的性格。但我奇怪为什么我跟另一位老员工处得还不错。他很愿意在工作上带我，教会了我很包括在工作之外的事情。我很感激他，没有他的提点，相信即使再过几年我也一无是处。</p>
<p>对未来的想法在被劝退之前就有了，只是一直想不清楚，被劝退也打乱了原有的平稳节奏。</p>
<p>是要找一个能安静坐下来钻研问题的职位，还是找一个比现在的看起来更不适合自己的销售工作呢？</p>
<p>前者算是顺从了自己的性格，相信自己在做事的过程中也十分快乐。看起来我没有任何理由要拒绝这种选择；但我内心又有点不愿意，这种不愿意难以说清道明。因为我怕老了之后干不了技术活还得转型，以自己这种性格，一定会干不好；还有，这种工作看来赚不了我想要的那么多的钱。有人说，找工作要先抛开钱来找，但我就是想要多一点的钱，赚不了那么多的钱，我就过不上自己想要的生活：读书写作，悠闲自在，保持尊严。或者我这点想得不对。没钱也能读书写作，贱命一条，倒也悠闲自在。尊严一直都或有或无。与人共处、与人比较时无有优越感，但独处的时候最多，但也无关尊严。或者我只是想世间一切的烦恼都只是为了钱，虽然自己不曾因钱烦恼过，但我很清楚总有一天自己会为它烦恼的。最简单的，老人家生病要钱，老了也要钱。</p>
<p>我想想销售一因为听说可以赚多点钱，二来因为它据说很锻炼人，年轻人就应该得到多点锻炼，多受点挫折，多见点不同的人。没损失的。只是，我连现在这个职位都干不好，能干好这种工作吗？最重要的是，我的性格不像是适合干这类型工作的人。或者性格才是最要命的。</p>
<p>最后，我还想过自己去创业。或者我不是那种适合在别人底下工作的人吧？这个问题坦白说，没人能给自己正确答案，除了上帝。但我有的是机会去证明。</p>
<p>只是我不清楚自己能做什么，想做什么生意。我还是太天真了。</p>
]]></content>
    
    <summary type="html">
    
      用两个字总结这一年，失败；用四个字的话，我希望是：还没完败
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>《生活在哪个朝代最郁闷》摘抄</title>
    <link href="http://judes.me/2017/01/18/2014-02-16-notesOfYuMen/"/>
    <id>http://judes.me/2017/01/18/2014-02-16-notesOfYuMen/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T15:09:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="身体、革命与“痛史”">身体、革命与“痛史”</h3><p>我们对革命烈士理应表现出就有的尊敬，却不必通过无节制渲染暴力的方法，强化这种尊敬，何况这种渲染未必与历史的真相相符。最近看了国民党上海市长吴国桢的回忆录，他曾逮捕过数百名地下党，几乎都有迅速招供的纪录，这让他百思不得其解，心想难道这共产党内就没有誓死不吐秘密的汉子吗？他花了番心思考察，甚至仔细摘出了列宁的一段话进行分析，列宁曾告诫过搞地下工作的同志，说一定要记住，搞这种特殊工作的人，身体忍受力一定有一个极限。吴国桢发现地下党内部有个万一被捕如何应对酷刑的时间规则，就是在被捕后一定要坚守至二十四小时，最多到七十二小时即可开口，过了此期限招供即不算变节，因为人的身体忍耐是有一个限度的，超过这个极限就会难以忍受，二十四小时的设计是为了更多的同志有转移的时间，而非一味地要求被捕同志坚忍不招，可见再有信仰的身体也有一个承受极限。所以，历史的真相，特别是身体受耐疼痛的真相不应被过度浪漫化。“痛史”如果真能表露真相，其实并不会对那些真正做出牺牲的坚忍战士构成不敬。</p>
<h3 id="为什么有人要为秦桧翻案">为什么有人要为秦桧翻案</h3><p>杨家将屡战不胜自然有它的原因，疆域攻守情势转换非常复杂，战局不是文人喊几句慷慨空话就能扭转，也不是空间大小人口多寡就能决定胜负。文人好面子，办事却往往毁在这个毛病上。汉代贾谊可算是文人好面子的老祖宗，当年贾谊就觉得匈奴占据的土地面积不过是汉朝的一个大县，觉得堂堂天朝，“以天下之大，而困于一县之小”，很感羞耻。其实当时处理与匈奴关系有多种选择，比如开放边界贸易，和平交往相处，等等。贾谊却觉得匈奴都是禽兽之类，哪有资格和汉人平起平坐，和禽兽平等贸易简直是“以大事小”，面子上说不过去。唯一可以接受的办法就是逼胡人“纳贡”，“纳贡”就是“以小事大”，匈奴要用进献礼品的方式承认汉代的威仪，然后接受天朝赏赐，这样的交换多有面子啊！匈奴也不是傻子，正好利用进贡机会大搞走私，于是历朝历代进贡的队伍越来越庞大，经常是上千人的规模。天朝都得管吃管住，还是对走私睁一眼闭一眼假装不知，最后不堪重负，只好诏令裁减纳贡队伍，又招致北方民族的不满，因为北方族群的生活很大一部分必需品是靠汉人王朝提供的，纳贡渠道本来就狭窄，又缺乏其他正当的商贸途径，如果再受限制，就只好不断攻入内地劫掠谋生了。不断的抢劫骚扰又为王朝发动军事征剿提供了借口，文人主战的喧嚣声浪也会随之汹涌地推波助澜，丝毫不考虑战争的高额成本可能带来的灾难。好战声音与劫掠周期混杂相伴，恶性循环，直到闹得不可收拾。</p>
<h3 id="汉奸随想">汉奸随想</h3><p>讽刺的是，京都这牧歌式的庭院氛围据说还是拜中国人梁思成所赐，他在地图上标明了主要建筑的位置，避免了美国飞机的轰炸。最近有新闻说京都要立梁氏的铜像，听到这个消息我不但没觉得高兴，反倒好像重重挨了一记耳光，因为在我看来，梁氏当年极力想保护的北京城被拆得如此七零八落，和京都相比犹如一块凄惨的文化废墟。去了京都后，你会憎恨自己怎么如此轻易地就成了“哈日 一族”。也由此理解了当年周作人成为“汉奸”的悲苦和无奈，他笔底的文采深深染有日式的气息，可又如中国文化品味的残留物。我想那种无奈一定是寒彻骨髓的，自己的文化被邻居拿去后变成了真正的精神资源，而我们却通过破坏源远流长的文明不断作践自己，在这种自杀式的或自我阉割式狂欢中还冠冕堂皇地大谈民族振兴，振兴的标准据说是某个国力指标超过日本。可在我看来，北京和京都比，就像一个败家子把自己家房子拆了，搭了一个劣质的仿造品，还硬说是文明的再造和进步。</p>
<h3 id="我看“八十年代”">我看“八十年代”</h3><p>八十年代的魅力就在于它有太多的不确定性：不确定的政治走向，不确定的经济前途，不确定的文化变革，不确定的人生选择。又有太多的问题：姓资姓社的可能，民主自由的可能，调侃主流思想的可能，甚至是性解放的可能。那味道有点像晚清的乱世，也有那么点民国肇始时没皇帝管着的撒欢和散漫。我还记得第一次看人体画大展，人们遭遇女性裸体时最初的羞涩表情，和犹豫片刻蜂拥贴近的饥渴感，冲动而又茫然。可这些不确定在九十年代以后全都消失了。当裸体画进入网络可以随意浏览时，人们的视觉开始麻木。倘若那画师拿着九十年代的画像到处问，得到的回答恐怕就不是方巾和胡须了，而是像美国、“像某个西方大师”或者“像麦当娜”，再说得严重点，美国和西方不是方巾和胡须，而是那画家所提示的”形体“。我们的生活、思想和行为越来越从形体上被描绘出来了，可惜那“形体”往往不是我们自己的，因为有人一指认就说这太像美国啦，那太像西方某个人啦，从貌似高雅的学院到低俗不堪的欢场，一系列的生活节奏都可以从中找到依据、线索和偶像。大家活得是否愉快我不知道，但都活得越发有规有矩恐怕没人否认。因此，我以为，人们怀念八十年代，是怀念只能说出方巾、衣服和胡须的那种感觉和时刻。<br>我还以为，可怕的不在于人们津津乐道于各种方巾、衣服和胡须，或描绘不出八十年代的准确轮廓，那恰恰可能是一种时不再来的动人状态，可怕的是那些怀念八十年代的人，或那些在八十年代画像里曾经扮演过方巾、衣服、胡须角色供人们指认甚至崇拜的人，好像也只能活在怀旧的阴影里。他们有些变成了娱乐文化的宠儿，如尼采专家转行大写轻飘飘的人生箴言呓语，原本辛辣犀利的愤青作家转而对女儿说起了私房悄悄话，富有诗性的“棋王”变成了影视听觉盛宴的技术写手，当年说出“我不相信”的急进诗人却开始琐碎地唠叨大院父辈的夕阳晚年，等等。他们说是给八十年代画像，其实更多谈的是九十年代的失落，颓唐的暗恋中满是英雄迟暮无奈退场的感伤。八十年代好像不是为后来的时代提供了养分，而是为后人掘出了一个思想坟墓。这才是最可怕的，它让我们看不到希望！我们看不到这些当年扮演方巾和胡须的英雄后续的英雄故事，也看不出他们九十年代以后的表现和八十年代有什么连续继承的关系。这一点陈丹青也在访谈中说过，崔永元做怀念老电影的节目，意思是向老一辈致敬，可是这档节目和美国的区别在于，人家好莱坞越怀旧越得意，虽说已不及黄金时代，但仍有资本对过去怀抱敬意。怀旧是为未来打气，是自信的表现，意思是咱们现在照样可以牛逼。而崔式怀旧则是以悔恨、抱怨的心理在怀旧，怀旧是为了诅咒今天，我们时时能从《八十年代访谈录》中嗅出同样的味道。<br>八十年代以后没有延续性，没有未来！这才是怀念八十年代的真实理由，也是八十年代风云人物退出历史舞台的开始。我只能说，八十年代被纳入怀旧的轨道，恰恰昭示的是现世思想的极度贫乏和无奈。</p>
]]></content>
    
    <summary type="html">
    
      抄几段杨念群写的《生活在哪个朝代最郁闷》。我想，学历史的人生活在现世都有种与常人不一样的郁闷吧
    
    </summary>
    
      <category term="reading" scheme="http://judes.me/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>导出网易博客</title>
    <link href="http://judes.me/2017/01/18/2014-03-22-exportOf163Blog/"/>
    <id>http://judes.me/2017/01/18/2014-03-22-exportOf163Blog/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近想把在网易上写的博客迁移过来，也动手做了。但网易博客貌似只有迁进没有迁出的功能。</p>
<p>google了一下，发现可以xml格式导出博客内容。具体方法是在 ++个人博客中心++个人博客中心 页面的最下方，点RSS按钮，再保存这个弹出的页面就OK了。</p>
<p>之后的工作就是从这个文件提取内容，我只会用python做这种事。</p>
<p>关于XML格式相关基础知识，可以看 <a href="http://www.w3schools.com/xml/" target="_blank" rel="external">这里</a>（w3school）。处理导出的XML文件所用到的XML知识都可以从中找到。</p>
<p>python有处理XML的包（package）：xml，xml包里有好几个子模块：</p>
<blockquote>
<p>xml.etree.ElementTree,<br>xml.dom,<br>xml.dom.minidom,<br>xml.dom.pulldom,<br>xml.sax,<br>xml.parsers.expat</p>
</blockquote>
<p>我没有深入了解它们的差别，有兴趣可以看 <a href="http://docs.python.org/2/library/xml.html" target="_blank" rel="external">这里</a>（官方文档）。官方建议若对DOM不熟悉就使用xml.etree.ElementTre：</p>
<blockquote>
<p>Users who are not already proficient with the DOM should consider using the xml.etree.ElementTree module for their XML processing instead</p>
</blockquote>
<p>使用 xml.etree.ElementTree 的确比较方便。只是xml.etree.ElementTree 对CDATA节点的支持不好，可以说是无视。对以下节点：</p>
<p><code>&lt;title&gt;&lt;![CDATA[title]]&gt;&lt;/title&gt;</code></p>
<p>应用<code>node.txt</code>得到的是<code>title</code>。不过在这次的xml文档处理正好可以利用这个特性。</p>
<p>回过头来说说从网易导出的xml文档，文章标题、发表日期、修改日期、作者都可以轻易解决，唯独 正文 中夹杂着很多html标签，不能直接用。</p>
<p>我用正则表达式来对付正文。只要用空字符串替换匹配的所有html标签就OK。要匹配html标签也很简单，用这个字符串<code>&#39;&lt;/?[^&gt;]+&gt;&#39;</code>就行。</p>
<p>剩下就只有把读取到的内容写进新文件。原本打算用读取得来的title作为写文件的文件名，但python提示错误：</p>
<p><code>IOError: [Errno 22] invalid mode (&#39;w&#39;) or filename</code></p>
<p>没找到解决的办法，这个问题就先留着吧。</p>
<p>废话不多说，上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#encoding:UTF-8&#10;import xml.etree.ElementTree as ET&#10;import re&#10;&#10;tree = ET.parse(&#39;blog163.xml&#39;)&#10;root = tree.getroot()&#10;i = 0&#10;for item in root.iter(&#39;item&#39;):&#10;&#9;#.text&#26041;&#27861;&#24471;&#21040;&#30340;&#23383;&#31526;&#20018;&#26159;Unicode&#32534;&#30721;&#65292;&#38656;&#35201;&#36716;&#25442;&#25104;UTF-8&#32534;&#30721;&#10;    title = item.find(&#39;title&#39;).text.encode(&#39;UTF-8&#39;)&#10;    pubDate = item.find(&#39;pubDate&#39;).text.encode(&#39;UTF-8&#39;)&#10;    postContent = item.find(&#39;description&#39;).text.encode(&#39;UTF-8&#39;)&#10;    pattern = re.compile(r&#39;&#60;/?[^&#62;]+&#62;&#39;)&#10;    patternNBSP = re.compile(r&#39;&#38;nbsp;&#39;)&#10;    result = re.sub(pattern, &#39;&#39;, postContent)&#10;    resultReplaceNBSP = re.sub(patternNBSP,&#39;\n&#39;,result)&#10;    fileName = str(i)&#10;    i += 1&#10;    newFile = file(&#39;blog163/&#39; + fileName + &#39;.md&#39; ,&#39;w&#39;)&#10;    newFile.write(title + &#39;\n\n&#39;)&#10;    newFile.write(pubDate + &#39;\n\n&#39;)&#10;    newFile.write(removResultNBSP)&#10;    newFile.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      折腾了一下，把之前在网易的博客文章导出成md格式
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>《挪威的森林》摘抄</title>
    <link href="http://judes.me/2017/01/18/2014-03-26-extractsOfNorwegianWood/"/>
    <id>http://judes.me/2017/01/18/2014-03-26-extractsOfNorwegianWood/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>绿子说：“我所求的只是容许我任性，百分之百的任性。比方说，我现在对你说想吃酥饼，你就什么也不顾地跑去买，气喘吁吁地跑回来递给我，说：‘喏，绿子，这就是酥饼。’可我却说：‘我又懒得吃这玩意儿了！’说着‘呼’的一声从窗口扔出。这就是我所追求的”</p>
<p>“这和爱似乎不大相干啊！”我不无愕然地说。</p>
<p>“相干！你不知道罢了”，绿子说，“对女孩儿来说，这东西有时非常非常珍贵”。</p>
<p>“就是把酥饼扔出窗口？”</p>
<p>“是啊。我希望对方这样说：‘明白了，绿子。怪我不好，我本该估计到你又不想吃酥饼才是。我简直像驴粪蛋儿一样愚蠢透顶，麻木不仁。为了表示歉意，让我再去给你买点什么。什么好？巧克力饼？还是奶酪饼？’”</p>
<p>“然后怎么样呢？”</p>
<p>“那我就好好地爱他，报答他。”</p>
]]></content>
    
    <summary type="html">
    
      绿子和彻的一段对白。爱是宽容、宠爱与感恩。
    
    </summary>
    
      <category term="reading" scheme="http://judes.me/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈CSS2.1可视化格式模型</title>
    <link href="http://judes.me/2017/01/18/2014-03-27-aboutCss2VFM/"/>
    <id>http://judes.me/2017/01/18/2014-03-27-aboutCss2VFM/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T15:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>近日看了CSS2.1规范文档中对可视化格式模型（visual formatting model）的描述，弄懂了很多之前理解模糊的概念。顺手写写总结，理理思路，以便日后忘记了可以回头看看。</p>
<p>网页上看得到的所有元素都是一个个大小不同、或相互嵌套、或上下堆叠、或水平排列的盒子。</p>
<p>可视化格式模型说的就是如何摆放这些盒子。盒子的布局与以下几个因素有关：</p>
<ol>
<li><a href="http://www.w3.org/TR/CSS21/conform.html#doctree" target="_blank" rel="external">文档树</a>中元素之间的关系；</li>
<li>盒子的类型和尺寸；</li>
<li>定位方案；</li>
<li>其他外部信息（如视点、图片的本征尺寸等）</li>
</ol>
<h2 id="文档树中各元素的关系">文档树中各元素的关系</h2><p>文档树中各元素的关系无非就是祖先、同辈、后代。值得一说的是包含块（containing blocks）的概念。一个盒子在真正被定位时需要一个具体的大环境，盒子被包含在这个大环境之中，这个大环境就是此盒子的包含块，具体来说盒子的包含块是从盒子的某个祖先盒子中挑选出来的，不一定就是它的父亲盒子。因为盒子之内可以嵌套其他盒子，换句话说盒子可以有子孙后代，此盒子也可充当后代盒子的包含块。</p>
<h2 id="盒子的类型、尺寸">盒子的类型、尺寸</h2><p>盒子的类型细分起来有很多种，由 display 属性的值决定。常用的 display属性值有：</p>
<ul>
<li>block<br>  此值可使元素产生块盒子</li>
<li>inline<br>  此值可使元素产生一个或多个行内盒子</li>
<li>inline-block<br>  此值可使元素产生一个行内级块容器。行内级块容器对包含在其内部的元素表现为块盒子，其自身——即对同辈元素及祖先元素而言——是一个原子行内级盒子。</li>
<li>none<br>  此值可使元素不产生任何盒子，其本身、内容、后代元素在格式化结构中消失。同辈元素、祖先元素就当其根本不存在一样。</li>
</ul>
<p>display还有很多其他的取值，在此不作研究。</p>
<p>下面来说说盒子的两大类型：块盒子、行内盒子。</p>
<h3 id="块盒子">块盒子</h3><p>在说块盒子前，要先说说块级元素。块级元素最显著的特征是其开头和结尾处都会另起一行。<a href="http://reference.sitepoint.com/html/block-level" target="_blank" rel="external">这里</a>罗列了所有的块级元素。块级元素会产生块级盒子（准确来说是原始块级盒子），这个块级盒子会充当包含在其内的元素的包含块。</p>
<p>块级盒子在多数情况下（除非它是表格盒子或元素本身是重置元素。重置元素指元素本身的尺寸和外形由外部信息决定，不由CSS决定。images/plugins/form 元素都属于重置元素。<a href="http://reference.sitepoint.com/css/replacedelements" target="_blank" rel="external">此处</a>有更详细的描述）也是块容器盒子。块级盒子与块容器盒子不是包含与被包含的关系，它们之间有重叠的部分，也有不重叠的部分。非重置行内块盒子和非重置表格单元是块容器盒子，但并不是块级盒子。既是块级盒子也是块容器盒子的可被称作：块盒子。</p>
<p><strong>块容器盒子要么只包含块级盒子，要么只包含行内级盒子。</strong>这句话很重要。</p>
<h4 id="匿名块级盒子">匿名块级盒子</h4><pre><code>&lt;<span class="keyword">div</span>&gt;
    Some <span class="type">text</span>
    &lt;p&gt;More <span class="type">text</span>&lt;/p&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>假设div与p的display属性值均为blcok。实际如下图，div标签生成一个块容器盒子，若块容器盒子内包含块级盒子（本例正是此种情况：p为块级盒子），则强制此块容器盒子只包含块级盒子。文本节点“Some text”此时将被一个匿名块级盒子包裹。</p>
<p><img src="!--￼0--&gt;/2014/03/anon-block.png" alt="anonymous_block_boxes"></p>
<p>产生匿名块级盒子的情况是，当一个行内盒子包含一个流内（in-flow，流在这里指常规流）块级盒子时，这个行内盒子会被块级盒子腰斩成两个匿名块级盒子。由此形成的三个块级盒子是同辈的关系。匿名块级盒子还有很多细节，详见<a href="http://www.w3.org/TR/CSS21/visuren.html" target="_blank" rel="external">文档</a>。</p>
<h3 id="行内盒子">行内盒子</h3><p>与块级元素和块级盒子对应的是行内级元素和行内级盒子。</p>
<p>行内级元素与块级元素相反，它不会在开头和结尾处另起一行，<a href="https://developer.mozilla.org/en-US/docs/HTML/Inline_elements" target="_blank" rel="external">这里</a>罗列了所有的块级元素。行内级盒子由行内级元素产生。</p>
<p>与块级盒子一样，并不是所有的行内级盒子都是行内盒子，由重置行内级元素、inline-block元素、inline-table元素产生的行内级盒子就不是行内盒子，这些盒子被称为原子行内级盒子。</p>
<h4 id="匿名行内盒子">匿名行内盒子</h4><p>也存在匿名行内盒子，见下面的例子。p产生的块容器盒子内不包含块级盒子，却包含一个行内盒子（由em产生），此时将强制p产生的块容器盒子只包含行内盒子。文本节点“Some”和“text”将被一个匿名行内盒子包裹。匿名行内盒子还有很多细节，详见<a href="http://www.w3.org/TR/CSS21/visuren.html" target="_blank" rel="external">文档</a>。</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>Some<span class="tag">&lt;<span class="title">em</span>&gt;</span>emphasized<span class="tag">&lt;/<span class="title">em</span>&gt;</span>text<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p><strong>盒子的尺寸</strong></p>
<p>盒子的尺寸并不受限与包含块，若比包含块的尺寸要大，盒子将会溢出。</p>
<h2 id="定位方案">定位方案</h2><p>定位方案分以下三种：</p>
<ol>
<li>常规流；</li>
<li>浮动；</li>
<li>绝对定位；</li>
</ol>
<h3 id="常规流">常规流</h3><p>只要元素没有被设置为浮动或绝对定位，元素就位于常规流之内（否则称之为脱离常规流），采用常规流定位。</p>
<p>位于常规流内的元素，其产生的盒子要么处于块格式化上下文要么处于行内格式化上下文。理所当然地，块级盒子参与构成块格式化上下文，行内级盒子参与构成行内格式化上下文。</p>
<p><strong>块格式化上下文</strong></p>
<p>浮动元素、绝对定位元素、不是块盒子的块容器（如inline-block等）、设置overflow属性值且值不为visible的块盒子都将会为其内容（内容是一个术语，对其准确解释见<a href="http://www.w3.org/TR/CSS21/conform.html#doctree" target="_blank" rel="external">这里</a>）产生一个新的块格式化上下文。</p>
<p>在块格式化上下文之中，所有盒子都将从包含块的顶部开始，从上到下垂直堆叠，它们之间的垂直间距由margin属性确定，两个相邻的块级盒子之间还将发生垂直边距的塌陷（collapse）。每个盒子的左外边缘将与包含块的左边缘（这里指内容的的左边缘）重合。</p>
<p><strong>行内格式化上下文</strong></p>
<p>在行内格式化上下文之中，盒子将从包含块的顶部开始，从左到右排布。盒子的垂直对齐方式有：顶部对齐、底部对齐、基线对齐。</p>
<p>这里还有一个重要的概念：行盒子（line box），行内盒子排成一行，这一行就形成行盒子。</p>
<p>行盒子的宽度由两点决定：包含块的宽度、浮动的存在与否。行盒子的高度是个比较复杂的问题，详见<a href="http://www.w3.org/TR/CSS21/visudet.html#line-height" target="_blank" rel="external">此处</a>,行盒子的高度永远大于或等于其包含的盒子。</p>
<p>除去存在浮动的情况，行盒子的左边缘将与包含块的左边缘重合。</p>
<p>当构成行盒子的所有行内级盒子的总宽度比行盒子的宽度要短时，行内级盒子的水平排布方式将由行盒子的text-align属性决定。反过来，当一个行内盒子的宽度比行盒子的宽度要大，行内盒子将被分割成几个行内盒子摆放在几个行盒子当中，除非这个行内盒子被设置为不可分割的，这种情况下，行内盒子将会溢出行盒子。</p>
<p>行盒子的相关细节比较多，详见<a href="http://www.w3.org/TR/CSS21/visuren.html#positioning-scheme" target="_blank" rel="external">文档</a>。</p>
<h3 id="浮动">浮动</h3><p>只要元素设置float属性值且其不为none，元素就将会脱离常规流且尽可能向左（或右）移动。<br>（这里的内容指文本、行内元素）可能会排布在浮动的周围。</p>
<p>元素产生的浮动盒子将一直向左（或右）移动直到它的外边缘与包含块的边缘或者其他浮动的外边缘重合。如果此时存在同辈的行盒子，浮动将与行盒子的顶部垂直对齐。</p>
<p>如果当前的水平空间不足以容纳浮动，浮动将会下移到要么放得下它要么只有它一个浮动的地方。</p>
<p><strong>浮动盒子脱离常规流，所以块盒子在布局时视它为无物，但行盒子却受其影响，紧邻浮动的行盒子会排布在浮动的周围，前提是浮动的高度（outer height，算上padding、border、margin）是个正值，</strong>这是文字围绕图片的原理。</p>
<p>浮动的外边距从不与相邻的其他盒子发生塌陷。</p>
<p>浮动可以覆盖（overlap）处于常规流中的其他块盒子。如果发生覆盖，浮动将呈现在块盒子的前面（前面指的是更接近用户），而在行内盒子的后面。</p>
<p>浮动的盒子除了尽可能向左（或右）移动之外，它还尽可能向上移动，当两者冲突时，它会选择尽量向上移动。</p>
<p>设置元素的clear属性，可使其左侧（或右侧，或两侧）不与浮动相邻。</p>
<p>浮动的还有不少细节，详见<a href="http://www.w3.org/TR/CSS21/visuren.html#positioning-scheme" target="_blank" rel="external">文档</a>。</p>
<h3 id="绝对定位">绝对定位</h3><p>设置元素的postion属性值为 absolute 或 fixed 可使元素采用绝对定位，此时元素脱离常规流。</p>
<h3 id="display、position和float的关系">display、position和float的关系</h3><ol>
<li>如果display设置为none，则position和float属性无论为何值都不会生效，元素不产生盒子；</li>
<li>否则，当position设置为absolute或fixed时，float属性的计算值为none，display属性的计算值如下表。盒子的位置为包含块及top/right/left/bottom等值确定；</li>
<li>否则，当float为非none的值时，其display属性的计算值如下表；</li>
<li>否则，当元素为根元素时，display属性的计算值如下表，有一种例外情况就是声明值为list-item其计算值可以是block或者list-item；</li>
<li>否则，其他的dispaly属性值表现为其声明的值。</li>
</ol>
<pre><code><span class="header">specified value                        computed value
------------------------------------------------------</span>
<span class="header">inline-table                                  table
------------------------------------------------------</span>
inline,inline-block,table-row-group,
table-column,table-column-group,
table-header-group,table-footer-group,         block
<span class="header">table-row,table-cell,table-caption
------------------------------------------------------</span>
others                                same as specified
</code></pre><h2 id="参考资料">参考资料</h2><p>Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification, <a href="http://www.w3.org/TR/CSS21/visuren.html" target="_blank" rel="external">Visual formatting model</a>;</p>
<p>Github上面的一篇同主题<a href="https://github.com/sunnylost/sunnylost.github.com/blob/master/draft/css-visual-formatting-model.md" target="_blank" rel="external">文章</a>;</p>
<h2 id="后记">后记</h2><p>关于可视化格式模型，还有很多知识点没有谈及，比如视点，相对定位，绝对定位时包含块的选择，z-index，等等。写技术文章很辛苦，而且总感觉挂一漏万，不过写技术文章有且于内化知识，也算是一道苦口良药吧。</p>
]]></content>
    
    <summary type="html">
    
      对CSS2.1可视化格式模型的一些总结
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>width属性取100%时与inherit的区别</title>
    <link href="http://judes.me/2017/01/18/2014-03-31-widthPercentageAndInherit/"/>
    <id>http://judes.me/2017/01/18/2014-03-31-widthPercentageAndInherit/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>width属性不可继承，默认值是auto。</p>
<p>元素的width属性值为percentage时，width是根据其包含块的width计算的，如果其包含块的width反而是根据此元素的width计算出来的，这种情况CSS2.1未定义。</p>
<p>元素的width属性值为inherit时(inherit可用于那些不可继承的属性上)，其继承的是父元素width属性的声明值(specified value)。</p>
<p>声明值(specified value)按以下三个原则取值：</p>
<ol>
<li>如果元素样式表中有定义（无论是由作者、用户、还是浏览器定义）属性及其值，则其为声明值；</li>
<li>否则，如果元素并非文档树的根，且属性是可继承的，则从其父元素继承声明值（继承父元素相应属性的计算后的值(computed value)）；</li>
<li>否则，声明值为元素对应属性的默认值。</li>
</ol>
<p>借用知乎上的一个例子：</p>
<pre><code><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
    <span class="id">#d0</span><span class="rules">{<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">300px</span></span></span>;}</span>
    <span class="id">#d1</span><span class="rules">{<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100%</span></span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">10px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#ddd</span></span></span>;}</span>
    <span class="id">#d2</span><span class="rules">{<span class="rule"><span class="attribute">width</span>:<span class="value">inherit</span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">10px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#ccc</span></span></span>;}</span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"d0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"d1"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"d2"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>没有id的那个div，其width值为auto，d2的width实际上也是auto。因为width取值为auto时，margin及padding将向内压缩内容,所以d2的width只有280px。而d1的width根据div算出是300px，因为还有20px的padding，所以d1会溢出。</p>
<p>###参考文献</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/specified_value" target="_blank" rel="external">容易理解的对specified value的解释</a></li>
<li><a href="http://www.w3.org/TR/CSS2/cascade.html#specified-value" target="_blank" rel="external">更准确的specified value解释</a></li>
<li><a href="http://www.w3.org/TR/CSS21/visudet.html#the-width-property" target="_blank" rel="external">visual formatting model details中width属性值的说明</a></li>
<li><a href="http://www.w3.org/TR/CSS21/cascade.html#value-def-inherit" target="_blank" rel="external">Assigning property values, Cascading, and Inheritance中对inherit值的说明</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      width属性取100%时与inherit的区别
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么eval里面要加圆括号？</title>
    <link href="http://judes.me/2017/01/18/2014-05-18-eval-why/"/>
    <id>http://judes.me/2017/01/18/2014-05-18-eval-why/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 JavaScript DOM 高级程序设计上看到这样一段代码：</p>
<pre><code><span class="keyword">try</span> {
    j = <span class="built_in">eval</span>(<span class="string">'('</span> + s + <span class="string">')'</span>)
} <span class="keyword">catch</span>(e){
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">"parseJSON"</span>);
}
</code></pre><p>为什么eval内部的 s 要用圆括号围起来呢？</p>
<p>书上的解释：因为 s 是JSON格式的数据，形式是这样的：<code>{key1:val1,key2:val2}</code>，其中“｛”操作符具有语法上的二义性：它既可以定义一个语句块，也可以表示对象字面量，用圆括号围起来是让它表示对象字面量。</p>
<p>如果要深入了解背后的原理，就要先知道几个概念：语句、表达式及分组操作符。</p>
<p>以下内容引自<a href="http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html" target="_blank" rel="external">代码之谜（二）- 语句与表达式</a>：</p>
<blockquote>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；</p>
<p>“语句”（statement）是执行某种操作，没有返回值。</p>
</blockquote>
<p><strong>表达式的特点</strong>：</p>
<ul>
<li>会返回一个值</li>
<li>可放在任何一个需要值的地方</li>
<li>存在于表达式上下文当中</li>
<li>表达式的一部分也是表达式</li>
<li>表达式可以代替（本该出现的）语句，此时的表达式称为表达式语句</li>
</ul>
<p><strong>语句的特点</strong>：</p>
<ul>
<li>不会返回值</li>
<li>存在于语句上下文中</li>
<li>语句不能代替（本该出现的）表达式，例如不能把语句作为函数的参数</li>
</ul>
<p>圆括号：()，是分组操作符，<strong>分组操作符只能包含表达式</strong>。</p>
<p>还需要知道的一点是，<strong>eval会将其参数放进 语句上下文 中解释</strong>。</p>
<p>我们要传进eval中解释的是一个对象字面量，是一个值。所以要传进去的是一个表达式，如果不加圆括号，这个表达式就会被解释成表达式语句，圆括号可在语句上下文内产生新的一个表达式上下文来避免这一点。</p>
<p><strong>参考文献</strong></p>
<ul>
<li><a href="http://www.2ality.com/2012/09/expressions-vs-statements.html" target="_blank" rel="external">Expressions versus statements in JavaScript</a></li>
<li><a href="http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html" target="_blank" rel="external">代码之谜（二）- 语句与表达式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      关于eval、分组操作符、语句及表达式
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>一个应用JSONP的例子</title>
    <link href="http://judes.me/2017/01/18/2014-05-26-JSONP/"/>
    <id>http://judes.me/2017/01/18/2014-05-26-JSONP/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript出于安全考虑，禁止跨域访问资源。跨域是指以下情况：各级域名、端口、协议有任何一处不相同。</p>
<p>因此AJAX是不能跨域请求数据的。但在页面中载入来源指向其他域的 script 标签却可以跨域下载javascript脚本。这种使用 script 标签从别的域请求数据的技术又叫JSONP。</p>
<p>JSONP只能用 GET 方式获取数据。</p>
<p>在ADS这本书中也提到JSONP，作者使用动态生成的 script 元素来模拟XMLHttpRequest对象。</p>
<p>下面是实现的部分关键代码，初次看到的时候还没有看懂，特别是服务器端用PHP写的返回数据部分。</p>
<pre><code>XssHttpRequest.prototype ={
    <span class="comment">//...省略部分代码</span>
    open:<span class="function"><span class="keyword">function</span>(<span class="params">url,timeout</span>)</span>{

        <span class="comment">//...省略部分代码</span>

        <span class="comment">//以下代码将一个名为XSS_HTTP_REQUEST_CALLBACK的变量附加到URL</span>
        <span class="comment">//传给服务器，用以指定回调函数的名称</span>
        <span class="keyword">this</span>.url = url
            + ((url.indexOf(<span class="string">"?"</span>) != -<span class="number">1</span>) ? <span class="string">"&amp;"</span> : <span class="string">"?"</span>)
            + <span class="string">"XSS_HTTP_REQUEST_CALLBACK="</span>
            + <span class="keyword">this</span>.requestID
            + <span class="string">"_CALLBACK"</span>;

        <span class="comment">//...省略部分代码</span>

        send:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
         <span class="comment">//...省略部分代码</span>
         <span class="comment">//以下代码生成javascript标签，但并没有赋给它src属性值，也没有将它加入DOM。</span>
        <span class="keyword">this</span>.scriptObject = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);
        <span class="keyword">this</span>.scriptObject.setAttribute(<span class="string">"id"</span>,<span class="keyword">this</span>.requestID);
        <span class="keyword">this</span>.scriptObject.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);

         <span class="comment">//...省略部分代码</span>
         <span class="comment">//以下代码十分关键，在window环境中创建（声明）一个名为</span>
         <span class="comment">//this.requestID+"_CALLBACK"的方法，JSON参数是服务器返回的数据</span>
         <span class="built_in">window</span>[<span class="keyword">this</span>.requestID + <span class="string">"_CALLBACK"</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">JSON</span>)</span>{
            <span class="comment">//...省略部分代码</span>

            requestObject.responseJSON = <span class="built_in">JSON</span>;
        }
        <span class="comment">//...省略部分代码</span>
        <span class="comment">//此时再设置script标签的src属性及将其进入DOM</span>
        <span class="keyword">this</span>.scriptObject.setAttribute(<span class="string">"src"</span>,<span class="keyword">this</span>.url);
        <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];
        head.appendChild(<span class="keyword">this</span>.scriptObject);

        <span class="comment">//...省略部分代码</span>
        <span class="comment">//以下是回调函数，</span>
        req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
            <span class="keyword">switch</span> (req.readyState) {
               <span class="comment">//...省略部分代码</span>
                <span class="keyword">case</span> <span class="number">3</span>:
                    <span class="comment">// Interactive</span>
                    <span class="keyword">if</span>(options.ineractiveListener) {
                        options.ineractiveListener.apply(req,<span class="built_in">arguments</span>);
                    }
                    <span class="keyword">break</span>;
                <span class="comment">//...省略部分代码</span>
            }
        };
</code></pre><p>服务器端PHP可以这样写：</p>
<pre><code>&lt;?php
header(<span class="string">'Content-type: text/javascript'</span>);
//只允许回调函数存在数字、字母和下划线
<span class="variable">$callback</span> = preg_replace(
    <span class="string">'/[^A-Z0-9_]/i'</span>,
    <span class="string">''</span>,
    $_GET[’XSS_HTTP_REQUEST_CALLBACK‘]
);
<span class="keyword">if</span>($[callback]){
    <span class="variable">$date</span> = date(<span class="string">'r'</span>);
    echo
//这是PHP输出字符串的一种方法，这里的 JSON只是作为定界符
&lt;&lt;&lt;JSON
//使用大括号可在字符串中输出变量，所以以下内容其实是一个函数调用，
//传入一个json对象作为参数
{<span class="variable">$callback</span>}({
    message: <span class="string">'response on {$date}'</span>
});
JSON;
}
?&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      ADS上一个JSONP的例子，服务器得知请求端函数名的具体实现
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>关于setTimeout二三事</title>
    <link href="http://judes.me/2017/01/18/2014-07-03-aboutSetTimeOut/"/>
    <id>http://judes.me/2017/01/18/2014-07-03-aboutSetTimeOut/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:37:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器中的javascript引擎是单线程的，如果在setTimeout设定的时间到达时，javascript引擎还在处理另外的代码，那么setTimeout设定的事件就只有排队等待了。所以一般来说setTimeout设定的时间都是不准确的，会比设定的晚。就算setTimeout时间设定为0,也不一定马上执行，这样设定是把想执行的函数放在javascript引擎执行队列的末尾。</p>
<p>浏览器内部是多线程的，包括：GUI线程、javascript引擎线程、定时器线程、事件线程、http请求线程等。我们能使用定时器是因为浏览器会为setTimeout开一个定时器线程。我们能使用ajax实现异步请求也是因为浏览器能为其开一个http异步请求的线程。</p>
<p>setTimeout和setInterval接受的第一个参数可以是字符串，javascript会隐式调用eval函数来解析这个字符串，这种情况下解析后的字符串将在全局作用域中执行。会产生意想不到的后果。而且定时器（包括setTimeout和setInterval）不是ECMAScript的标准。各家浏览器在一些实现的细节上各有不同，比如如何解析字符串参数在不同的javascript引擎实现中可能不同。所以十分不建议使用字符串作为定时器的第一个参数。</p>
<p><strong>参考文献</strong></p>
<ul>
<li><a href="http://ejohn.org/blog/how-javascript-timers-work/" target="_blank" rel="external">How JavaScript Timers Work</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/web/1105_chengfu_jsworker/index.html" target="_blank" rel="external">JavaScript 工作线程实现方式</a></li>
<li><a href="http://www.phpv.net/html/1700.html" target="_blank" rel="external">JavaScript可否多线程? 深入理解JavaScript定时机制</a></li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#intro" target="_blank" rel="external">JavaScript 秘密花园</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      定时器与javascript引擎、浏览器及eval函数
    
    </summary>
    
      <category term="frontend" scheme="http://judes.me/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>大鱼</title>
    <link href="http://judes.me/2017/01/18/2014-07-18-big-fish/"/>
    <id>http://judes.me/2017/01/18/2014-07-18-big-fish/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>读大学时看过一遍《大鱼》这部电影，那时没有看懂，感觉豆瓣评论中对它的评分太高，不就是一个老头子总是在讲故事嘛，而且很奇怪，他最后变成一条大鱼游走了。</p>
<p>近日因为看到一组电影截图（就是老爷子年轻时追求妻子的故事）觉得很有趣所以就又看一遍，看完觉得电影跟书一个道理，在人生的不同时候看会有不一样的感想。</p>
<p>电影中的父亲从儿子小时候就讲故事给他听，讲的恰恰是自己的故事。电影有趣及有意义的地方就在这一点设定上。</p>
<p>现实生活中，大人们很少会向小孩子们讲述他们自己的故事，即使有过，也是极为平面化、说教意味浓重的、情节简单的成功（或失败）故事。况且市面上儿童故事书汗牛充栋，大人们也用不着每天工作后绞尽脑汁编故事，这对想像力的一大挑战，恐怕他们不敢面对。</p>
<p>父亲一周大部分时间都在跑业务，回到家把工作中遇到的事、接触到的人，加点“调味料”化作奇幻故事讲给儿子听。单从这一点就可以看出父亲其是很爱儿子的。</p>
<p>当然他并不只是讲给儿子听，他爱讲故事，逮住机会就讲，很表演欲。他不在乎别人信与不信。</p>
<p>他身边所有的人都喜欢他，唯独儿子觉得很丢脸，十年如一日地听父亲讲述同样的故事，早已失去新鲜感，每当父亲起个话头就压不住心中那股厌恶。也难怪，这是另外一种唠叨。</p>
<p>但为什么同样听了这么多年的母亲及旧友没有感到厌恶呢？我想他们都明白到一个道理：现实总是枯燥乏味的，与平淡无趣的真相相比，更愿意相信奇幻刺激的故事。还有，尊重一个人活着的方式。电影里有过儿子与父亲独处时，儿子表达了自己希望能从父亲口中听到哪怕一点点关于父亲的真实的往事，他觉得自己一直以来都不清楚真实的父亲是什么样的。但父亲很生气，说自己一直在展示着真实的自己，看不出来是儿子的问题。爱讲故事且固执，就是真实的父亲吧。</p>
<p>除去现实中父与子的冲突这个看点，电影里的故事也都是很有意义的。我想一个父亲能教给儿子的道理都已概括在这些故事当中。</p>
<p>最开始的那个结伴去找小镇巫女的故事，因为能从巫女的眼睛看见自己是怎样死的，故事的主角——父亲——日后去冒险就有了强力的支持，因为他看出了自己不会因此而死。这个故事能让电影更好地展开，但也是父亲对儿子尝试未知、面对恐惧的一种鼓励：It won’t kill you !</p>
<p>还有闯进生活安逸、歌舞升平的丰都小镇，遇到了钟情自己的小女孩珍妮，看到了诗人的才华被这种安逸糟蹋剩下三句蹩脚诗，醒悟到温柔乡中最能消磨意志，最终令人一事无成，当晚下定决心即使没有了鞋子都得离开。。</p>
<p>最出彩的故事当属父亲遇到未来的妻子以及花尽心思去追求她。时间会在你遇到命中注定的另一半时突然静止，但它一旦恢复又像流星飞逝。你还没明白过来的时候，伊人早已消失得无影无踪。这是十分细致真实的描写。</p>
<p>父亲花三年时间无偿当苦力，就为了每个月能从黑心老板口中听到一件关于她的事。这是段励志的经历，虽然笨了点，但有时候人就得靠这种日积月累的咬牙坚持才能靠近目标。</p>
<p>追求妻子的那段简直就可以当阜追女孩教科书了。首先即使没有好机会，也得<strong>大胆</strong>作个自我介绍，给人留下阳光的印象。其后得有足够足够厚的<strong>脸皮</strong>，扛得住当头一棒。继之以花样百出的<strong>投其所好</strong>，无非就是惊喜以及足以引起她闺蜜羡慕嫉妒的举动。最后就是<strong>把其他竞争对手比下去</strong>。</p>
<p>我估计没有多少父亲会把追女孩子的心得教给儿子，就算有，也没有比这个好。</p>
<p>其他故事，如身体突然长大、在小镇充当全能明星、带领巨人走出小镇、说服双生女逃到美国、与诗人抢劫银行、再回丰都镇，大多都渲染了电影的奇幻色彩，与珍妮久别重逢的那段也刻画了父亲对妻子的忠诚的形象。</p>
<p>电影中的最后一个故事，由儿子讲，讲的正是父亲最后的结局如何。这个设定有双重意义，一是预示着儿子最终理解了父亲，并愿意用父亲最擅长的方式为这个传奇故事划上句号，二是揭开了父亲从巫女眼中看到了什么：他最终会变成一条大鱼，一个不死的传说。</p>
<p>摘一段电影最后，儿子说的话：</p>
<blockquote>
<p>父亲因为讲了那个故事太多次，以至于他也成为了故事。</p>
<p>就这样，在他身后，故事依然流传，他也就成为了不朽的传奇。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      重看电影《大鱼》，严重剧透，请观影后阅读
    
    </summary>
    
      <category term="life" scheme="http://judes.me/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>川端康成三部名作中的男主人</title>
    <link href="http://judes.me/2017/01/18/2014-08-09-theManInYasunariNovel/"/>
    <id>http://judes.me/2017/01/18/2014-08-09-theManInYasunariNovel/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇小短文只是谈谈自己仅仅读过川端康成的三篇名作（雪国,古都,千只鹤）之后的一些感想。</p>
<p>这三篇作品中的男主，分别是冬季来雪国疗养的岛村、千重子的父亲绸缎批发店老板太吉郞、身份不明的菊治。</p>
<p>先说这三位男主自身的生活状态。岛村美其名曰“舞蹈艺术研究家”，但“他没能亲眼看到西方人的舞蹈”，也“向来不看日本人跳西方舞蹈”，他研究舞蹈艺术，“其实是任意想象”。太吉郞是生意日渐清减的绸缎批发店老板，年轻时他父亲就知道“太吉郞没有天才，难以进步，并想借助麻药的魔力给出奇怪的友禅画稿”，直到中年，“他为了得到一些构图的灵感，经常独自躲进嵯峨的尼姑庵里深居简出”，即便如此，他设计的花样既没有迎合了世人的喜好，也没有令自己满意。菊治，故事中没有描述他的身份、工作和社会地位。</p>
<p>这三位男主的生活状态即便不是可有可无的（如菊治），也给人一种停滞不进、脱离现世的感觉。跟女主的“现世存在感”有很强烈的对比。不管最终是不是图劳的，驹子没有掩饰过自己对岛村的爱；千重子的孝顺、对身世的纠结、对苗子的愧欠，都比他父亲显得要正常很多；太田夫人忘不了菊治的父亲、文子为母亲的出格行为感到羞耻、拼命阻止母亲去见菊治，相比之下，菊治只是一个旁观者。</p>
<p>说到旁观者，这三位男主的确都有一双发现美的眼睛，可以说，虽然他们的内心是空洞的，但却又似海绵般感受到了自然、女性满满的美。雪国中的例子数不胜数，开场不久映在列车窗玻璃上的叶子的脸庞和映着晨雪与朝阳的梳妆镜中的驹子，夕照下冷峻的群山和边上寂静挺直的杉树。古都中太吉郞到南神寺附近看房子时“在门前伫立，欣赏着胡枝子白花，看得都入迷了”，“或许是对那一溜胡枝子白花恋恋不舍吧，走了七八步，又独自折回去再观赏一番”。千只鹤中菊治自从注意到雪子的千只鹤包袱皮就念念不忘。</p>
<p>这三位男主心里都有“两位”女性，一位是已经追求到手或者是与自己亲近的，很真实且有个性，而另一位则是远远观望，只有过简短的接触，显得很纯洁美好。雪国中的驹子、叶子；古都中的太吉郞在七轩中遇到的年轻艺妓、在电车中见到的小千子；千只鹤中的太田夫人、文子和雪子。男主对前一位不敢说有爱，他只是被动地接受，而对后一位也没有主动热烈的追求。（这一点对太吉郞来说有点牵强）</p>
<p>总的来说，这三位男主的存在感不弱，但真正属于自身的内容并不多，与女主相比显得有点虚空。</p>
]]></content>
    
    <summary type="html">
    
      川端康成擅长描写女性，他书中出现的男性则往往是为了展现女性美。
    
    </summary>
    
      <category term="reading" scheme="http://judes.me/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>奢餐，绝食，读《玻璃天》偶感</title>
    <link href="http://judes.me/2017/01/18/2014-08-24-yedushu/"/>
    <id>http://judes.me/2017/01/18/2014-08-24-yedushu/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>  “我不想在那里和他们同桌吃饭，是因为那里有精美的菜肴。您大概不知道那些菜肴的价格吧？”</p>
<p>  “……不知道。我在一个餐厅吃过晚餐，记得是五块钱左右。”</p>
<p>  “是吗？我想，如果您知道我的部下们老家的生活状况，您一定会感到震惊的，五块钱对他们来说是个什么金额。别说地方上，就是在东京，很多人天不亮开始不停地工作，干一天也只能到手五六毛钱。” </p>
<p>  我无言以对。</p>
<p>  “有五块钱的话，就可以让五十个饥饿的人吃上一顿咖喱饭……如果有众多那样的人能够挺直胸膛，高高兴兴地加入到您所说的行进队伍里的话……不管是一个怎样的队伍，我都会从心底里支持。”</p>
<p>  羞愧这个词，大概就是在这种时候使用的吧。</p>
<p>  “您鄙视我吗？”</p>
<p>  那个人慢慢地摇了摇头。</p>
<p>  “恰恰相反。您有自己的思想。——请不要误解。如果您听了我刚才的话而开始绝食，也是没有任何意义的。我并不希望发生那样的事情。” </p>
<p>  –以上摘自《玻璃天》</p>
<p>  读着上面的对话，不由得联想到前段时间风行一时的 冰桶挑战 。某名人说其家乡正经历严重旱灾，所以不会接受冰桶挑战，但钱一定会捐。也有言论指责 冰桶挑战 已经沦为 纯属浪费水资源的作秀作为。我想，这种指责虽然很动人，但，是没有道理的。贵族小姐听闻民间疾苦后毅然绝食，“也是没有任何意义的”。指责他人浪费水资源，大概就等同指责水的价格为何这么低一样。用水的人已经为水支付相应价格，怎样用是个人喜好。用来洗地顺便淋个浴不也是一种用法么，不脱衣服就是浪费了？</p>
]]></content>
    
    <summary type="html">
    
      夜读书，怎么就跟冰桶挑战扯上关系了呢？
    
    </summary>
    
      <category term="reading" scheme="http://judes.me/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>在 manjaro sublime text 3 中輸入中文</title>
    <link href="http://judes.me/2017/01/18/2014-09-23-typingChineseInSB3/"/>
    <id>http://judes.me/2017/01/18/2014-09-23-typingChineseInSB3/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>网上有不少文档说明怎样在 linux sublime text 中输入中文的，比如<a href="http://c4fun.cn/blog/2013/11/30/linux-sublimetext-chinese/" target="_blank" rel="external">这篇</a>。本人操作系统是 manjaro linux，按照文档操作能在命令行运行能输入中文的sublime text，但要想在桌面上点击图标运行，就出问题了。</p>
<p>一番折腾之后，终于发现点击图标运行能输入中文sublime text的方法，跟着步骤来：</p>
<ol>
<li><p>通过 pacman 安装 sublime text 3 dev 版 和 Fcitx</p>
</li>
<li><p>按照上面提到的那篇文档安装补丁，完成之后就可以在命令行中运行能输入中文的sublime text啦</p>
</li>
<li><p>把 sublime text 放到桌面（不要忘了我们的目标是在桌面上点击运行XD），右键点击找到“编辑启动器”，在“命令”一栏，把原来的<code>subl3 %F</code>替换成<code>bash -c &#39;LD_PRELOAD=/usr/lib/libsublime_imfix.so /opt/sublime_text_3/sublime_text&#39; %F</code>，这跟你在命令行中执行的那条命令本质上是一样的，只是两个文件的路径变成了绝对路径。</p>
</li>
<li><p>没有第四步啊，双击打开就OK啦。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      sublime text 很好用，但不能輸入中文就很蛋疼了。水文一篇
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
  </entry>
  
  <entry>
    <title>gulp task</title>
    <link href="http://judes.me/2017/01/18/2014-09-27-gulp-task/"/>
    <id>http://judes.me/2017/01/18/2014-09-27-gulp-task/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>阅读 <a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">gulp API</a>，有一点要注意的就是：</p>
<p><strong>gulp默认以最大并发执行任务，怎样保证某些任务按顺序（即 task A 在 task B 完成之后）执行呢？</strong></p>
<p>先来看一下gulp task的形式：</p>
<pre><code>gulp.<span class="function"><span class="title">task</span><span class="params">(name[,deps],fn)</span></span>
</code></pre><p><strong>gulp</strong> 用 <a href="https://github.com/orchestrator/orchestrator" target="_blank" rel="external">Orchestrator</a> 定义一个任务，Orchestrator 是一个把任务和依赖串联起来并以最大并发执行的模块。所以gulp默认以最大并发执行任务。</p>
<p><strong>name</strong> [string]</p>
<p>任务的名字，如果要在命令行中执行任务，name中不能有空格。</p>
<p><strong>deps</strong> [Array]</p>
<p>任务的依赖，是由一系列任务组成的数组。用意是：要等这一系列任务执行完之后再执行定义的任务。实际上要达到这个目的，光这样写是不够的。接下来会说到。</p>
<p><strong>fn</strong></p>
<p>任务要执行的操作。通常形式是这样的：</p>
<pre><code><span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    gulp.src<span class="params">()</span>.pipe<span class="params">(someplugin<span class="params">()</span>)</span>;
}
</code></pre><p>上面说到要让依赖先执行完毕再启动定义的任务，只在定义任务时写上依赖数组是不够的，要达到这个目的，每个依赖的任务都要是异步执行的。</p>
<p>如果说按顺序排行任务是同步执行的话，那么这里就是通过异步来实现同步：每个异步执行的任务在执行完之后会发一个信号告知gulp，等集齐数组所有的完成信号后再执行定义的任务。（不知道理解得对不对）</p>
<p><strong>fn</strong>采取如下三种形式之一就能让任务变成异步执行：</p>
<p>###传入回调函数</p>
<pre><code><span class="comment">// run a command in a shell</span>
<span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;
gulp.task(<span class="string">'jekyll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>{
  <span class="comment">// build Jekyll</span>
  exec(<span class="string">'jekyll build'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
    <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err); <span class="comment">// return error</span>
    cb(); <span class="comment">// finished task</span>
  });
});
</code></pre><p>###返回一个流</p>
<pre><code>gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> stream = gulp.src(<span class="string">'client/**/*.js'</span>)
    .pipe(minify())
    .pipe(gulp.dest(<span class="string">'build'</span>));
  <span class="keyword">return</span> stream;
});
</code></pre><p>###返回一个promise</p>
<pre><code><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);
gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="keyword">var</span> deferred = Q.defer();

  <span class="comment">// do async stuff</span>
  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    deferred.resolve();
  }, <span class="number">1</span>);

  <span class="keyword">return</span> deferred.promise;
});
</code></pre><p>以下是一个实现 task two 在 task two 执行完毕后再开始执行的例子：</p>
<pre><code><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);

<span class="comment">// takes in a callback so the engine knows when it'll be done</span>
gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>{
    <span class="comment">// do stuff -- async or otherwise</span>
    cb(err); <span class="comment">// if err is not null and not undefined, the run will stop, and note that it failed</span>
});

<span class="comment">// identifies a dependent task must be complete before this one begins</span>
gulp.task(<span class="string">'two'</span>, [<span class="string">'one'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="comment">// task 'one' is done now</span>
});

gulp.task(<span class="string">'default'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>]);
</code></pre><p><strong>以上所有代码来源于 <a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">gulp API</a></strong></p>
]]></content>
    
    <summary type="html">
    
      gulp task 笔记
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
  </entry>
  
  <entry>
    <title>推导 Y 组合子</title>
    <link href="http://judes.me/2017/01/18/2014-10-18-deriving-the-y-combinator/"/>
    <id>http://judes.me/2017/01/18/2014-10-18-deriving-the-y-combinator/</id>
    <published>2017-01-18T14:17:43.000Z</published>
    <updated>2015-07-31T14:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>The Litter Schemer 的第九章，不读到最后，大概你都不知道作者其实是在一步步地推导Y组全子。</p>
<p>什么是Y组合子？答案在<a href="http://zh.wikipedia.org/zh-cn/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90" target="_blank" rel="external">这里</a>。</p>
<p>看不懂？不要紧，记住Y组合子可以做什么就行了：<strong>Y 组合子让我们可以定义匿名的递归函数</strong>。</p>
<p>以下推导采用来自 The Little Schemer 的例子，并为每一步加上注解。</p>
<p>嘿喂狗！</p>
<p>假设我们要写一个求列表长度的 length 函数，很简单是不是？我们之前已经写过了：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">define</span></span> length
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                add1 <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>刚才我们定义了一个叫 length 的函数，现在假设我们不能给这个函数命名，只能使用匿名函数：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
            <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">???</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>忽然间，我们没有办法递归调用上面这个匿名函数了。<code>???</code>是什么意思呢？原本这是函数名字，但匿名函数没有名字嘛～</p>
<p>现在我们唯一可以做的就是用 整个匿名函数 替换 <code>???</code>：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
            <span class="list">(<span class="keyword">add1</span> <span class="list">(

    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>                            <span class="comment">; the</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>                                <span class="comment">;</span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>                <span class="comment">; function</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>                            <span class="comment">; </span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">???</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>    <span class="comment">; itself</span>

             <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>虽然这是一个治标不治本的方法，因为<code>???</code>还藏在函数里面。但这个函数已经可以用来求长度为1或0的列表长度了。如果我们重复上一步：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
            <span class="list">(<span class="keyword">add1</span> <span class="list">(
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(
        <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>                            <span class="comment">; the</span>
            <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>                                <span class="comment">;</span>
                <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>                <span class="comment">; function</span>
                <span class="list">(<span class="keyword"><span class="built_in">else</span></span>                            <span class="comment">;</span>
                    <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">???</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>    <span class="comment">; itself</span>
                 <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>现在这个函数可以用来求长度为0,1,2的列表长度了，你可以这样一直替换下去，直到天荒地老。但这样会很累。而且函数里有大量重复的代码，这样很不好。</p>
<p>我们还是想想别的办法吧。首先，我们把引发重复代码的源头<code>???</code>从函数中提出来，把它当作函数的参数再传进去：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
???)</span>
</code></pre><p>上面的代码首先调用了<code>lambda (length)</code>函数，并且把<code>???</code>当作参数传进去，最终返回了另一个匿名函数：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
            <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">???</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>你没看错，这就是我们最初的那个匿名函数。现在我们用同样的方法——用整个匿名函数替换`???——重写一下可以求长度为0,1列表长度的匿名函数：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
 <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">g</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">g</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
???)</span>)</span>
</code></pre><p>上面的代码首先把<code>???</code>传给<code>lambda(g)</code>函数，然后把返回的函数——就是最初的匿名函数——传给<code>lambda(f)</code>，最终得到：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
            <span class="list">(<span class="keyword">add1</span> <span class="list">(
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">???</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>上面的代码是不是很眼熟？它就是之前那个可以求长度为0,1的列表长度的函数，运用同样的方法可以得到求长度为0,1,2的列表长度的函数：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
 <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">g</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">g</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
  <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">h</span>)</span>
      <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
          <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
              <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
              <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                  <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">h</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
???)</span>)</span>)</span>
</code></pre><p>因为函数的参数名字叫什么都没关系，我们不妨把<code>f,g,h</code>改成更有意义的名字：<code>length</code>：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
 <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
  <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
      <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
          <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
              <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
              <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                  <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
???)</span>)</span>)</span>
</code></pre><p>到这步，我们又写了重复的代码。再一次，我们把重复的部分提出来，写一个<code>mk-length</code>函数帮我们生成<code>length</code>函数：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> ???)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>仔细观察上面的代码，<code>(lambda (mk-length) ...)</code>函数把<code>(lambda (length) ...)</code>函数当作<code>mk-length</code>参数传进去了。而<code>(lambda (length) ...)</code>函数则把<code>???</code>当作<code>length</code>参数，返回最初的匿名函数：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
            <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">???</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>我们利用<code>mk-length</code>再次重写一下求长度为1的列表长度的函数，只需要对原<code>mk-length</code>函数的参数<code>???</code>再调用一次<code>mk-length</code>：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> 
        <span class="list">(<span class="keyword">mk-length</span> ???)</span>)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>分析上面的代码，首先我们把<code>(lambda (length) ...)</code>函数当作<code>mk-length</code>参数传进<code>(lambda (mk-length) ...)</code>函数。这样得到的函数将把<code>(mk-length ???)</code>返回的结果当成参数，还记得<code>(mk-length ???)</code>返回什么吧？没错，就是最初的那个匿名函数。上面的代码展开之后就成了可以求长度为0,1的列表长度的函数了：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
    <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
            <span class="list">(<span class="keyword">add1</span> <span class="list">(
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">???</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>类似地，可以写出求长度为0,1,2的列表长度的函数：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> 
        <span class="list">(<span class="keyword">mk-length</span>
            <span class="list">(<span class="keyword">mk-length</span> ???)</span>)</span>)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>因为我们并不关心<code>???</code>到底是什么东西，不妨把它替换为<code>mk-length</code>：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> mk-length)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>上面这个函数与原版的不同之外就只是原来是<code>???</code>的地方，现在是：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
                 <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
                 <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                     <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>但这不影响我们求长度为0的列表长度，因为根本用不着。让我们改一下函数的参数名字——之前我们做过类似的事情——把<code>length</code>改为<code>mk-length</code>：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> mk-length)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword">mk-length</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>接下来我们要做最关键也是最神奇的一步，把最后面一个<code>mk-length</code>用<code>(mk-length mk-length)</code>替换：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> mk-length)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="list">(<span class="keyword">mk-length</span> mk-length)</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>上面的代码可以计算任意长度列表的长度哦，不信你试试下面这个：</p>
<pre><code><span class="list">(<span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> mk-length)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="list">(<span class="keyword">mk-length</span> mk-length)</span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
 '<span class="list">(<span class="keyword">a</span> b c d e f g h i j)</span>)</span>
</code></pre><p>如果上面的代码太复杂，不妨看看这个简化的例子：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">m</span>)</span>
    <span class="list">(<span class="keyword">m</span> m)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">l</span>)</span>
     <span class="list">(<span class="keyword">l</span> l)</span>)</span>)</span>
</code></pre><p>上面的函数展开之后，还是得到自己！这样它就可以无限循环下去了。我们的<code>mk-length</code>函数也是类似的，只不过因为<code>list</code>长度会不断递减，所以函数最终会停下来。不过我们还没有得出Y组合子，我们还得把Y组合子与真正干活的那部分函数分离开来！</p>
<p>我们先来看看这个：<code>(mk-length mk-length)</code>，它以<code>(cdr list)</code>为参数，事实上，这与下面的函数等价：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span>
    <span class="list">(<span class="list">(<span class="keyword">mk-length</span> mk-length)</span> x)</span>)</span>
</code></pre><p>用上面的函数替换<code>(mk-length mk-length)</code>，得到：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> mk-length)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(

                     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span>
                        <span class="list">(<span class="list">(<span class="keyword">mk-length</span> mk-length)</span> x)</span>)</span>

                     <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>然后我们故技重施，把<code>(lambda (x) ...)</code>提出来：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
    <span class="list">(<span class="keyword">mk-length</span> mk-length)</span>)</span>
 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>

     <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>                                 <span class="comment">;</span>
         <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>                                 <span class="comment">;</span>
             <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>                                    <span class="comment">;</span>
                 <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>                    <span class="comment">;</span>
                 <span class="list">(<span class="keyword"><span class="built_in">else</span></span>                                 <span class="comment">;</span>
                     <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>    <span class="comment">;</span>

    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span>
        <span class="list">(<span class="list">(<span class="keyword">mk-length</span> mk-length)</span> x)</span>)</span>)</span>)</span>)</span>
</code></pre><p>来看看上面代码中间与其他代码隔开来的部分，这部分是真正”干活“的，我们把它提出来：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">le</span>)</span>
    <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
        <span class="list">(<span class="keyword">mk-length</span> mk-length)</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">mk-length</span>)</span>
        <span class="list">(<span class="keyword">le</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span>
                <span class="list">(<span class="list">(<span class="keyword">mk-length</span> mk-length)</span> x)</span>)</span>)</span>)</span>)</span>)</span>

 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>                                 <span class="comment">;</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>                                 <span class="comment">;</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>                                    <span class="comment">;</span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>                    <span class="comment">;</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>                                 <span class="comment">;</span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>    <span class="comment">;</span>
</code></pre><p>就这样，我们得到了两部分代码，上一部分就是Y组合子，把<code>mk-length</code>重命名为<code>f</code>：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">le</span>)</span>
    <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span>
        <span class="list">(<span class="keyword">f</span> f)</span>)</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span>
        <span class="list">(<span class="keyword">le</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span>
                <span class="list">(<span class="list">(<span class="keyword">f</span> f)</span> x)</span>)</span>)</span>)</span>)</span>)</span>

 <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>                                 <span class="comment">;</span>
     <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>                                 <span class="comment">;</span>
         <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>                                    <span class="comment">;</span>
             <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>                    <span class="comment">;</span>
             <span class="list">(<span class="keyword"><span class="built_in">else</span></span>                                 <span class="comment">;</span>
                 <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>    <span class="comment">;</span>
</code></pre><p>为方便以后使用，还可以把上半部分的代码定义为 <code>Y</code> 函数：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">define</span></span> Y
    <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">le</span>)</span>
        <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword">f</span> f)</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span>
                <span class="list">(<span class="keyword">le</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="list">(<span class="keyword">f</span> f)</span> x)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>最后，利用 <code>Y</code> 函数重写<code>length</code>函数：</p>
<pre><code><span class="list">(<span class="list">(<span class="keyword">Y</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span>)</span>
    （lambda <span class="list">(<span class="keyword"><span class="built_in">list</span></span>)</span>
        <span class="list">(<span class="keyword"><span class="built_in">cond</span></span>
            <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">null?</span></span> list)</span> <span class="number">0</span>)</span>
            <span class="list">(<span class="keyword"><span class="built_in">else</span></span>
                <span class="list">(<span class="keyword">add1</span> <span class="list">(<span class="keyword"><span class="built_in">length</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> list)</span>)</span>)</span>)</span>)</span>)</span>)</span>
'<span class="list">(<span class="keyword">a</span> b c d e f g h i j)</span>)</span>
</code></pre><p><strong>参考文献</strong></p>
<ul>
<li><p>原文 <a href="http://www.catonmat.net/blog/derivation-of-ycombinator/" target="_blank" rel="external">Deriving the Y-Combinator</a></p>
</li>
<li><p><a href="http://a-shi.org/blog/2014/10/05/li-jie-y-combinator/" target="_blank" rel="external">理解Y Combinator</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      看不懂 the little schemer 第九章？请看这里
    
    </summary>
    
      <category term="tech" scheme="http://judes.me/categories/tech/"/>
    
    
  </entry>
  
</feed>
